{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Hello and Welcome! 👋","n":0.5},"1":{"v":"\nWelcome to the homepage! I use Dendron to store and organize notes, ideas, and experiments I’m working on. Here are the main sections you’ll find on this site:\n\n1. **Learning Notes** — Practical notes on programming, recent technologies, and productivity tips.\n2. **Personal Projects** — Summaries of projects, experiments, and outcomes I’m working on or have completed.\n3. **Writings & Opinions** — Casual articles and reflections about technology, daily life, and other interesting topics.\n\nI’m constantly experimenting and learning. I hope the content here helps you as a reference, a starting point for discussion, or just light reading.\n\n> Why Dendron?\n>\nDendron helps keep notes organized. Its \"seed\" and \"vault\" concepts make it easy to structure content and find what you need.\n\n## Find More\n\nIf you want to learn more or connect, check these links:\n\n- [Homepage (Dendron)](https://zeihanaulia.github.io/sotoy/)\n- [My GitHub](https://github.com/zeihanaulia)\n- [My Twitter / X](https://x.com/zeihanaulia)\n\nThanks for stopping by. If you have feedback or want to chat, feel free to reach out.\n","n":0.081}}},{"i":2,"$":{"0":{"v":"Today I Learned","n":0.577}}},{"i":3,"$":{"0":{"v":"Writing","n":1}}},{"i":4,"$":{"0":{"v":"Belajar Menulis","n":0.707},"1":{"v":"\nTahun ini baru tau dan baru join club menulis yang di inisiasi sama temen temen yang suka menulis di eFishery. Sepertinya menarik, jadi ada teman nulis bareng. Baca isi pikiran mereka dalam tulsan. Gue suka baca tapi gue gak pernah nulis sama sekali. Jadilah gue coba ikutin apa kaya orang orang di youtube aja dulu. Begitu typing belajar menulis langsung keluar video ini.\n\n[![Youtube - Pelajaran Menulis - Dea Anugrah](assets/youtube-pelajaran-menulis-dea-anugrah-malaka.png)](https://www.youtube.com/watch?v=Ldz2SZ-L9rQ)\n\nPemberi materinya Dea Anugrah, Jujur baru tau namanya. Tapi ini insight yang bisa gue ambil.\n\nAda empat point yang dibahas:\n\n1. Struktur\n2. Kalimat Pertama\n3. Insight \n4. Humor\n\n## Struktur\n\nLangkah pertama yang bisa dilakukan adalah membangun strukturnya dulu. Bikin outline dulu, ini yang nanti akan jadi panduan menulis. Dalam menulis pada umumnya ada structure yang terkenal seperti [three act structure](https://en.wikipedia.org/wiki/Three-act_structure) atau drama tiga babak.\n\n![three-act structure](assets/til.belajar-menulis/image.png)\n\nTapi structure gak kaku atau cuma itu aja, kita bisa eksplorasi lebih dalam lagi soal struture. Gue coba pause videonya dan check ada apalagi sih? Misalnya novel terkenal sudah banyak yang membahas juga, Harry Potter menggunakan [chiastic structure](https://en.wikipedia.org/wiki/Chiastic_structure#:~:text=Chiastic%20structure%2C%20or%20chiastic%20pattern,%2CB'%2CA'.) berdasarkan diskusi [reddit](https://www.reddit.com/r/harrypotter/comments/11lhwa/the_chiastic_symmetrical_structure_of_harry_potter/#:~:text=There%20is%20a%20book%20written,and%20ending%20at%20the%20Dursley's.). Atau ketika menulis berita lo bisa pakai struktur 5W1H langsung to the point untuk menjabarkan informasinya. Jadi poinnya structure ini tergantung dari tujuan cerita lo mau kemana? abis itu lo tentuin strukturenya.\n\n\n## Kalimat Pertama\n\nKalimat pertama jadi penting dan ritme tulisan ditentukan dari kalimat pertama. Kalimat pertama mengantarkan pembaca ke suatu dunia baru, dunia dimana si penulis sedang bercerita\n\n## Insight\n\nDalam setiap tulisan, kalo bisa ada insight yang baru untuk para pembaca. Jadi mereka bisa dapet sesuatu dari dunia yang lo buat\n\n## Humor\n\nMenurut gue ini bagian sulit membuat humor dari tulisan. Ya memang gue juga bukan orang yang humoris. Tapi ini akan gue pelajari. Gue kemarin sempet nonton video andre dan radit lagi belajar stand up comedy munkin caranya bisa ditiru. https://www.youtube.com/watch?v=xayskKycquU`","n":0.059}}},{"i":5,"$":{"0":{"v":"Windows","n":1}}},{"i":6,"$":{"0":{"v":"Notes: Resolving Connection Issues from WSL to Windows","n":0.354},"1":{"v":"\n## Steps to Resolve \"Connection Refused\" from WSL to Windows\n\n### 1. Check Windows IP Address from WSL\nUse the following command inside WSL to find the IP address used by Windows:\n```bash\ncat /etc/resolv.conf | grep nameserver\n```\nThe IP address shown is the Windows IP address accessible from WSL.\n\n### 2. Access Service Using Windows IP Address\nTry accessing the service running on Windows from WSL using the IP address obtained earlier. Example:\n```bash\ncurl http://10.255.255.254:1234\n```\n\n### 3. Check Firewall Settings\nEnsure the Windows firewall does not block connections from WSL to Windows. Temporarily disable the firewall to check if it is the cause of the issue:\n- Open \"Windows Defender Firewall with Advanced Security\".\n- Temporarily disable the firewall for Domain, Private, and Public Network.\n\n### 4. Ensure Services in Windows Listen on All Interfaces\nEnsure the service running on Windows listens on all interfaces (`0.0.0.0`) and not just `127.0.0.1`.\n\n### 5. Use Port Forwarding with `netsh`\nRun the following command in PowerShell with Administrator rights to forward traffic from localhost to the Windows IP accessible from WSL:\n```powershell\nnetsh interface portproxy add v4tov4 listenaddress=127.0.0.1 listenport=1234 connectaddress=10.255.255.254 connectport=1234\n```\n\n### 6. Create or Edit `.wslconfig` File\nCreate or edit the `.wslconfig` file in the `%UserProfile%` directory with the `networkingMode=mirrored` setting.\n\n#### PowerShell Script to Create/Edit `.wslconfig`\n```powershell\n# Define the path to the .wslconfig file in the User Profile directory\n$wslConfigPath = \"$env:UserProfile\\.wslconfig\"\n\n# Content to be added to the .wslconfig file\n$newContent = \"networkingMode=mirrored\"\n\n# Check if the .wslconfig file exists\nif (Test-Path $wslConfigPath) {\n    # Read the content of the .wslconfig file\n    $content = Get-Content $wslConfigPath\n\n    # Check if the [wsl2] section exists\n    if ($content -match '\\[wsl2\\]') {\n        # If the [wsl2] section exists, add the new setting below it\n        Add-Content -Path $wslConfigPath -Value $newContent\n    } else {\n        # If the [wsl2] section does not exist, add the entire [wsl2] section and the new setting\n        Add-Content -Path $wslConfigPath -Value \"[wsl2]`n$newContent\"\n    }\n} else {\n    # If the file does not exist, create a new file with the entire [wsl2] section and the setting\n    Set-Content -Path $wslConfigPath -Value \"[wsl2]`n$newContent\"\n}\n\nWrite-Output \"Setting has been added to $wslConfigPath:\"\nGet-Content $wslConfigPath\n```\n\n### 7. Restart Services in Windows and WSL\nRestart the services running in Windows and the WSL distribution:\n```powershell\nwsl --shutdown\nwsl\n```\n\n### 8. Use `localhost` in WSL\nTry accessing `localhost` directly from WSL:\n```bash\ncurl http://localhost:1234\n```\n\nBy following these steps, you should be able to resolve the connection issue from WSL to Windows and get the desired response.\n\nI hope these notes are helpful! If you have any further questions or need additional assistance, feel free to ask.\n\n## Drawbacks\n\nin wsl ubuntu cannot access internet","n":0.05}}},{"i":7,"$":{"0":{"v":"Recovering from a Broken Nix Wsl Setup","n":0.378},"1":{"v":"\n\nBeberapa bulan lalu, gue lagi nonton sesi [Dev Tool Time](https://www.youtube.com/watch?v=LA8KF9Fs2sk), narasumbernya **Mitchell Hashimoto** (founder Vagrant, Terraform, Vault).\n\nDi situ Mitchell nunjukin setup developernya yang keren banget: pakai **NixOS di dalam VM**, semua konfigurasinya deklaratif, dan kalau mau rebuild environment cukup jalanin satu perintah. \n\nGue mikir, \"Wah gila, keren banget. Kalau Mitchell bisa, masa gue nggak?\". Akhirnya gue mulai eksperimen sendiri: pasang Nix langsung di WSL Ubuntu, tanpa VM. Gue pikir bakal lebih praktis. Ternyata... malah jadi awal bencana kecil.\n\n## Masalah\n\nAwalnya semua keliatan baik-baik aja. Tapi hari ini 2025-04-29 , tiba-tiba semua command dasar kayak `ls`, `mkdir`, `rm` mulai error. Pesannya aneh banget:\n\n```bash\nmkdir: symbol lookup error: /nix/store/.../libc.so.6: undefined symbol: __tunable_is_initialized, version GLIBC_PRIVATE\n```\n\nSemua binary standar mati total, bahkan `bash` sendiri error. Sistem WSL gue kayak zombified.\n\nSetelah gue selidiki, ketauan masalahnya: glibc versi baru dari Nix terlalu bleeding edge. Ada perubahan internal symbol yang bikin semua binary yang udah ada langsung crash. Dan karena gue make Nix sebagai base shell, ya udah, kena semua.\n\nParahnya lagi, file `.vhdx` WSL jadi ke-lock. Mau akses lewat Windows pun nggak bisa. Total disaster.\n\n## Usaha Recovery\n\nKarena dari dalam WSL udah nggak mungkin recovery sih wkwkwk,  satu-satunya jalan dengan melakukan operasi penyelamatan dari luar.\n\nGue mulai dengan cari file `.vhdx` di:\n\n```\nC:\\Users\\<username>\\AppData\\Local\\Packages\\<distro>\\LocalState\\ext4.vhdx\n```\n\nAbis itu gue copy `.vhdx` ke lokasi aman. Butuh waktu lama, karena ukurannya 75GB lebih.\n\nSetelah itu, gue import lagi file itu ke WSL baru:\n\n```bash\nwsl --import --vhd recovery-distro D:\\wsl-recovery\\ D:\\ext4-copy.vhdx --version 2\n```\n\nLanjut, gue jalanin:\n\n```bash\nwsl -d recovery-distro\n```\n\nAkhirnya bisa masuk ke recovery mode. Tapi jangan buru-buru copy semua `/home`, itu malah buang-buang space. Gue cuma backup folder-folder penting buat development aja kayak project directory sama `.ssh`.\n\nPakai `tar` gini:\n\n```bash\n#!/bin/bash\nBACKUP_NAME=\"home-important-$(date +%Y%m%d%H%M%S).tar.gz\"\nBACKUP_PATH=\"/mnt/c/Users/<username>/Desktop/$BACKUP_NAME\"\n\necho \"\\ud83d\\udce6 Creating selective backup...\"\n\ntar -czvf \"$BACKUP_PATH\" \\\n  /home/<username>/folder1 \\\n  /home/<username>/folder2 \\\n  /home/<username>/folder3 \\\n  /home/<username>/.ssh\n\necho \"\\u2705 Backup completed: $BACKUP_PATH\"\n```\n\nSetelah semua data penting aman, gue unregister distro yang rusak:\n\n```bash\nwsl --list --verbose\nwsl --unregister Ubuntu\nwsl --unregister recovery-distro\n```\n\n## Refleksi\n\nKalau dipikir-pikir, gue salah kaprah dari awal.\n\nMitchell itu pakai Nix di dalam **VM**. Environment dia isolated. Kalau rusak? Ya VM tinggal rebuild.\n\nGue malah pasang Nix langsung di WSL, ngegantiin tool dasar OS. Begitu `glibc` crash, semua ikut ambruk. Gue juga terlalu optimis sama janji \"reproducibility\"-nya Nix, padahal kenyataannya. wkwkwkw\n\n> \"Nix **aims** for reproducibility, but it does **not guarantee** it.\"\n\nKalau mau baca lebih dalem, ini artikelnya:  \n[Nix does not guarantee reproducibility](https://cs-syd.eu/posts/2025-03-14-nix-does-not-guarantee-reproducibility)\n\n## Yang Gue Pelajarin\n\nMulai sekarang, gue bakal pakai Nix cuma buat bikin `devShell`, bukan gantiin shell dasar. Semua environment harus dipisah, entah itu di VM atau container. Nggak bakal lagi install Nix langsung buat ngeganti sistem operasi.\n\nFlake bakal gue setup lebih hati-hati, pin `nixpkgs` ke branch stabil kayak `nixos-23.11`, dan semua yang berhubungan sama core OS bakal gue pisahin.\n\nBackup rutin juga jadi wajib. Kalau perlu gue taro snapshot `.vhdx` mingguan ke external drive.\n\nDan yang paling penting: jangan percaya bleeding edge glibc.\n\n## Penutup\n\nBelajar dari pengalaman ini, gue sadar: Nix itu powerful gila, tapi kayak reaktor nuklir.\n\nKalau lo salah pake...  Bisa meledak, untung ya beberapa project itu udah di github sih.\n\nMakanya sekarang, gue tetep pakai Nix, tapi dengan lebih hati-hati. \nBiar keren kayak Mitchell... tanpa harus jungkir balik recovery lagi. wkwkwk","n":0.045}}},{"i":8,"$":{"0":{"v":"Beres Beres Disk","n":0.577},"1":{"v":"\nOke, gue ubah ya—lebih naratif, lebih ngalir, dan gak ada bullet point yang kaku.\n\n---\n\n### 📌 TIL – Bersihin Sampah Digital Biar C Drive Gak Nanggung\n\nHari ini gue iseng ngecek isi `C:\\` karena udah mulai mepet space-nya. Pas liat di file explorer sih keliatannya bersih-bersih aja, tapi pas gue breakdown lebih dalam, ternyata banyak banget file sampah kayak `.log`, `.tmp`, `.bak`, sama `.dmp` yang ukurannya bisa sampe ratusan MB. Beberapa dari file itu diem-diem makan space tapi gak keliatan jelas dari UI biasa.\n\nAkhirnya gue nulis skrip PowerShell buat bersihin itu semua. Gue set filter biar cuma ngambil file yang size-nya di atas 1MB, karena yang kecil-kecil mah gak ngaruh. Gue juga exclude folder-foler sensitif kayak `System32`, `WinSxS`, `Program Files`, dan lain-lain—takutnya malah bikin sistem jadi berantakan. Supaya prosesnya gak macet kalau ada file yang nge-lock atau lama dihapus, gue bungkus proses penghapusan pakai `Start-Job` dan kasih timeout 5 detik. Jadi kalau file itu ngeyel, ya gue skip dan taruh di list `$skipped` buat dicek nanti.\n\nSkrip ini gue jalanin dari PowerShell biasa, gak butuh admin mode kecuali lo mau bersihin file di folder yang protected. Overall, ini cara bersih-bersih yang aman, bisa dipantau, dan bisa lo jalankan berkala kayak nyapu kamar setiap minggu.\n\nBerikut skripnya:\n\n```powershell\n$deletedCount = 0\n$checkedCount = 0\n$skipped = @()\n$excludedRoots = @(\n    \"C:\\Windows\\System32\",\n    \"C:\\Windows\\WinSxS\",\n    \"C:\\Windows\\Installer\",\n    \"C:\\Program Files\",\n    \"C:\\Program Files (x86)\",\n    \"C:\\$Recycle.Bin\"\n)\n\nWrite-Host \"\"\nWrite-Host \"🧹 Starting cleanup at $(Get-Date -Format 'HH:mm:ss')...\" -ForegroundColor Cyan\n\n$files = Get-ChildItem -Path C:\\ -Recurse -Force -ErrorAction SilentlyContinue | \n    Where-Object { $_.Extension -in '.log', '.tmp', '.bak', '.dmp' }\n\nforeach ($file in $files) {\n    $checkedCount++\n\n    if ($checkedCount % 100 -eq 0) {\n        Write-Host \"Checked $checkedCount files...\" -ForegroundColor Yellow\n    }\n\n    if ($file.Length -lt 1MB) { continue }\n\n    $fileRoot = $file.DirectoryName\n    if ($excludedRoots -contains $fileRoot -or $excludedRoots | Where-Object { $file.FullName.StartsWith($_) }) {\n        continue\n    }\n\n    $timestamp = Get-Date -Format \"HH:mm:ss\"\n    Write-Host \"[$timestamp] 🗑 Attempting: $($file.FullName) ($([math]::Round($file.Length / 1MB, 2)) MB)\" -ForegroundColor Gray\n\n    $job = Start-Job { param($f) Remove-Item $f -Force -ErrorAction SilentlyContinue } -ArgumentList $file.FullName\n    if (Wait-Job $job -Timeout 5) {\n        Receive-Job $job | Out-Null\n        Write-Host \"[$timestamp] ✅ Deleted: $($file.FullName)\" -ForegroundColor Green\n        $deletedCount++\n    } else {\n        Stop-Job $job | Out-Null\n        Write-Host \"[$timestamp] ⚠️ Timeout: $($file.FullName)\" -ForegroundColor DarkYellow\n        $skipped += $file.FullName\n    }\n    Remove-Job $job | Out-Null\n}\n\nWrite-Host \"\"\nWrite-Host \"✅ Done. Deleted $deletedCount files over 1MB.\" -ForegroundColor Green\nif ($skipped.Count -gt 0) {\n    Write-Host \"⚠️ Skipped $($skipped.Count) files due to timeout:\" -ForegroundColor Yellow\n    $skipped | ForEach-Object { Write-Host \"- $_\" -ForegroundColor DarkGray }\n} else {\n    Write-Host \"🎉 No skipped files!\" -ForegroundColor Cyan\n}\n```\n\nSekarang setiap kali lo ngerasa \"kok C makin sempit ya padahal gak install apa-apa\", tinggal run ini aja. Gak usah repot cari aplikasi cleaner pihak ketiga yang kadang malah naruh bloat baru. Mau gue buatin versi task scheduler biar auto jalan tiap Senin pagi juga bisa.","n":0.047}}},{"i":9,"$":{"0":{"v":"Supabase","n":1}}},{"i":10,"$":{"0":{"v":"RLS Supabase: Biar Data Lo Gak Jadi Konsumsi Publik","n":0.333},"1":{"v":"\n\nLo pasti pernah kepikiran: “Gimana caranya user cuma bisa ngakses data yang emang buat dia?” Nah, RLS atau Row-Level Security itu jawabannya. Di Supabase (dan di Postgres juga), RLS itu semacam **penjaga pintu**—dia bakal nentuin data mana yang boleh dan nggak boleh diakses sama user tertentu.\n\n## **Apa Itu RLS?**\nSecara teknis, RLS itu fitur bawaan Postgres yang bikin lo bisa filter data langsung di level baris (row), bukan cuma kolom doang. Jadi, kalau lo punya tabel **orders** isinya 1 juta baris, user A cuma boleh liat order yang dia bikin doang—nggak bisa kepoin order orang lain. Semua logicnya ditulis di database, bukan di backend lo.\n\nGampangnya, **RLS** adalah fitur keren di Postgres yang bikin lo bisa atur siapa yang bisa lihat data di level baris (row). Jadi, bukan cuma tabel yang di-protect, tapi per **baris** data pun bisa lo atur aksesnya. RLS ini kayak satpam di pintu-pintu rumah lo – lo bisa atur siapa yang boleh lewat, siapa yang nggak.\n\n### **Kenapa Penting?**\nTanpa RLS, lo harus rely sama backend lo buat handle data filtering. Itu riskan banget. Misalnya, di backend lo lupa check `where user_id = session_user`, user bisa dapetin data orang lain—bahaya! Dengan RLS, lo **mindahin logic proteksi** langsung ke database. Hasilnya:\n- Data lebih aman.\n- Backend lo lebih simpel (nggak perlu query filter yang ribet).\n- Semua permintaan ke database (termasuk API Supabase) udah auto-filtered.\n\nLo bayangin kalo lo punya satu database tapi dipake rame-rame: ada admin, user biasa, dan customer premium. Tanpa RLS, kalo lo nggak hati-hati, siapa aja bisa lihat semua data. Bahaya, kan? Nah, RLS bikin lo bisa setel “aturan main” biar user A cuma liat data dia doang, admin bisa liat semua, dan lain-lain.\n\n## Cara Kerja RLS\n\nSecara default, Postgres **nggak aktifin** RLS. Lo harus nyalain dulu:\n\n```sql\nalter table profiles enable row level security;\n```\n\nAbis itu, lo bikin policy. Misalnya, lo pengen user biasa cuma bisa liat datanya sendiri:\n\n```sql\ncreate policy \"user can view own profile\"\non profiles\nfor select\nusing (auth.uid() = id);\n```\n\nNah, `auth.uid()` ini di Supabase otomatis dapet dari JWT user yang login. Jadi lo nggak perlu nulis kode filter data di backend lo, semua udah dihandle sama database!\n\n## **Contoh Use Case**\nLo punya app SaaS buat beberapa tenant. Di sana ada admin yang harus bisa liat semua data, dan ada user biasa yang cuma boleh liat data organisasinya doang. Contohnya di tabel `profiles`:\n\n* User Biasa: cuma boleh liat data user di tenant dia sendiri.\n* Admin: boleh liat data semua orang.\n* Guest / Anon: nggak boleh liat sama sekali.\n\n### **Simulasi Sederhana**\nDi Supabase, lo bisa bikin 2 policy di tabel `profiles` kayak gini:\n\n```sql\n-- Admin bisa akses semua\ncreate policy \"admin can access all profiles\"\non public.profiles\nas permissive\nfor all\nto authenticated\nusing (\n  auth.jwt() ->> 'role' = 'admin'\n);\n\n-- User biasa cuma bisa akses profil sendiri\ncreate policy \"user can access own profile\"\non public.profiles\nas permissive\nfor select\nto authenticated\nusing (auth.uid() = id);\n```\n\nJadi waktu ada request:\n\n* Admin dapet full akses.\n* User biasa cuma liat data yang ID-nya sama dengan `auth.uid()`.\n* Kalau anon? Kena RLS—data nggak muncul sama sekali.\n\n### **Custom Claims di Supabase**\n\nSupabase support banget buat custom JWT claims—artinya lo bisa nyelipin info tambahan kayak `role`, `tenant_id`, atau apapun yang lo butuhin di JWT user. Nah, kenapa ini penting?\n\nBiasanya, JWT default dari Supabase cuma punya info standar kayak `sub` (user id), `email`, sama `role` yang default (`authenticated` / `anon`). Tapi buat app multi-tenant, lo butuh role yang lebih spesifik—misalnya admin, sales, customer, dsb.\n\nDi Supabase, caranya lewat **Auth Hooks**. Lo bisa bikin **custom access token hook** di PostgreSQL yang akan “selipin” field baru ke JWT sebelum dikasih ke user. Contoh:\n\n```sql\ncreate or replace function public.custom_access_token_hook(event jsonb)\nreturns jsonb\nlanguage plpgsql\nas $$\ndeclare\n  claims jsonb;\n  user_role text;\nbegin\n  -- Ambil role dari tabel profiles\n  select role into user_role\n  from public.profiles\n  where id = (event->>'sub')::uuid;\n\n  -- Kalo nggak ketemu, fallback ke 'user'\n  if user_role is null then\n    user_role := 'user';\n  end if;\n\n  -- Ambil claims dari event\n  claims := coalesce(event->'claims', '{}');\n\n  -- Tambahin custom claim 'role'\n  claims := jsonb_set(claims, '{app_metadata, role}', to_jsonb(user_role)::jsonb);\n\n  -- Update claims di event\n  event := jsonb_set(event, '{claims}', claims);\n\n  return event;\nend;\n$$;\n```\n\nHasilnya? JWT user lo sekarang bakal punya `app_metadata.role` = “admin” atau “user”, sesuai yang lo simpen di tabel `profiles`. Ini yang nanti **dipake di policy RLS**!\n\n\n**Tips**\n✅ **Jangan asal nambahin claims**—cuma yang emang dibutuhin buat RLS.\n✅ **Tes hook lo**—biar JWT yang dihasilkan sesuai ekspektasi dan nggak ngerusak policy yang udah lo bikin.\n✅ **Hindari leak data sensitif**—jangan selipin info yang nggak perlu di JWT.\n\n---\n\n## **Best Practice**\nJangan cuma bikin policy yang kelihatannya aman. Ada beberapa tips biar lo nggak keteteran:\n\n1. **Selalu tes policy lo**—pakai akun dummy yang role-nya beda-beda.\n2. **Pisahin policy buat read (select) sama write (insert/update/delete)**—biar lo bisa detailin kontrolnya.\n3. **Gunakan claim JWT** kayak `role` atau `tenant_id` buat filter lebih spesifik—jadi bukan cuma ID user doang.\n4. **Jangan kasih grant `select` atau `all` langsung ke `anon` / `authenticated`** tanpa policy. Tanpa policy, data lo kebuka semua.\n5. **Kalau ada query yang harus admin-only, kasih policy spesifik**—jangan sampe admin lo kena limit yang sama kayak user biasa.\n\n## Reference\n\n- [Row Level Security di Supabase Docs](https://supabase.com/docs/guides/database/postgres/row-level-security)\n- [Postgres Official Docs](https://www.postgresql.org/docs/current/ddl-rowsecurity.html)  \n- [Supabase Auth Hooks: Custom Access Token Hook](https://supabase.com/docs/guides/auth/auth-hooks/custom-access-token-hook)\n\n","n":0.035}}},{"i":11,"$":{"0":{"v":"Setup Spring Boot","n":0.577},"1":{"v":"\nSiap! Ini dia versi **terbaru dan bersih** dari **step-by-step install Spring Boot pakai Gradle di WSL Ubuntu**, dengan **Java 21 (LTS)** dan **tanpa buka browser**.\n\n---\n\n## ✅ STEP-BY-STEP SPRING BOOT + GRADLE + JAVA 21 (WSL Ubuntu – Full CLI)\n\n---\n\n### 🧱 1. Install Dependency Dasar\n\n```bash\nsudo apt update\nsudo apt install unzip curl zip -y\n```\n\n---\n\n### ☕️ 2. Install SDKMAN\n\n```bash\ncurl -s \"https://get.sdkman.io\" | bash\nsource \"$HOME/.sdkman/bin/sdkman-init.sh\"\n```\n\n> ✅ SDKMAN = versi manager buat Java, Gradle, Spring CLI\n\n---\n\n### ☕️ 3. Install Java 21 (LTS)\n\n```bash\nsdk install java 21.0.7-tem\nsdk default java 21.0.7-tem\njava -version\njavac -version\n```\n\n---\n\n### ⚙️ 4. Install Gradle dan Spring Boot CLI\n\n```bash\nsdk install gradle\nsdk install springboot\n```\n\n> Cek:\n\n```bash\ngradle -v\nspring --version\n```\n\n---\n\n### 📦 5. Generate Proyek Spring Boot (pakai CLI)\n\n```bash\nspring init \\\n  --boot-version=3.3.0 \\\n  --build=gradle \\\n  --type=gradle-project \\\n  --java-version=21 \\\n  --dependencies=web,lombok \\\n  --name=demo \\\n  demo\n\n```\n\n> Ini akan membuat folder `demo/` berisi project Spring Boot + Gradle.\n\n---\n\n### 🚀 6. Jalankan Spring Boot\n\n```bash\ncd demo\n./gradlew bootRun\n```\n\n> Buka browser di Windows:\n\n```\nhttp://localhost:8080\n```\n\n---\n\n### 🔨 7. Tambahkan Endpoint Controller\n\n```bash\nnano src/main/java/com/example/demo/HelloController.java\n```\n\nIsi:\n\n```java\npackage com.example.demo;\n\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\npublic class HelloController {\n    @GetMapping(\"/hello\")\n    public String hello() {\n        return \"Hello from Spring Boot in WSL!\";\n    }\n}\n```\n\nSimpan & restart:\n\n```bash\n./gradlew bootRun\n```\n\n---\n\n### 👨‍💻 8. (Opsional) Buka di VSCode\n\n```bash\ncode .\n```\n\n> Pastikan sudah install extension **\"Remote - WSL\"** di VSCode.\n\n---\n\nKalau semua step ini diikuti, kamu udah siap ngoding full Spring Boot di WSL 🎉\nMau lanjut setup PostgreSQL atau Docker juga?\n","n":0.069}}},{"i":12,"$":{"0":{"v":"Package Explanation","n":0.707},"1":{"v":"\n# Penamaan Package Java & Spring Boot: Kenapa Harus Seribet Itu?\n\nKalau lo datang dari dunia Go atau Node.js yang cenderung simple dan flat, struktur package Java kelihatan ribet banget. Kenapa mesti ada `id.mycompany.adm` segala? Kenapa gak cukup `app`, `service`, atau `main` aja?\n\nNah, ini gue jelasin secara naratif dan pakai logika, bukan sekadar ikut-ikutan best practice.\n\n## Package Itu Bukan Sekadar Folder\n\nDi Java, package itu bukan cuma struktur folder buat nyimpan file `.java`. Package itu juga berfungsi sebagai namespace yang ngatur akses antar class, dan jadi identitas unik suatu bagian dari aplikasi lo.\n\nJadi kalau lo punya class `UserService` di dua tempat berbeda, misalnya:\n\n* `id.mycompany.billing.UserService`\n* `id.mycompany.userprofile.UserService`\n\nItu sah-sah aja karena beda package. Gak bakal bentrok. Java compiler tahu mana yang mana. Di Go, namespace biasanya ngikut dari import path (misal: `github.com/myorg/userprofile/service`), dan konsepnya mirip walaupun lebih fleksibel.\n\n## Kenapa Harus \"id.mycompany\"?\n\nNama package di Java umumnya pakai domain perusahaan dalam bentuk terbalik (`reverse domain name`). Jadi kalau domain lo `mycompany.id`, lo tulis `id.mycompany`.\n\nKenapa dibalik? Karena di dunia Java, ini udah jadi cara umum buat bikin namespace yang unik. Google misalnya pakai `com.google`, Apache pakai `org.apache`, Spring pakai `org.springframework`, dan seterusnya.\n\nTujuannya biar gak bentrok. Bayangin semua orang pakai `app.service` — kacau nanti kalau semua library campur di satu project.\n\n## Tambahan Modul di Akhir\n\nSetelah `id.mycompany`, lo tambahin nama aplikasi atau modulnya. Misalnya `adm` buat `ADMInfoHandlerWrapper`. Jadi lengkapnya:\n\n```\nid.mycompany.adm\n```\n\nKalau mau lebih rapi, lo bisa strukturin lagi kayak:\n\n```\nid.mycompany.adm.controller\nid.mycompany.adm.service\nid.mycompany.adm.repository\n```\n\nMirip banget sama layered architecture yang dipakai di mana-mana: controller buat HTTP layer, service buat business logic, repository buat database access.\n\n## Tapi Gue Cuma Pake Buat Service Kecil, Emang Perlu?\n\nKalau lo lagi nulis microservice kecil buat internal, dan yakin itu gak bakal digabung ke sistem besar, ya boleh aja lo flatten semua jadi satu package: `app` misalnya. Spring Boot gak bakal ngambek.\n\nTapi kalau lo main di monorepo, enterprise system, atau ngembangin open source lib, pake struktur `id.mycompany.module` itu penting banget. Framework kayak Spring Boot juga scan komponen berdasarkan package. Jadi kalau lo nyebar bean lo ke package yang gak kerelasi sama root package, Spring bisa gak nemu komponen lo. Trust me, itu pain point yang umum banget di project Java.\n\n## Kesimpulan\n\nPenamaan package `id.mycompany.adm` itu bukan buat gaya-gayaan. Itu cara Java ngebuat struktur yang scalable, traceable, dan gak bentrok kalau proyek lo makin besar. Lo boleh aja mulai dari yang simple, tapi seiring waktu lo bakal ngerasa sendiri kenapa struktur itu jadi penting. Beda konteks, beda kebutuhan.\n\nKalau lo mau ngulik lebih dalam soal konvensi ini, ini beberapa referensi yang bisa lo baca:\n\n* [Oracle Java Package Naming Guide](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html)\n* [Structuring Code in Spring Boot](https://docs.spring.io/spring-boot/reference/using/structuring-your-code.html)\n* [Baeldung: Java Packages](https://www.baeldung.com/java-packages)","n":0.049}}},{"i":13,"$":{"0":{"v":"Python","n":1}}},{"i":14,"$":{"0":{"v":"Building a Robust Live Log Viewer with FastAPI and Server-Sent Events","n":0.302},"1":{"v":"\nKadang lo bikin sistem yang kerjanya di balik layar. Kayak proses code generation yang lo trigger dari web, tapi di balik itu semua, ada proses AI yang jalan di background, parsing metadata, generate kode, dan simpen hasil. Masalahnya: user cuma liat loading spinner, padahal di balik layar lagi banyak hal seru—dan penting—yang terjadi.\n\nDi sinilah lo pengen kasih visibility. Biar user bisa liat log secara real-time. Biar kalau mereka cabut dan balik lagi, masih bisa liat jejak prosesnya. Lo butuh log system yang ringan, bisa di-*stream*, dan bisa di-*persist*. Bukan cuma buat user experience, tapi juga buat debugging, QA, dan observabilitas internal tim dev.\n\n![alt text](assets/til.python.building-sse/image.png)\n\n---\n\n## Sistem Ini Dibangun di Atas Tiga Pilar\n\nFastAPI jadi tulang punggungnya. Server-Sent Events (SSE) yang ngirim log kayak radio satu arah. Dan Supabase jadi storage kalau semua udah kelar. Sisanya? Sedikit HTML dan JavaScript untuk prototipe awal.\n\nGue tau lo pengen cepat nyoba, jadi UI-nya nggak langsung React atau Refine. Nanti itu bisa nyusul. Sekarang yang penting jalan dulu.\n\n```sh\n+-----------+          SSE           +-----------------+\n|           |  <------------------  |                 |\n|  FastAPI  | ------------------>   |   Frontend UI   |\n| (Backend) |   Streaming Logs      | (HTML/JS/React) |\n+-----------+                       +-----------------+\n     |\n     | Background Tasks\n     |\n     v\n+------------------+\n|  BufferedLogger  |\n|  (In-Memory Log) |\n+------------------+\n     |\n     | flush when done\n     v\n+------------------+\n|    Supabase      |\n| (Final Log Store)|\n+------------------+\n\n```\nGambaran besarnya:\n\n- FastAPI jadi otaknya, ngatur semua routing dan trigger proses.\n- Frontend UI (HTML/JS awalnya, bisa evolve ke React) connect via SSE buat dapetin log real-time.\n- Sementara itu di dalam FastAPI, log dicatat dulu di BufferedLogger—disimpan sementara di memori.\n- Begitu prosesnya selesai, logger nge-flush log-nya ke Supabase buat diambil lagi nanti kalau user refresh atau datang belakangan.\n\n---\n\n## Logger: Komponen Paling Penting yang Lo Gak Liat\n\nDi dalam FastAPI, kita bikin `BufferedLogger`. Ini semacam log manager lokal. Dia nyimpen log selama proses jalan, terus kasih akses ke client lewat `subscribe()` pake `asyncio.Queue`. Tiap log baru langsung dipush ke semua subscriber aktif. Dan kalau prosesnya udah selesai, dia `flush_to_supabase()` biar gak hilang.\n\nSemua logger disimpan di satu peta global: `logger_map[(upload_id, service)]`. Jadi kapan pun, route mana pun, asal tau ID-nya, bisa ambil logger yang sama. Ini yang bikin komunikasi antara background task dan SSE handler jadi seamless.\n\n```python\nimport asyncio\nfrom datetime import datetime\nfrom typing import Literal\n\n\nclass BufferedLogger:\n    def __init__(self):\n        self.subscribers: list[asyncio.Queue] = []\n        self.buffer: list[dict] = [] \n        self.done = False\n        self.last_used = datetime.now().timestamp()\n\n    def subscribe(self) -> asyncio.Queue:\n        queue = asyncio.Queue()\n        self.subscribers.append(queue)\n\n        # Kirim log yang sudah ada ke subscriber baru\n        for entry in self.buffer:\n            queue.put_nowait(entry)\n\n        return queue\n\n    def unsubscribe(self, queue: asyncio.Queue):\n        try:\n            self.subscribers.remove(queue)\n        except ValueError:\n            pass\n\n    def mark_done(self):\n        self.done = True\n\n    def log(self, message: str, level: Literal[\"info\", \"error\"] = \"info\"):\n        entry = {\n            \"timestamp\": datetime.now().isoformat(),\n            \"log_level\": level,\n            \"message\": message\n        }\n\n        # save buffer\n        self.buffer.append(entry)\n\n        # Broadcast to all subscribers\n        for q in self.subscribers:\n            q.put_nowait(entry)\n\n        self.last_used = datetime.now().timestamp()\n\n    async def flush_to_supabase(self, upload_id: str, service: str, supabase):\n        for entry in self.buffer:\n            supabase.table(\"runs_logs\").insert({\n                \"upload_id\": upload_id,\n                \"service_name\": service,\n                \"timestamp\": entry[\"timestamp\"],\n                \"log_level\": entry[\"log_level\"],\n                \"message\": entry[\"message\"]\n            }).execute()\n```\n\n---\n\n## Jalankan Proses, Stream Log-nya\n\nBegitu user nge-trigger endpoint generate, lo bikin logger, simpan ke map, dan langsung jalanin background task. Tapi karena ini async, kita bungkus `background_task()` dalam lambda dan jalanin pake `asyncio.run()`. Di dalam situ, semua log dikirim via logger, dan pas udah selesai baru log-nya di-*flush* ke Supabase.\n\n```python\nfrom fastapi import APIRouter, BackgroundTasks, Request\nfrom starlette.responses import StreamingResponse\nimport asyncio\nimport json\n\nrouter = APIRouter()\n\n@router.post(\"/{upload_id}/{service}/generate\")\nasync def generate_code(upload_id: str, service: str, background_tasks: BackgroundTasks):\n    logger = BufferedLogger()\n    logger_map[(upload_id, service)] = logger\n\n    async def background_task():\n        try:\n            result = await generate_and_save_code(\n                upload_id=upload_id,\n                service=service,\n                logger=logger\n            )\n        finally:\n            logger.done = True\n            await logger.flush_to_supabase(upload_id, service)\n            logger_map.pop((upload_id, service), None)\n\n    # Bungkus coroutine ke dalam background thread\n    background_tasks.add_task(lambda: asyncio.run(background_task()))\n    return {\"status\": \"Generation started\"}\n```\n\nSementara itu, user bisa buka `/logs`, dan browser akan buka koneksi SSE. Tiap log masuk, langsung di-*yield* ke client. Kalau 30 detik gak ada apa-apa dan proses udah selesai, koneksi ditutup rapi, dan user dapet pesan terakhir: stream ended.\n\n```python\n@router.get(\"/{upload_id}/{service}/logs\")\nasync def stream_logs(upload_id: str, service: str, request: Request):\n    logger = logger_map.get((upload_id, service))\n    if not logger:\n        return StreamingResponse(\n            iter([\"data: Log not available\\n\\n\"]),\n            media_type=\"text/event-stream\"\n        )\n\n    async def event_stream():\n        queue = logger.subscribe()\n        idle_counter = 0\n\n        while True:\n            if await request.is_disconnected():\n                break\n            try:\n                log = await asyncio.wait_for(queue.get(), timeout=5)\n                idle_counter = 0\n                yield f\"data: {json.dumps(log)}\\n\\n\"\n            except asyncio.TimeoutError:\n                idle_counter += 1\n                yield \": keep-alive\\n\\n\"\n                if idle_counter >= 6 and logger.done:\n                    yield f\"data: {json.dumps({'message': 'Log stream ended.'})}\\n\\n\"\n                    break\n\n        logger.unsubscribe(queue)\n\n    return StreamingResponse(event_stream(), media_type=\"text/event-stream\")\n```\n\nNah, bagian ini yang bikin prosesnya kerasa live. Tiap kali logger .log(...), semua subscriber bakal dapet update, dan user bisa ngeliat langsung progres di layar. Dan karena pakai asyncio.Queue, gak akan blocking route lain—FastAPI tetep responsif.\n\nDengan kombinasi background_tasks, logger in-memory, dan SSE, proses panjang kayak code generation atau data processing jadi jauh lebih transparan buat user. Lo gak cuma bikin sistem jalan, tapi bikin user ngerti apa yang lagi dikerjain.\n\n---\n\n## Kalau Telat? Gak Masalah. Ada Final Log\n\n```sh\n[ User buka UI ]\n       |\n       v\n[ UI panggil /status ]\n       |\n       v\n[ Logger aktif? ]\n   |             \\\n  Ya              Tidak\n   |                |\n   v                v\n[SSE connect]    [GET /logs/final]\n   |                |\n   v                v\n[Streaming]     [Ambil log dari Supabase]\n   |                |\n   v                v\n[Tutup saat done]  [Tampilkan log final]\n\n```\n\nGak semua user nungguin. Kadang mereka cabut, terus balik 5 menit lagi. Makanya lo siapin endpoint `/logs/final` buat ambil semua log yang udah di-*persist* ke Supabase. Tinggal fetch dan render ulang. Sesimpel itu.\n\n```python\n@router.get(\"/{upload_id}/{service}/logs/final\")\nasync def get_logs_final(upload_id: str, service: str):\n    response = supabase.table(\"runs_logs\")\\\n        .select(\"*\")\\\n        .eq(\"upload_id\", upload_id)\\\n        .eq(\"service\", service)\\\n        .order(\"timestamp\", desc=False)\\\n        .execute()\n\n    return {\"logs\": response.data or []}\n```\n\nEndpoint `/status` juga lo kasih buat ngecek: logger masih aktif gak? Kalau iya, jalanin SSE. Kalau enggak, langsung fetch final logs.\n\n\n\n---\n\n## UI HTML: Cepat, Kecil, Gak Ribet\n\nJujur aja, lo butuh UI cepat buat testing, dan gak pengen terlalu berat setup-nya. Jadi pakai HTML murni dulu. Satu halaman, satu fungsi `startStream()`, dan satu kotak `<pre>` buat nampilin log.\n\nBegitu tombol “Start” diklik, JS-nya ngecek status logger. Kalau masih aktif, dia buka koneksi SSE dan nampilin setiap log yang masuk. Kalau enggak, dia fallback ke log final dan render dari hasil Supabase. Log box otomatis scroll ke bawah tiap log baru masuk.\n\n```html\n<html>\n<head>\n  <title>OSB Logs UI</title>\n  <script>\n    function startStream() {\n      const uploadId = document.getElementById('uploadId').value;\n      const service = document.getElementById('service').value;\n      const logContainer = document.getElementById('logs');\n      logContainer.innerHTML = '';\n\n      fetch(`/runs/${uploadId}/${service}/status`)\n        .then(res => res.json())\n        .then(status => {\n          if (status.active) {\n            const eventSource = new EventSource(`/runs/${uploadId}/${service}/logs`);\n            eventSource.onmessage = function(event) {\n              try {\n                const data = JSON.parse(event.data);\n                logContainer.innerHTML += `[${data.timestamp}] ${data.log_level.toUpperCase()}: ${data.message}\\n`;\n                logContainer.scrollTop = logContainer.scrollHeight;\n              } catch (e) {\n                console.warn(\"Malformed log:\", event.data);\n              }\n            };\n            eventSource.onerror = function(err) {\n              console.error(\"SSE connection error\", err);\n              eventSource.close();\n              logContainer.innerHTML += `\\nLog stream ended. Please refresh to view saved logs.\\n`;\n            };\n          } else {\n            fetch(`/runs/${uploadId}/${service}/logs/final`)\n              .then(res => res.json())\n              .then(data => {\n                (data.logs || []).forEach(log => {\n                  logContainer.innerHTML += `[${log.timestamp}] ${log.log_level.toUpperCase()}: ${log.message}\\n`;\n                });\n              });\n          }\n        });\n    }\n  </script>\n</head>\n<body style=\"font-family: sans-serif; padding: 1em;\">\n  <h2>Live Log Viewer</h2>\n  <label>Upload ID: <input id=\"uploadId\" type=\"text\" /></label><br/>\n  <label>Service: <input id=\"service\" type=\"text\" /></label><br/><br/>\n  <button onclick=\"startStream()\">Start</button>\n  <pre id=\"logs\" style=\"background:#111;color:#0f0;padding:1em;height:400px;overflow:auto;white-space: pre-wrap;\"></pre>\n</body>\n</html>\n\n```\n\nKelebihan pendekatan ini? Gak ada dependency frontend. Bisa langsung nyatu sama FastAPI. Dan gampang banget buat debugging.\n\n---\n\n## Sebelum Masuk Production, Ada PR\n\nSistem ini oke buat development, tapi buat jalan di Vercel, Railway, atau VM internal, lo mesti perhatiin beberapa hal.\n\nPertama, keamanan. Lo belum ada auth. Upload ID dan service bisa dimainin. Jadi perlu validasi ID dan tambahin token atau session check. Akses SSE juga harus dibatasi ke user yang emang punya akses. Admin dan dev aja, misalnya.\n\nKedua, skalabilitas. Logger sekarang disimpan di RAM. Kalau banyak user atau task, ini gak akan cukup. Lo bisa pindah ke Redis PubSub, atau Kafka kalau lo butuh multiple consumer yang konsumsi log-nya secara paralel.\n\nKetiga, reliabilitas. Saat idle 30 detik, koneksi ditutup. Tapi kalau user gak sadar, mereka pikir server-nya hang. Lo harus edukasi user atau bikin fallback UX yang jelas. Dan pastikan SSE-nya bisa recover kalau disconnect.\n\n---\n\n## Yang Kita Pelajari Sepanjang Jalan\n\nAda beberapa hal yang terbukti berhasil.\n\nMulai dari yang lo butuh dulu, itu kunci. Awalnya cuma pakai Streamlit, terus berevolusi ke FastAPI dan SSE. Logger-nya juga dipisah dari storage—kerja di RAM, baru simpen saat selesai. Ini ngurangin pressure ke Supabase.\n\nAsync-nya juga beneran non-blocking. Lo bisa jalanin banyak request FastAPI lain tanpa terganggu sama log stream. Ini penting buat scalability.\n\nTapi gak semua hal berjalan mulus.\n\nPernah logger nyangkut karena client SSE disconnect tapi gak unsubscribe. Akhirnya logger-nya stay di RAM terus. Kadang juga log gak dikirim kalau gak ada log baru, dan user bingung. Fallback ke final logs juga gak otomatis, harus manual cek status dulu.\n\n---\n\n## Next Step? Lo Pasti Tau Sendiri Arahannya\n\nKalau lo mau lebih niat, UI-nya bisa pindah ke React, pake Refine.dev biar modular dan punya UX yang proper. Kalau SSE udah gak cukup, dan lo pengen user bisa submit perintah balik (misalnya kirim prompt ke LLM), berarti waktunya upgrade ke WebSocket.\n\nDan biar log-nya makin berguna, lo bisa tambahin timestamp relatif, filter severity (INFO, ERROR), atau export ke file langsung.\n\nTapi intinya, lo udah punya fondasi kuat: sistem log streaming yang bisa live, bisa nyimpen, dan bisa dibersihin otomatis.\n\nKapan mau dipake di proyek lo yang berikutnya?\n","n":0.026}}},{"i":15,"$":{"0":{"v":"Observability","n":1}}},{"i":16,"$":{"0":{"v":"Prometheus","n":1},"1":{"v":"\n## Apa itu Prometheus\n\n### Cara kerja prometheus\n\n## Apa itu PromQL\n\nPromQL(Prometheus Query Language) adalah functional query yang disediakan oleh prometheus agar user dapat melakukan query ke data yang telah disimpan secara real-time dan melakukan segala macam analisis, aggregation dan operasi.\n\nUntuk memahami promql ada baiknya kita mengetahui dulu tipe data yang disimpan, yaitu time-series data.\n\n### Apa itu time-series data\n\nTime-series data didefinisikan sebagai seraikaian data yang diurutkan berdasarkan waktu.\nMisalnya, Kalau lo mau mengukur penggunaan CPU, data yang akan dikumpulkan akan seperti ini.\n\n| Timestamp     | CPU Utilization (%) |\n|---------------|---------------------|\n| 1591709873808 | 67                  |\n| 1591709884270 | 68                  |\n\nDi Prometheus, time-series object dibuat pada setiap metrik yang mau dimonitor dan setiap object itu unik diidentifikasi dengan nama metric yang berisi key-value.\nYang mana key berisi timestamp dan value adalah nilai yang mau diukur. Setiap key-value disebut dengan istilah \"Sample\".\nSelain itu prometheus membrikan kemampuan untuk menambahkan label untuk memperkaya data atribut pada metrics.\nMisalnya, Kalau lo mau mengukur berapa banyak request pada suatu endpoint, lo bisa membuat satu metrics `http_request_duration_seconds_count`.\nlalu lo tambahkan label untuk memperinci diendpoint mana, jadi `http_request_duration_seconds_count{job=\"order-service\", path=\"POST_/dispatch\"}`.\nDengan memperkaya data, lo bisa dengan mudah melakukan filter ketika melakukan monitoring aplikasi lo.\n\n### Selectors\n\nAda beberapa cara untuk melakukan selecting data. \n\n#### Select Metric\n\n#### Filter by Label\n\nSetelah selecting metrics kita bisa melakukan filter berdasarkan label, ada beberapa operator dasar yang bisa kita gunakan\n\n| Description                                                                                                    | example                                                   |\n|----------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------|\n| ambil data dengan value \"heap\"                                                                                 | jvm_memory_bytes_used {area=\"heap\"}                       |\n| ambil data dengan value tidak sama dengan \"heap\"                                                               | jvm_memory_bytes_used {area!=\"heap\"}                      |\n| cari data pada label job dengan value berisi 'fed'                                                             | jvm_memory_bytes_used {job=~\"fed.+\"}                      |\n| cari selain data pada label job dengan value berisi 'fed'                                                      | jvm_memory_bytes_used {job!~\"fed.+\"}                      |\n| cari data pada label job dengan value berisi awalan 'f' atau 'j'                                               | jvm_memory_bytes_used {job=~\"f.+\\|j.+\"}                   |\n| cari data pada label area dengan value berisi 'heap' atau 'nonheap'                                            | jvm_memory_bytes_used {area=~\"heap\\|nonheap\"}             |\n| cari data pada label area dengan value berisi 'heap' atau 'nonheap' dan pada label job dengan awalan huruf 'j' | jvm_memory_bytes_used {area=~\"heap\\|nonheap\", job=~'j.+'} |\n\n#### Select to return range vectors\n\nSelain dasar query tersebut, lo juga bisa mengembalikan nilai sample untuk setiap time series yang bebeda.\nlo bisa menambahkan '[10m]' diakhir label, misalnya jvm_memory_bytes_used {area=\"heap\"}[10m] artinya kita akan mengambil data dari query dalam rentang waktu 10 menit.\nselain menit kita juga bisa \n\n- s: seconds\n- m: minutes\n- h: hours\n- d: days\n- w: weeks\n- y: years\n\n#### Select past/historical data\n\nKalau sebelumnya kita bisa mengambil data berdasarkan range, kita bisa juga melakukan mengambil data yang sudah lalu. misal\n\n`jvm_memory_bytes_used Offset 7d`\n\n","n":0.05}}},{"i":17,"$":{"0":{"v":"Nix","n":1},"1":{"v":"\nNix adalah solusi kalau lo males buat setup development env dari 0, tiap ganti laptop lo harus instal satu persatu tools yang lo butuhin. dengan nix lo bisa mendeklarasikan konfigurasi yang lo mau.\n\nini adalah proses yang gw lakuin, ketika gw init os baru di wsl dengan os ubuntu\n\n\n## instalasi ulang dengan \nawalnya gw setup dari zero to nix, tapi entah kenapa banyak error terjadi dan gw nemu instalasi tanpa daemo dengan cara ini [ https://github.com/NixOS/nix/issues/3435#issuecomment-859461593](https://github.com/NixOS/nix/issues/3435#issuecomment-1120488592)\n\n`sh <(curl -L https://nixos.org/nix/install) --no-daemon`\n  \n## Build Nix\n\nbuild nix dari repository\n\n```bash\nnix build github:zeihanaulia/nixpkgs#homeConfigurations.x86_64-linux.zeihanaulia.activationPackage\n```\n  \n## Activate zsh  \nkarena gw menggunakan zsh, maka gw activate lewat command ini `chsh -s $(which zsh)`\n\n\nselesai sih dengan kaya gini, gw udah bisa dapet semua env yang gw mau setup di setiap komputer yang gw pake.","n":0.09}}},{"i":18,"$":{"0":{"v":"Nixos on Windows","n":0.577},"1":{"v":"\n## NixOS di WSL — Biar Setup Dev Lo Gak Ribet Tiap Ganti Laptop\n\nGue udah capek tiap kali pindah laptop atau reinstall sistem harus setup ulang environment satu per satu. Install ini itu, copy config, lupa set env var, dan akhirnya... gak konsisten. Padahal kan pengennya begitu install, semua langsung jalan kaya sebelumnya.\n\nMakanya, gue mutusin buat pindah ke NixOS. Nantinya setup development env gue di wsl atau di MacOS akan sama. Tujuan akhirnya: dev environment yang deklaratif dan reproducible.\n\n---\n\n### Kenapa Gak Cukup Pakai Ubuntu + Nix?\n\nGue sempet nyobain itu juga. Di WSL Ubuntu, lo bisa install `nix`, terus setup environment lo lewat `nix-env`, `nix profile`, bahkan `home-manager`. Tapi hasilnya agak laen sih wkwkwk, environment lo seolah ditiban di atas Ubuntu. Kernel, systemd, dan banyak hal lain tetap milik Ubuntu. Yang gue dapet cuma `nix`-based package manager, bukan full declarative system.\n\nDan ya, waktu itu gue juga ngalamin beberapa issue aneh. Salah satunya tentang path resolution di dalam WSL Ubuntu yang bikin environment keacak, terutama kalau lo setup pake `.bashrc`/`.zshrc` terus dijalanin lewat flake. Ada juga masalah PATH yang berantakan karena colokan antara Windows dan Linux. Gue dokumentasiin juga di sini:\n\n👉 [Recovering from a Broken Nix Wsl Setup](https://zeihanaulia.github.io/sotoy/notes/57q7jyz0wff078xaz4s6eea)\n\nIntinya, pendekatan \"Ubuntu + Nix\" bisa dibilang setengah jalan. Kayak lo pengen declarative, tapi fondasinya tetep mutable. Jadi nantinya setiap mau setup atau instalasi baru cuma bisa lewat declarative config ini. \n\n---\n\n### Install NixOS di WSL\n\nPertama, download image `.wsl` dari GitHub release-nya:\n→ https://github.com/nix-community/NixOS-WSL/releases\n\nSetelah itu, import ke WSL pake PowerShell:\n\n```powershell\nwsl --import NixOS C:\\Distros\\NixOS .\\Downloads\\nixos.wsl --version 2\n```\n\n- `NixOS` di situ nama instance-nya. Lo bisa namain ini apa pun sih.\n- `C:\\Distros\\NixOS` itu direktori tempat disimpannya data `.ext4`\n- file `.wsl` tadi yang udah lo download\n\nKalau lo mau bikin instance kedua buat testing atau sandbox, tinggal ganti nama dan path:\n\n```powershell\nwsl --import NixTest C:\\Distros\\NixTest .\\Downloads\\nixos.wsl --version 2\n```\n\nAbis itu, lo tinggal masuk:\n\n```bash\nwsl -d NixOS\n```\n\nLo bakal disambut dengan shell bash kosong. Gak ada `zsh`, gak ada `nvim`, belum ada flake juga. Tapi ini udah NixOS beneran.\n\n---\n\n### Konfigurasi Awal\n\nTambahin ini ke `.bashrc` lo supaya fitur flake bisa jalan:\n\n```bash\necho 'export NIX_CONFIG=\"experimental-features = nix-command flakes\"' >> ~/.bashrc\nsource ~/.bashrc\n```\n\nSetelah itu tes apakah environment-nya udah siap:\n\n```bash\nnix eval nixpkgs#hello\nnix shell nixpkgs#bat\nbat --version\n```\n\nKalau semua jalan, berarti base system udah siap. Nix bisa resolve package, download derivation, dan aktifin shell-nya.\n\n---\n\n### Lokasi File Nix\n\nSecara default, Nix nyimpen semua derivation dan build result lo di `/nix/store`. Karena lo lagi di WSL, partisi ini diemount dari file `.ext4` yang lo simpan waktu import tadi.\n\nMisal tadi lo import ke `C:\\Distros\\NixOS`, maka file ext4-nya ada di situ. Di dalam situ ya semua file yang dibaca Nix.\n\nMenariknya, bahkan kalau lo `ls /nix`, itu cuma symlink ke isi mount. Tapi NixOS-WSL udah handle semua mount-nya otomatis.\n\n---\n\n### Testing Basic Dev Setup\n\nLo bisa cobain mulai dari command sederhana:\n\n```bash\nnix shell nixpkgs#bat\n```\n\nMasuk ke shell itu dan jalanin:\n\n```bash\nbat --version\n```\n\nKalau jalan, artinya `nixpkgs` lo up to date dan semua udah siap dipake.\n\n---\n\n### What's Next?\n\nGue udah bikin struktur awal kayak gini:\n\n```\nflake.nix\nflake.lock\n/home/\n  zeihanaulia.nix\n/modules/\n  dev-tools.nix\n```\n\nTujuannya jelas: gue pengen punya satu file `flake.nix` yang bisa dipake buat install semua dev tools, shell config, editor setup, bahkan CLI-CLI kecil yang biasa gue pake tiap hari.\n\nGue juga rencanain pake `home-manager` supaya semua user config (git, shell, aliases, dll) bisa diatur dari 1 tempat. Tapi itu di langkah berikutnya.\n\n---\n\n### Penutup\n\nYang penting sekarang, gue udah punya pondasi: WSL + NixOS yang proper, gak half-baked. Gak perlu ribet tiap kali ganti laptop atau setup baru. Semua tinggal pull repo dan `nixos-rebuild`.\n\nKalau lo juga pengen dev environment yang gak cuma \"works on my machine\", tapi bisa dibangun ulang dengan satu command, menurut gue ini worth banget dicoba.\n\nMau lanjut ke bagian flake setup dan home-manager? Gas. Kita bikin sampe lo tinggal `nixos-rebuild switch` dan semuanya siap tempur.\n","n":0.041}}},{"i":19,"$":{"0":{"v":"Managing Team","n":0.707},"1":{"v":"\nMalem ini gw kembali melek karena ada diskusi menarik dari thread hrd bacot tentang managing teams.\n\n![screenshot twitter](assets/20230426232639.png)\n\nLinknya [disini](https://twitter.com/hrdbacot/status/1651163534863261698?t=14CJyK-bxEFLYz8Q0rWbqA&s=19), yang dimana kebetulan gw juga lagi pelajarin banget cara manage team. Ada beberapa tweet yang menurut gw menarik dan bisa gw kulik lebih dalam. Reply tweet yang pertama gw baca itu [ini](https://twitter.com/JetVeetlev/status/1651247102054531073).\n\n![tweet 1](assets/20230426233852.png)\n\n1. Kasih arahan yg jelas mau lo apa. Ceritain thought process lo.\n2. Delegasi kerjaan.\n3. Cek periodically utk update or kendala.\n4. Jangan micromanage.\n5. Ngobrol bukan menggurui.\n6. Saying Thank you, please and sorry goes very long way.\n\nIni poin poin yang menurut gw actionable dan cukup jelas. Yang pertama adalah lo harus bisa memberikan arahan yang jelas, apa yang lo mau capai dengan team lo dan lo harus bisa ceritain cara berpikir lo. hasil penelusuran sederhana dengan mencari video youtube dengan kata kunci \"thought process\" gw bisa dapet beberapa masukan yang bagus dan actionable.\n\n- <https://www.youtube.com/watch?v=rrOnk0JnXW4>\n  - video ini berisi talks dari alan alda, beliau adalah pakar komunikasi yang sebenarnya dia tidak suka dengan istilah memberikan tips, dan dia menyaranan kalau jangan pernah ambil \"pro tips\" dari siapa pun. gak ada yang namanya hacks atau jalan pintas semua butuh proses\n  - gw bahas lebih detail disini [[til.managing-team.youtube.3-ways-to-express-your-thoughts-so-that-everyone-will-understand-you]]\n- <https://www.youtube.com/watch?v=HZRDUZuIKg4>\n  - point pentingnya adalah cara berpikir dari first principles thinker atau pemikir prinsip-prinsip dasar yang mencari kebenaran dari suatu konsep atau ide dengan memulai dari fundamental terkecil yang dapat dikonseptualisasikan.\n  - gw bahas lebih detail disini [[til.managing-team.youtube.the-most-powerful-way-to-think-first-principles]]\n\nDari sini jadi terbuka apa yang selanjutnya harus gw pelajari, ini relate dengan critical thinking, sesuatu yang mau gw pahami dan memiliki pemikiran yang kritis. gw tulis beberapa reading list yang harus gw baca dan nanti gw buat summarynya.\n\n- <https://blog.pragmaticengineer.com/critical-thinking/>\n- <https://learning.oreilly.com/library/view/hbr-guide-to/9781647824471/>\n- <https://learning.oreilly.com/videos/-/9781492028383/>\n- <https://learning.oreilly.com/live-events/introduction-to-critical-thinking/0636920118909/>\n- <https://learning.oreilly.com/library/view/critical-thinking-skills/9781118924730/05_9781118924723-ch01.xhtml>\n- <https://learning.oreilly.com/library/view/the-lost-art/53863MIT57409/>\n- <https://www.criticalthinkingatwork.com/2-chapters.html>\n- <https://www.indeed.com/career-advice/career-development/importance-of-critical-thinking>\n","n":0.06}}},{"i":20,"$":{"0":{"v":"Youtube","n":1}}},{"i":21,"$":{"0":{"v":"The Most Powerful Way to Think First Principles","n":0.354},"1":{"v":"\n![The Most Powerful Way to Think First Principles](assets/20230427005745.png)\n\nlink: <https://www.youtube.com/watch?v=HZRDUZuIKg4>\n\n## Intinya\n\nInti dari transkrip ini adalah membahas tentang cara berpikir dari first principles thinker atau pemikir prinsip-prinsip dasar yang mencari kebenaran dari suatu konsep atau ide dengan memulai dari fundamental terkecil yang dapat dikonseptualisasikan. Pembicara dalam transkrip juga membahas manfaat dan cara menjadi seorang first principles thinker, yaitu dengan membuat hierarki atau peta pikiran yang menghubungkan konsep-konsep tersebut. Transkrip ini juga menyoroti pentingnya pemikiran dari first principles dalam mengembangkan ide, inovasi, dan pembelajaran, serta membahas bahaya dari menjadi first principles thinker.\n\n## Transkrip\n\nPada video sebelumnya, kita membahas tentang gagasan kekuasaan dan menciptakan kerangka pemikiran untuk memahaminya. Saya menyatakan bahwa seseorang membutuhkan dua bahan dasar untuk menjadi kuat: pemahaman yang benar tentang dunia dan sumber daya untuk membentuknya. Seperti yang dijanjikan, kita akan membahas apa yang saya tinggalkan dalam video terakhir, yaitu bagaimana cara mendapatkan pemahaman yang lebih benar tentang dunia. Saya percaya bahwa esai ini akan menerangi fakta bahwa beberapa cara berpikir lebih berguna daripada yang lain. Dari semua esai yang pernah saya tulis, ini adalah yang paling penting.\n\nHari ini, kita akan membahas cara berpikir dari prinsip-prinsip pertama. Prinsip-prinsip pertama adalah blok bangunan fundamental dari sebuah gagasan; mereka adalah bagian paling tidak terpisahkan yang kita ketahui benar dan yang kita gunakan untuk membangun pemikiran yang lebih kompleks. Saya tahu ini terdengar agak abstrak saat ini, tapi izinkan saya memberikan sejarah, analogi, dan contoh.\n\nBerpikir dari prinsip-prinsip pertama bukanlah ide yang baru atau revolusioner. Sebenarnya, ini telah menjadi mode berpikir dominan di antara semua ilmuwan dan filsuf besar selama beberapa waktu sekarang; mungkin faktor paling konsisten di antara para pemikir besar. Meskipun ada banyak praktisi dari cara berpikir ini, saya ingin memfokuskan pada salah satu yang mungkin pernah Anda dengar: Aristoteles.\n\nDia adalah seorang penyusun yang produktif yang percaya bahwa segala sesuatu dapat dibagi menjadi kategori dan subkategori. Subkategori terkecil dalam domain apa pun adalah apa yang akan kita sebut sebagai prinsip pertama. Dia juga salah satu empiris awal yang kita ketahui. Empiris adalah orang yang percaya bahwa semua pengetahuan dicapai melalui pengalaman. Sebagai salah satu kontributor besar awal dalam studi biologi, adalah masuk akal bahwa Aristoteles adalah seorang pemikir prinsip-prinsip pertama. Dia akan membedah hewan untuk memperoleh pengetahuan dunia nyata dan kemudian menggunakan kapasitasnya untuk merangkai dan mengkategorikan informasi ini. Siklus mencari pengetahuan melalui pengalaman dan menggunakan akal untuk memberikan struktur padanya adalah bagaimana seseorang sampai pada prinsip-prinsip pertama dari suatu subjek. Aristoteles percaya bahwa kita tidak bisa memiliki pengetahuan yang benar kecuali kita memahami prinsip-prinsip ini.\n\nSekarang bahwa Anda memiliki pemahaman sedikit tentang sejarah, biarkan saya memberikan analogi tentang berpikir dari prinsip-prinsip pertama. Bayangkan pengetahuan Anda dalam suatu domain tertentu sebagai pohon. Seseorang yang berpikir dari prinsip-prinsip pertama - seorang pemikir yang tidak konvensional - akan memahami tubuh pengetahuan dari buah sampai akar. Buah adalah apa yang kita lihat di depan kita: itu adalah pengetahuan yang belum dihasilkan yang dapat kita peroleh, alami, dan ulangi segera. Kita dapat melihat pohon apel, mengatakan bahwa itu hanya sesuatu yang menghasilkan apel, dan menyerah.\n\nIni adalah pemahaman yang sangat dangkal tentang pohon tetapi itu tidak salah. Di sisi lain, seorang pemikir dari prinsip-prinsip pertama akan ingin tahu bagaimana penciptaan ini benar-benar terjadi. Mereka akan melihat bahwa apel terhubung ke cabang. Setiap cabang adalah bagian dari keseluruhan yang lebih besar yang disebut batang. Akhirnya, mereka melihat bahwa akar adalah bagian paling mendasar dari pohon yang memberikan munculnya buah. Mereka telah mengumpulkan beberapa informasi tentang pohon melalui pengalaman tetapi mereka juga telah mengorganisir potongan informasi dalam hubungannya satu sama lain.\n\nFakta-fakta yang mengambang ini telah diubah menjadi tubuh pengetahuan yang terorganisir. Pemikir konvensional akan percaya bahwa mereka dapat menempatkan biji apel di mana saja dan tumbuh apel yang lezat; mereka kurang memahami yang sebenarnya. Setelah memeriksa akar, pemikir dari prinsip-prinsip pertama akan melihat bahwa buah yang lezat dimulai dengan tanah yang baik; mereka memiliki pemahaman yang halus. Pemikir konvensional adalah orang di pesta koktail yang memiliki semua fakta menarik: pengetahuannya terdiri hanya dari buah yang dapat mereka tampilkan.\n\nSebaliknya, pemikir yang tidak konvensional secara konsisten fokus pada membangun pohon pengetahuan. Seperti Aristoteles, dia atau dia bolak-balik antara pengalaman dan akal untuk membangun tubuh pengetahuan yang terorganisir dan terstruktur. Pohon yang ditanam di tanah yang baik akan memiliki akar yang kuat dan sehat dan dengan demikian menghasilkan buah yang lezat. Demikian pula, ide yang berkembang dari prinsip-prinsip pertama yang benar dan indah itu sendiri akan menjadi indah dan benar. Secara alami, jika bagian-bagian sederhana yang membentuk keseluruhan yang kompleks baik dan benar, maka keseluruhan yang kompleks itu sendiri haruslah baik dan benar juga.\n\nIni penting karena, seperti yang kita bahas dalam video terakhir, pemahaman yang benar tentang dunia diperlukan untuk memperoleh kekuatan. Apapun keyakinan kompleks yang kita miliki hanya bisa benar jika bagian-bagiannya juga benar. Untuk membuatnya lebih konkrit, mari kita pikirkan tentang proses menulis esai dari prinsip-prinsip pertama. Sebuah esai yang ditulis dengan baik seperti buah yang lezat: nikmat untuk dikonsumsi dan sulit diproduksi tanpa memahami dasarnya. Kita dapat mengidentifikasi dasarnya dengan memecahnya menjadi bagian-bagiannya.\n\nSebuah esai adalah kumpulan paragraf. Nah, sebuah paragraf adalah kumpulan kalimat. Sebuah kalimat adalah kumpulan kata. Kata-kata adalah kumpulan huruf dan huruf adalah blok bangunan dasar dari sebuah esai. Setelah komponen-komponen sebuah esai dipahami, kita dapat memperbaiki masing-masing komponen dari yang paling sederhana hingga yang kompleks. Jika kita dapat membuat setiap komponen menjadi luar biasa maka keseluruhan harus luar biasa dan itu adalah seni berpikir dari prinsip-prinsip pertama.\n\nSekarang, mari kita bicara tentang manfaatnya. Beberapa manfaat datang dari memahami ide sampai ke komponen dasarnya. Setelah Anda memahami dasar-dasar suatu ide, Anda dapat mengatur ulang, mengubah, atau menyatukannya dengan cara yang berbeda untuk menciptakan ide atau produk baru. Pada contoh menulis, kita bisa membuat lapisan lain di atas esai: kita bisa menyebut kumpulan esai sebagai buku.\n\nSekarang kita telah menciptakan sesuatu yang baru. Komponen dasar dapat diubah untuk meningkatkan ide atau produk. Misalnya, setelah kita mengetahui komponen dasar dari esai, kita dapat mengevaluasi masing-masing komponennya untuk melihat bagaimana masing-masing komponen bisa menjadi yang terbaik. Tetapi, tanpa mengetahui komponen-komponen ini, tidak mungkin membuat perbaikan apa pun. Setelah Anda memahami komponen dasar dari suatu ide, lebih mudah untuk mengintegrasikan pengetahuan baru ke dalam pemahaman Anda. Misalnya, setelah Anda tahu cara menulis huruf, menjadi lebih mudah untuk membuat kata.\n\nSetelah Anda tahu cara menulis kata, Anda bisa membuat kalimat. Setelah Anda bisa membuat kalimat, Anda bisa membuat paragraf, kemudian esai, kemudian buku, kemudian seluruh perpustakaan. Memahami komponen dasar dari suatu ide membuat lebih mudah untuk mentransfer ide yang kompleks ke orang lain. Anda dapat mulai dari komponen paling sederhana dan membangun ide dari sana; ini sama persis dengan apa yang kita coba lakukan di sekolah.\n\nKami mengajarkan anak-anak bagaimana menulis abjad, kemudian kata-kata, dan seterusnya. Pemikir prinsip pertama adalah guru yang lebih baik karena mereka dapat menentukan tingkat persis di mana pemahaman seorang siswa gagal. Jadi, Anda melihat manfaatnya tapi bagaimana seseorang bisa menjadi pemikir prinsip pertama? Bagaimana Seseorang Bisa Berpikir dari Prinsip Pertama? Berpikir dari prinsip pertama sederhana, tetapi tidak mudah.\n\nSaya hanya memiliki satu saran yang dapat dilakukan dan terinspirasi oleh Aristoteles: membuat hierarki (seperti yang kami lakukan dengan contoh esai).\nKebanyakan gagasan bersarang di dalam atau di luar satu sama lain dan tugas pemikir prinsip pertama\nadalah memetakan bagaimana gagasan-gagasan ini terkait. Seperti Aristoteles, seperti semua empiris, akan mengatakan, pengetahuan dimulai dengan pengalaman. Dunia menyajikan buah di sekeliling Anda: tindakan penciptaan yang menakjubkan dan kompleks. Menemukan akar penciptaan ini dimulai dengan pertanyaan seperti mengapa atau bagaimana.\n\nPencari kebenaran tertinggi tidak boleh puas dengan buah, namun mereka menyadari bahwa pencarian\nakar tidak pernah berakhir. Setelah mereka mengurangi suatu ide menjadi dasar-dasar terkecil yang dapat mereka pikirkan, mereka telah tiba pada prinsip-prinsip pertama.\n\nDasar-dasar ini dapat digunakan untuk berinovasi, mengoptimalkan, mempelajari ide yang lebih kompleks, atau mengajarkan orang lain. Salah satu cara terbaik untuk menemukan dasar-dasar ini adalah dengan menulis dan mengorganisir informasi dalam suatu subjek yang Anda minati dengan menggunakan hierarki atau peta pikiran seperti yang kami lakukan dengan esai.\nJadi, itu mengakhiri seri mini saya tentang kekuatan. Saya mengajukan kerangka kerja untuk kekuatan dalam video terakhir dan membahas ide menjadi berharga untuk memperolehnya.\n\nDalam video ini, saya mengajukan mode pemikiran umum untuk pencari kebenaran.\nDi video berikutnya, saya berencana untuk membahas sesuatu yang mungkin mengejutkan Anda: bahaya\nmenjadi pemikir prinsip pertama.\n\n## Pengaplikasian untuk seorang Engineering Manager\n\n1. Identifikasi dan dekonstruksi masalah: Identifikasi masalah yang perlu dipecahkan, kemudian dekonstruksi masalah tersebut menjadi elemen-elemen dasar. Misalnya, jika masalahnya adalah keterlambatan pengembangan produk, kemudian dekonstruksi masalah tersebut menjadi tugas-tugas dasar yang perlu diselesaikan, seperti pengembangan fitur, debugging, dan integrasi.\n\n2. Cari solusi dari dasar: Gunakan pendekatan bottom-up untuk menemukan solusi-solusi baru dari elemen-elemen dasar yang telah diidentifikasi. Misalnya, jika masalahnya adalah keterlambatan pengembangan produk, pertimbangkan solusi-solusi seperti mengotomatisasi tugas-tugas tertentu, memperbaiki proses debugging, atau menggunakan teknologi baru untuk mengintegrasikan fitur-fitur produk.\n\n3. Evaluasi solusi: Evaluasi setiap solusi yang dihasilkan dari sudut pandang logis dan fakta-fakta yang tersedia. Pertimbangkan juga konsekuensi jangka panjang dari setiap solusi. Jika solusi tersebut terbukti efektif, gunakan untuk memperbaiki proses pengembangan produk.\n\n4. Terus belajar: Tetap mempelajari teknologi dan tren terbaru dalam industri. Selalu mencari tahu cara-cara baru untuk memecahkan masalah dan meningkatkan proses pengembangan perangkat lunak.\n","n":0.026}}},{"i":22,"$":{"0":{"v":"3 Ways to Express Your Thoughts so That Everyone Will Understand You","n":0.289},"1":{"v":"\n![youtube](assets/20230427002651.png)\n\nlink: <https://www.youtube.com/watch?v=rrOnk0JnXW4>\n\n## Intinya\n\nInti dari transkrip ini adalah bahwa menjadi seorang komunikator yang efektif adalah keterampilan yang dapat dipelajari dan ditingkatkan melalui praktik dan pengalaman. Ada tiga tips utama yang dapat membantu seseorang menjadi lebih baik dalam berkomunikasi: memiliki fokus pada satu ide utama, menggunakan cerita untuk menjelaskan atau memperkuat ide tersebut, dan mengulang ide utama tiga kali selama presentasi. Namun, untuk benar-benar menjadi seorang komunikator yang efektif, seseorang harus merubah cara berpikir mereka tentang berkomunikasi dan mengambil langkah-langkah untuk terhubung dengan audiens mereka dengan cara yang lebih positif dan bermakna.\n\n## Transcript\n\nSaya tidak terlalu suka dengan tips; tips tentang cara berkomunikasi dengan baik, tips tentang cara menulis. Apa yang saya lebih suka adalah proses yang mengubah Anda sehingga tips terjadi secara otomatis.\n\nSeringkali, orang memberi tips seperti \"ketika Anda berbicara di depan orang banyak, variasikan kecepatan bicara Anda, variasikan volume suara Anda.\" Dua hal itu bagus, tetapi jika terjadi secara mekanis, itu menjadi membosankan. Beberapa orang merasa terbantu ketika mereka dilatih: \"pada saat ini, tinggalkan tempat Anda berdiri dan berjalan ke sana dan berhenti sejenak.\" Mungkin itu masuk akal dalam hal bagaimana ditulis, tetapi itu tidak selalu masuk akal dalam hal bagaimana Anda berbicara dan berhubungan dengan orang-orang yang Anda ajak bicara.\n\nHubungan dengan orang tersebut seharusnya menjadi sumber jeda, sumber gerakan, karena itu keluar dari proses berpikir yang saya lakukan dan keluar dari proses berpikir yang saya rasakan bahwa Anda juga alami. Ada hubungan dinamis antara kita yang mengarah pada perubahan dalam kecepatan, volume, dan hal-hal semacam itu.\n\nSebuah tips hanya merupakan intelektualisasi dari hal itu, yang mungkin baik untuk diberikan kepada seseorang setelah mereka memiliki kemampuan untuk terhubung, tetapi itu seharusnya keluar dari hubungan. Itu tidak boleh menjadi kotak centang yang Anda tandai.\n\nAda tiga tips yang saya ikuti. Kemungkinan itu adalah ide yang baik untuk mengikuti tips ini setelah Anda terbiasa terhubung dengan seseorang, tetapi ada tiga hal yang saya sukai, saya menyebutnya tiga aturan dari tiga hal.\n\nAturan pertama adalah, saya hanya mencoba mengatakan tiga hal penting saat berbicara dengan orang. Jika hanya satu hal itu mungkin lebih baik, tetapi biasanya ada banyak yang ingin dikatakan. Ketika saya membuat catatan tentang apa yang ingin saya bicarakan, jika saya melihat saya berbicara lebih dari tiga atau empat hal, saya mulai menghilangkannya atau mencoba melipatgandakan hal-hal tersebut menjadi satu. Karena tiga hal adalah semua yang bisa saya ingat dan saya tidak bekerja dari catatan saat berbicara dengan orang dan saya menyarankan orang lain juga tidak melakukannya. Saya tidak pernah membacanya karena membaca hanya akan membuat Anda terputus; itu bukan komunikasi, itu pengucilan menurut pandangan saya. Jadi saya hanya mengingat tiga hal, itu adalah aturan pertama dari tiga hal.\n\nAturan kedua adalah, jika saya memiliki hal yang sulit dipahami, jika ada sesuatu yang saya pikir tidak akan mudah dipahami, saya mencoba mengatakannya dalam tiga cara yang berbeda karena saya pikir jika Anda datang dari sudut pandang yang berbeda, Anda memiliki peluang yang lebih baik untuk memahami ide sulit ini secara tiga dimensi.\n\nDan tip ketiga, yang seringkali saya lupakan, adalah jika saya memiliki hal yang sulit untuk disampaikan, saya mencoba mengulanginya tiga kali selama pidato, sehingga pada kali pertama Anda mendengarnya, Anda mulai terbiasa, pada kali kedua sudah terasa akrab, dan pada kali ketiga Anda akan mengatakan, \"Oh ya, benar. Baiklah.\" Sekarang, saya memang mengikuti ketiga tips ini, tetapi saya tidak berpikir saya akan memberitahu seseorang: \"Anda akan berbicara di depan umum, berikut adalah tiga tips yang harus diingat.\" Ini adalah proses. Anda harus berubah menjadi seorang komunikator yang lebih baik. Anda harus melewati tahap-tahap seperti pergi ke gym, hanya saja jauh lebih menyenangkan daripada pergi ke gym karena melibatkan terhubung dengan orang lain dan kita memang dibangun untuk terhubung dengan orang lain. Meskipun kita sering menghindarinya, sebenarnya sangat menyenangkan saat kita berada dalam posisi tersebut. Jadi jika kita bisa mengubah diri kita untuk menyukai terhubung dengan audiens yang kita ajak bicara atau tulis, maka tips-tips ini akan terjadi secara otomatis atau akhirnya kita akan dapat mengaplikasikannya dalam cara yang berubah itu untuk terhubung dengan audiens dengan lebih baik. Rasanya sangat baik.\n\n## Rules of three yang bisa diaplikasikan untuk seorang engineering manager\n\n1. Ketika memberikan feedback kepada anggota tim, Anda dapat menggunakan rules of three untuk memberikan kritik konstruktif. Pertama, jelaskan apa yang dilakukan dengan benar. Kemudian, jelaskan apa yang harus diperbaiki. Terakhir, berikan saran konstruktif untuk membantu mereka memperbaiki kinerja mereka.\n\n2. Ketika memimpin rapat, gunakan rules of three untuk memastikan pesan Anda disampaikan dengan jelas dan efektif. Pertama, jelaskan masalah atau topik yang akan dibahas. Kemudian, berikan beberapa contoh atau bukti yang mendukung argumen Anda. Terakhir, sampaikan kesimpulan atau rekomendasi.\n\n3. Ketika mengembangkan strategi produk, gunakan rules of three untuk memprioritaskan fitur dan fungsi yang akan dikembangkan. Pertama, identifikasi tiga fitur yang paling penting. Kemudian, identifikasi tiga fitur tambahan yang akan meningkatkan nilai produk. Terakhir, identifikasi tiga fitur tambahan yang mungkin bermanfaat tetapi tidak kritis untuk sukses produk.\n\nDalam hal ini, rules of three dapat membantu Engineering Manager untuk berkomunikasi dengan jelas dan efektif, memprioritaskan tugas dan mengambil keputusan yang lebih baik","n":0.035}}},{"i":23,"$":{"0":{"v":"Quantified Self","n":0.707},"1":{"v":"\n\n### Quantified Self\n\nLagi baca buku \"Building a second brain\" gue nemuin sesuatu yang menarik. Penulis buku tiago forte memiliki problem pada tubuhnya dan dia metion sesutu yang belum pernah gue tau, yaitu: [Quantified Self](https://quantifiedself.com/get-started/) project yang cukup menarik dimana komunitasi ini saling membantu ke orang orang yang membutuhan self tracking. Orang orang bisa menggali insight tentang suatu masalah atau pertanyaan mengunakan data diri sendiri. Ada empat aktifitas yang akan dilakukan yaitu Pertanyaan, Mengamati, Reasoning (Memikirkan) dan Konsolidasi insight. Gue coba elaborasi\n\n#### The Questioning\n\nTahap ini lo mulai list apa aja yang jadi masalah di hidup lo. Kalau gue akhir akhir ini, ya mungkin udah lama juga sih semenjak 2020 mulai terasa mudah capek dan waktu berlalu begitu cepat. Dari sini akan tau apa yang nanti mau gue track dan coba observasi lebih dalam. Pertanyaan ini menjadi motivasi untuk diselesaikan. Yang jadi problem dalam menyelesaikan sesuatu adalah kita gak tau progress, gak tau udah sampai mana sehingga sering kali problem tidak terselesaikan dan cenderung diabaikan. Forum Quantified Self juga menyediakan platform untuk bertanya yang disebut [Project Logs](https://forum.quantifiedself.com/c/quantified-self/project-logs/41), disini kita bisa sharing dan meminta bantuan seperti cara tracking atau mungkin ada aplikasi yang membantu melakukan tracking.\n\n#### The Observing\n\nDi tahap ini lo mulai memutuskan, dari banyakanya pertanyaan yang jadi masalah buat lo, mana yang mau lo observasi lebih dalam. Ditahap ini lo akan melakukan trial error dan bereksperimen diawal. Lo akan mencoba buat menebak nebak data seperti apa yang mau lo collect. Lihat apakah ada pattern? Seberapa sering lo bakal ngukur atau mencatat? Apakah lo bakal nemu sesuatu yang bikin lo terkejut. Dan pastikan lo berfikir jernih tentang observasi ini, apakah observasi akan memberikan hal yang mungkin relevan, nyaman dan dapat dipercaya.\n\n  - Relevant: Apakah observasi ini benar benar memberikan insight?\n  - Convenient: Apakah bisa mengumpulkan data observasi dengan mudah dan konsisten?\n  - Trustworthy: Seberapa yakin dengan pengukurannya?\n\nNgomong ngomong soal validasi data bisa baca ini [Is My Data Valid?](https://quantifiedself.com/blog/validating-self-tracking-devices/) sebagai petunjuk. Pada tahap observasi catet semua apa yang sudah diamati. Toolsnya gak perlu ribet, notes digital di smartphone atau gsheet bisa, pake pensil dan kertas juga boleh. Yang penting konsisten dan gampang nyatetnya. Self tracking yang berhasil sebenernya cuma perlu satu jenis pengukuran angka setiap hari. Jadi kalau cuma buat ngukur diri sendiri gak perlu yang rumit rumit alatnya. Contohnya bisa gini\n\n  - Mood sebelum tidur atau perasaan segar setelah bangun tidur -> ini lo bisa nilai dengan angka 1-10.\n  - Kalau lo ada sakit yang menggangu, seberapa besar dan sering rasa itu -> ini juga bisa kasih skala 1-10 buat ngukur intensitas gangguan.\n  \nIntinya, self tracking bisa lo lakukan dengan cara yang sederhana tapi datanya bisa memberikan lo insight tentang kondisi diri. Kalo lo bikin prosesnya terlalu rumit ujung ujungnya lo bakal udahan, gak dilanjutin observasinya. Sebelum mulai self tracking tanya sama diri sendiri:\n\n  - Apakah lo bisa melakukan ini meskipun lo udah gak semangat lagi?\n  - Apakah metode observasi lo bisa dilakukan kapan pun? mekipun ketika lo sedang bekerja atau sedang bersama keluarga?\n\nBagian ini penting karena, lo biasanya banyak orang cuma semangat diawal dan gak bisa konsisten dengan banyak alasan seperti sibuk lah, bosen lah, gak sempet lah, dll. Akhir ini banyak sekali produk yang menawarkan health measurement, tapi pertanyaannya bisa diexport gak data mentahnya? jadi bukan cuma grafik aja. Dengan bisa mengakses data mentah, kita bisa mengolah lebih jauh lagi. Buat diskusi app dan tools bisa cek disini [App Tools](https://forum.quantifiedself.com/c/quantified-self/apps-tools/7)\n\n#### Reasoning (Penalaran)\n\nSetelah lo kumpulin data langkah selanjutnya adalah reasoning. Ada banyak cara untuk menganalisa data berbentuk angka. Bisa pake teknik statistik, Bikin prediksi dan Cek hubungan sebab-akibat antara satu tindakan dan hasil yang diperoleh. Memahami data bisa dilakukan oleh siapa saja, mau itu anak kecil sampai ilmuan, dari yang sederhana hingga yang kompleks. Ada tiga cara sederhana untuk ambil kesimpulan dari data.\n\n1. Membuat baseline: ini adalah titik awal pengukuran, gunanya buat membandingkan perubahan dimasa depan.\n\nSebagai contoh, lo mau ngukur seberapa kuat lo. Lo bisa coba dulu di iterasi pertama lo kuat berapa? misalnya 10 kali. angka 10 ini menjadi baseline yang nantinya lo bisa ngebandingin dengan performa lo beberapa minggu kedepan #YangPentingKonsisten. Kalau tadi kita pake single number, tapi bisa juga pake average karena pengukurannya selalu berubah ubah seperti denyut jantung, tekanan darah, berat badan dan mood. Kita bisa ambil satu kali pengukuran tapi bisa gak akurat. Dengan pake rata rata ini bisa membantu kita buat memahami variasi pola data. Seberapa besar fluktuasi normal dari suatu pengukuran ke pengukuran lainnya? Apakah perubahan terjadi karena kondisi tertentu? Kalau kita mengukur sesuatu pada waktu yang berbeda, misalnya pagi dan sore mungkin hasilnya tidak sama. \n\nSelain angka kita juga bisa kumpulin berdasarkan catatan atau observasi sehari hari. Tanyakan hali ini pada diri sendiri, Apa yang sebenarnya ingin lo ketahui? Apa yang ingin dipelajari dari data ini? Jawaban dari pertanyaan ini bakalan ngarahin lo ke cara kita ngumpulin baseline. Baseline gak harus berupa angka. Bisa juga berupa catatan sederhana tentang pengalaman sehari hari. Misalnya, catet pola tidur, lo merasa lebih segar setelah tidur 7 jam dibanding 6 jam, atau merasa lebih cepat tidur jika habis ngegym atau mandi air hangat. Contoh lain mencatat pola stres: Hari ini lo merasa lebih tenanhg karena lo olahraga di pagi hari. Atau mencatat interaksi sosial, Ternyata lo lebih bahagia jika lo ketemu teman lama atau lo lebih bahagia jika lo bertemu orang baru. Jadi baseline non angka ini intinya adalah asumsi awal lo tentang masalah yang lo alami, lo catet dan coba lakukan hal berbeda apakah hasilnya sama saja atau berubah.\n\n2. Gunakan timeline\n\nSalah satu cara paling umum dalam menganalisis data adalah dengan grafik yang menunjukan perubahan dari waktu ke waktu. Dengan begini lo bisa mudah melihat pola dan tren. Ini juga bakal membantu lo untuk mengidentifikasi hubungan sebab-akibat berdasarkan urutan waktu. Dan berguna untuk melihat dampak dari suatu intervensi. Timeline bissa dibuat dengan jumlah data yang sedikit maupun banyak. Mau itu cuma beberapa titik data sampe juataan. Tapi ada tantatangan teknis dalam membuatnya terutama kalau jumlah datanya besar banget dan data dikumpulkan dengan metode berbeda. Timeline tidak harus dibuat dengan alat digital yang rumit, cara paling sederhana bisa menggunakan kertan dan pensil.\n\n3. Retrospective annotation\n\nLangkah berikutnya adalah mencari tahu penyebab perlubahan yang terlihat. Apakah ada tren naik/turun? Apakah ada pola yang muncul? Apa yang menyebabkan perubahan tersebut? Jawabannya bisa aja gak langsung kelihatan. Jadi lo perlu lihat lebih dalam ke dalam konteks saat perubahan terjadi. Misalnya:\n\nTiba tiba berat badan lo turun drastis, Apakah ada perubahan dalam pola makan atau aktivitas?\nMood lo ancur dalam beberapa waktu terakhir, apakah ada kejadian yang memicu stres?\nMelakukan restrospeksi dapat membantu memahami pola ini. Lo bisa kombnasikan catatan digital lo dan memori otak lo buat merefleksikan perubahan berdasarkan data yang udah lo kumpulin. Lo juga bisa manfaatin jejak digital, kaya foto, kalender, email, chat atau aplikasi.\n\n#### Consolidating Insight\n\nSelf tracing project adalah proses pembelajaran yang terus berjalan, bukan hanya sekedar mengumpulkand ata dan menarik kesimpulan. Setiap langkah dalam proyek ini, mulai dari menentukan pertanyaan awal bisa menjadi wawasan yang berguna. Salah satu cara terbaik buat memperdalam pemahaman tentang data adalah bertindak berdasarkan insight yang diperloleh dan membagikan kepada orang lain? kenapa gitu? dengan begini lo akan dipaksa berpikir lebih dalam tentang data yang lo kumpulin. Lo bisa ningkatin kreativitas dalam melihat pola dan mencari solusi. Lo akan terbantu dalam mengoraganisir insight biar lebih fokus. Ketika lo mencoba share insight yang lo udah dapet ke orang lain, lo akan cenderung mengevaluasi ulang prosesnya. Dari sini lo bisa lebih paham tentang diri lo sendiri. Lo bakal nemuin pertanyaan baru buat diteliti lebih lanjut. Lo juga bakal mengeksploarasi teknik baru buat memvalidasi ulang. Sharing bukan tujuan akhirnya, tapi juga cara buat memerdalam pemahaman. Lo bisa sharing dengan ikut komunitas Quantified Self atau nulis blogpost. \n\nKalau lo mau ikut show&Tell, Biasanya struktur nya seperti ini. Ada tiga pertanyaan utama\n\n1. Apa yang lo lakukan?\n2. Bagaimana lo melakukannya?\n3. Apa yang lo pelajari\n\nPart \"Bagaimana\" ini lebih penting karena disini lo bisa bantu orang lain yang mau cobain hal yang sama. Yang pasti kejujuran itu hal yang paling utama, gak perlu melebih lebihkan agar hasil terlihat menarik (gak perlu ada double book buat ginian kan wkwkwkwk). Justru kejujuran dalam berbagi pengalaman, termasuk kegagalan bisa lebih bermanfaat. Hal yang tidak berhasil bisa sama berharganya dengan hal yang berhasil, karena sama sama memberikan perlajaran yang bisa dihindari orang lain. Selain itu saat berbagi hindari membuat kesimpulan yang terlalu unmum. Biasanya dari self tracking bersifat sangat pribadi, sesuatu yang berhasil buat kita belum tentu berhasil buat orang lain. jadi jangan diubah agar orang lain mengikuti.\n\nTidak ada cara yang benar atau salah dalam self tracking, tidak perlu mengesankan orang lain. Cukup fokus pada eksplorasi pribadi.\n\nHari ini gue belajar sesuatu yang menarik dan ini bakalan jadi project gue kedepannya.","n":0.026}}},{"i":24,"$":{"0":{"v":"Preparing Performance Review","n":0.577},"1":{"v":"\nTulisan ini catatan dari artikel [Preparing for performance reviews ahead of time](https://newsletter.pragmaticengineer.com/p/preparing-for-performance-reviews)\n\nBagaimana cara mempersiapkan performance review?\n\n## Mulai diawal; kumpulkan context dan set goals\n\nSesuatu yang lo harus segera lakukan, idealnya lo lakukan sebulan sebelumnya.\n\nIdentifikasi dan mengerti apa faktor yang paling penting untuk tim dan perusahaan tempat lo berkerja.\nSalah satu caranya adalah dengan bertanya ke manager.\n\n### Tanya ke manager\n\n- Apa tujuan tim ini\n- Bagaimana tim ini terlibat didalam perusahaan\n- Apa goal dari manager\n- Apa yang paling penting menurut manager\n\nDengan mengerti hal-hal ini lo akan banyak membantu di tim\n\n### Tanya kepada teman-teman yang ada di tim\n\nTanyakan kepada mereka apa yang mereka lihat sebagai tujuan paling penting bagi tim dan perusahaan.\n\n### Dengarkan company leaders dan executive\n\nPerusahaan yang baik jelas tentang tujuan mereka. Temukan apa yang paling penting caranya dengan menghadiri meetings, menonton rekaman dan membaca email yang dikirim leader yang membahas prioritas.\n\nKalau di big tech lo perlu mendengarkan beberapa seperti himbawan oraganisasi level, product org, parent organisasi, tech organisasi.\n\n### Tanyakan kepada orang orang yang berpengaruh\n\nCarilah 1:1 dengan rekan kerja yang memainkan peran kunci dan juga dapat diakses.\n\n\nSelain lo bertanya dan memahami tujuan dan apa hal yang penting bagi organisasi. lo perlu juga untuk memahami cara kerja dari sistem performance review.\n\nLo perlu mengumpulkan details dari sistem performa review, dengan cara seperti ini.\n\n- Siapa yang membuat keputusan akhir? Biasanya si manager, tapi perlu diklarifikasi.\n- Siapa yang memiliki major input dari performa review lo?\n- Kapan review ini dilaksanakan? Cek tanggal tanggal penting yang perlu diingat. Kapan deadline dari peer review atau self review? Kapan waktu kalibrasi.\n- Saran tentang apa yang dapat memastikan review ini adil. Tanya ke teman teman.\n\nBicara dengan manager tentang goals lo. Setelah lo mengumpulkan context apa yang terjadi disekitar lo. lo harus punya tujuan sendiri.\nDan tujuan lo itu harus mendukung tim dan perusahaan atau mungkin manager. Dan tentu saja, mereka harus membantu lo.\n\nSetelah lo memiliki daftar tujuan, lo kasih ke manager untuk meminta feedback. Kalau lo punya mentor didalam organisasi, share tujuan lo ini.\nDan tanya apa yang mereka pikirkan? Tujuan mana yang paling mereka sukai? Apa yang kurang? Apa suggestion yang mereka berikan?\n\nSepakati tujuan lo dengan manager lo. Salah satu cara terbaik untuk berada dipihak lo adalah dengan mereka mendukung tujuan lo.\n\nPastikan tujuan lo dituliskan.\n\n## The Power of Habit\n\nBiasanya performance reveiew ini berjalan sekali atau dua kali dalam setahun. Maka dari itu lo perlu membentuk kebiasaan dalam mencatat pekerjaan harian lo.\n\n**Keep track of your wins** maksudnya adalah performance review biasanya bias, maka ada baiknya lo catat kejadian apa yang bagus dari hari hari lo kebelakang.\nUntuk mencounter ini, lo perlu melampirkan bukti, screenshot prais ini emails atau chat atau bukti lain.\n\n**Keep a \"Work Log\"** Ini cukup mudah dengan membuat catatan lo ngapain aja dan lo membantu apa aja.\n\n![Work Log](assets/preparing-performance-review-work-log.png)  \n\nShare progress dengan manager lo. Buat regular 1:1 untuk catch up dengan manager setiap minggu.\nLalu bahas tentang pekerjaan yang telah lo lakukan, bicarakan tentang kemenangan lo, apa tantangan lo, tunjukan ke manager lo kalo lo mengelola semua task secara efektif.\n\nSebagai manager, biasanya tidak tau seberapa banyak pekerjaan yang dilakukan oleh rekan kerja. Dan biasanya pekerjaan dari engineer yang lebih experience yang mengambil banyak inisiatif. Jika engineer seperti ini tidak membagikan detailnya, manager tidak akan tau apa yang sudah dilakukan.\n\nJadi karena alasan seperti ini lebih baik lo membagikan apa yang lo lakukan dari pada lo berasumsi manager lo sudah tau.\n\nKalau lo ada di posisi leadership. lo tulis dan kirimkan weekly  [\"5-15 update\"](https://lethain.com/weekly-updates/). Maksudnya, lo tulis selama 15 menit dan tidak lebih dari 5 menit untuk membacanya.\n\nBiasanya strukturnya seperti ini\n\n- Wins \n- Challenges\n- Focus for the next week\n- What I learned\n\nAda juga yang seperti ini\n\n- Top-of mind things\n- Progress this week\n- Goals for the next week\n- Interesting things I’ve come across\n\nUpdate seperti ini lo perlu kirim setiap minggu atau dua minggu sekali\n\n\n**Get things done.** Semua ini gak ada gunanya kalo cuma sok sibuk tapi gak ada sesuatu yang lo deliver. Lo harus membangun reputasi lo sebagai seseorang yang \"menyelesaikan sesuatu\". [Internal politics for software engineers and managers:](https://newsletter.pragmaticengineer.com/p/internal-politics-part-2)\n \n>“‘Great’ is subjective to your environment; if possible, make sure it’s the right balance of high quality and speed. At startups, ‘great’ might lean towards shipping things quickly, while at larger companies, ‘great’ might mean well-tested and clean code, or code changes which are straightforward to review, and maintainable solutions.\n>\n> So, get familiar with what ‘great’ means in the context of your engineering organization, and gather regular feedback from your peers and managers to get a sense of how close your work is to this. Once you build up a reputation as someone who does great work, this will help others trust you.”\n\n**Help others.** Lo gak akan bisa melangkah jauh, kalau lo cuma mau melakukan apa yang lo suka aja. Lo harus menyeimbangkan pekerjaan yang membantu lo dengan pekerjaan yang membantu tim dan perusahaan. Jadi coba menawarkan bantuan ketika lo melihat kesempatan. Ini bisa berupa hal hal sepele seperti code review, menawarkan code review, memberikan feedback project dan merencanakan dokument.\n\n**Capture this work you do to help others**. Salah satu sisi negatif dari membantu orang itu adalah lo jadi terlalu banyak membantu dan malah pekerjaan lo jadi gak bisa diakui.\n\nSaran, pastikan tidak ada pekerjaan yang berarti tapi tidak diketahui, setidaknya oleh manager lo. Disinila work log dapat membantu dan juga lo dapat melihat apakah lo akan menghabiskan waktu hanya dengan membantu orang lain, kalau iya lo perlu re evaluasi penggunaan waktu lo.\n\n**Ask for specific feedback, every now and then.**. lo perlu meminta feedback, salah satu masalah klasik adalah tiba tiba manager lo memberikan feedback yang negatif dan lo baru tau ketika di review akhir dan lo merasa manager gak kasih tau lo. jadi dari pada lo berasumsi semua baik baik saja ada baiknya lo yang mulai bertanya.\n\nBeberapa situasi dimana lo bisa mencari feedback.\n\n- **Fasilitasi meeting.** Lo setup meeting buat tim lo. lalu setelahnya lo bertanya pada perserta yang hadir\n  - bagaimana pendapat lo tentang meeting tadi\n  - apa yang bisa lo lakukan agar bisa jadi lebih baik\n- **Resolving an outage.** Lo menyelesaikan issue di production, lalu lo berfikir lo telah melakukan pekerjaan yang hebat? apa benar? lo bisa pastikan ini ke manager lo\n- **Presenting in front of a larger group.** Ketika lo presentasi didepan banyak orang lo mungkin merasa hebat atau sepertinya ada yang kurang. Kenapa gak tanya ke salah satu yang hadir disana tentang lo, apakah lo melakukan dengan baik. Lebih baik lagi kalau lo rekam dan lo rewatch dan melakukan analisa terkait performa persentasi lo.\n- **Proposing a new initiative.** Ketika lo mengajukan project baru ke product manager dan engineering manager dan project itu mendapat lampu hijau. ada baiknya lo bertanya ke beberapa orang yang terlibat dalam proses tersebut bagaimana menurut mereka.\n- **Leading a project** Selama project lo perlu bertanya apa yang disukai mengenai proses yang ada di project ini apa yang membingungkan? Setelah project selesai lakukan retrospektif dan tentu undang teman untuk membagikan feedback bagaimana kinerja lo sebagai project lead dan apa yang bisa lo improve.\n- **Criticizing someone else’s code.** ketika lo memberikan feedback ke kode seseorang, kalau lo gak yakin apakah lo mereview dengan cara terlalu lemah atau keras lo bisa minta feedback ke peer lain apakah review yang gw tulis ini baik atau tidak.\n\nLo harus selalu minta feedback dari apa yang lo lakukan pertama kali dan perlu diingat lo harus menganggapi feedback dengan serius, dan ingat itu adalah opini bukan arahan. Dengarkan apa yang mereka katakan lalu cari tau apakah pengamatannya valid dan adakah sesuatu yang mau lo ubah dikedepannya.\n\nCaritau feedback mana yang perlu lo tindak lanjuti. Dan semuanya diawali dengan meminta feedback kalo gak ada ya lo gak punya sesuatu yang perlu pikirin nantinya.\n\n**Invest in connections beyond your manager and peer group.** lo akan menghabiskan banyak waktu lo dengan peer dan manager. Tapi kalau lo diposisi senior lo perlu lebih banyak kolaborasi dengan manager dan peer di luar dari grup lo.  \n\n![Politic](assets/preparing-performance-review-politic.png)  \n\nPertimbangkan apakah lo akan lebih banyak menghabiskan waktu dengan yang lain, coba membantu dan membangun relasi dengan tim lain. tapi perlu diingat lo melakukan ini bukan hanya sebatas nilai untuk performa review lo. tapi lo perlu membuat dampak positi di organisasi lo.\n\n## Ahead of performance review\n\n\n## Perparing to receive rating\n## How to not be “that person” who only cares about their own performance","n":0.027}}},{"i":25,"$":{"0":{"v":"Oreily","n":1}}},{"i":26,"$":{"0":{"v":"Critical Thinking at Work","n":0.5},"1":{"v":"\n## What Is Critical Thinking,  Actually?\n\nLink: <https://learning.oreilly.com/videos/critical-thinking-at/9781492028383/9781492028383-video318508/>\n\n### Inti\n\ntentang bagaimana pikiran kita cenderung lebih memilih hal-hal yang sederhana dan mudah diproses, dan bagaimana hal ini dapat memengaruhi keputusan kita dalam berbagai hal, termasuk dalam membeli barang atau dalam berpikir kritis. Penelitian juga menunjukkan bahwa membandingkan dua atau lebih hal adalah fitur yang diperlukan dalam berpikir kritis, tetapi pikiran kita cenderung untuk memilih opsi yang lebih sederhana dan terbatas. Pembicara merekomendasikan buku \"Predictably Irrational\" oleh Dan Ariely yang membahas cara-cara aneh yang kita gunakan dalam pengambilan keputusan dan bagaimana kita dapat menggunakan pengetahuan tentang cara kerja otak kita untuk membuat keputusan yang lebih baik.\n\n### Transkrip\n\n50 tahun yang lalu, Hakim Mahkamah Agung, Potter Stewart, terkenal mengatakan tentang pornografi, \"Saya tidak bisa mendefinisikannya, tapi saya tahu ketika saya melihatnya.\" Nah, apakah kita berada dalam situasi yang sama dengan pemikiran kritis? Jika saya melihat atau memahami sebuah gagasan dari seseorang dan saya sangat menyukainya, saya bisa berkata, \"Wow, ya, itu pemikiran kritis.\" Di sisi lain, jika ada gagasan yang saya tidak peduli, yang dipegang oleh seseorang, apakah baik-baik saja bagi saya untuk berkata, \"Saya tidak suka itu. Itu tidak bisa dianggap pemikiran kritis.\" Saya tidak berpikir begitu.\n\nItu bukan cara yang baik untuk memikirkan tentang pemikiran kritis karena itu hanya membawa kita pada bias kita sendiri. Dan kita tidak benar-benar belajar dengan cara itu. Jadi, ada kualitas struktural dalam pemikiran kritis. Dan saya ingin menggambarkannya sekarang. Sangat mudah seperti membandingkan dua objek atau dua gagasan. Jadi, saya berpikir tentang ponsel ini. Satu yang lebih baik daripada yang lain? Saya membandingkan keduanya.\n\n![critical thingking is comparing](assets/20230427092500.png)\n\nSaya menimbang opsi dari keduanya. Ini sesederhana itu, tetapi semenonjol itu karena dalam pertumbuhan pengetahuan dan sepanjang sejarah, kita memiliki segala jenis perbandingan. Jadi, apakah teori bahwa sel melakukan bunuh diri lebih baik daripada teori bahwa mereka hanya mati secara alami? Haruskah saya memilih Anna atau Mary? Apakah saya suka restoran A, B, atau C? Apakah teori string lebih mungkin daripada gravitasi loop kuantum? Sekarang lihat, saya tidak tahu apa-apa tentang gravitasi loop kuantum, tetapi saya bisa melihat bahwa orang-orang melakukan perbandingan semacam ini. Jadi, perbandingan adalah inti dari apa yang disebut pemikiran kritis.\n\nJadi membandingkan, membandingkan apa saja - oke, apa saja? Bagaimana dengan selai? Sekarang jika saya dalam mode otomatis, alias kebiasaan, maka saya hanya akan memilih selai boysenberry ini. Ini akan seperti, \"Oh, itu yang saya dapatkan di pasar. Saya mengambilnya dari rak.\" Tetapi jika saya berpikir tentang - saya ingin selai baru dalam hidup saya. Maka saya akan melakukan beberapa pemikiran kritis. Dan saya akan membandingkan. Jadi begitulah cara kerjanya. Tetapi saya membawa selai kepada Anda karena ada kualitas yang sangat menarik tentang apa yang sering kita lakukan ketika kita berpikir secara kritis.\n\nSeringkali, hanya dua hal yang kita bandingkan. Dan saya ingin memberikan Anda perasaan cepat tentang cara pikiran ingin mengecilkan alternatif. Ada sebuah studi selai yang sangat terkenal yang dilakukan, tetapi direplikasi di banyak area lain. Jadi juga terkait dengan hal lain, tentu saja, dalam hidup.\n\n![why is often just two things](assets/20230427093005.png)\n\nTetapi para peneliti ini melakukan penelitian dalam dua pengaturan yang berbeda. Pertama, pada suatu hari di pasar, mereka menampilkan 24 botol selai. Dan mereka meminta orang untuk mencoba, orang bisa mencicipi. Kemudian orang dapat membeli atau tidak membeli, dan sebagainya. Dalam kasus itu, 60% orang sebenarnya tertarik pada tampilan yang besar ini, tetapi hanya 3% yang membeli selai. Pada hari lain, para peneliti hanya menampilkan enam botol selai, lagi-lagi, mencicipi, tetapi 10 kali lebih banyak orang membeli selai. Dan mereka telah mereplikasi hal ini banyak kali. Ini sangat menarik. Saya pikir alasannya adalah bahwa pikiran kita hanya ingin menjaga segala sesuatu semudah mungkin. Kami agak kebanjiran jika ada lebih dari itu. Jadi jika perbandingan dengan berpikir kritis itu kompleks, kami cenderung mengurangi pilihan kami, bahkan dengan selai. Jadi, fitur yang diperlukan dari berpikir kritis adalah membandingkan dua atau mungkin lebih hal.\n\n![book recommendation](assets/20230427093110.png)\n\nJadi, saya ingin merekomendasikan buku ini oleh Dan Ariely yang berjudul Predictably Irrational. Dan di buku ini, dia banyak membahas beberapa cara aneh kita memutuskan. Aneh bahwa banyak orang tidak memutuskan dalam selai. Ada juga yang disebut anchoring. Jadi dalam studi ini, jika orang hanya diingatkan pada dua digit terakhir nomor keamanan sosial mereka, orang yang memiliki nomor keamanan sosial yang lebih tinggi - jika mereka hanya diingatkan pada itu - akhirnya mengatakan bahwa vas atau beberapa hal acak lainnya lebih berharga daripada orang yang memiliki nomor keamanan sosial yang lebih rendah.\n\nSaya maksud, kita gila, tetapi kita gila dengan cara yang bisa diprediksi. Dan kita dapat menggunakan apa yang kita ketahui tentang berpikir kritis - menghubungkannya dengan ilmu otak - untuk membantu kita membuat keputusan yang lebih baik. Pikirkan sebentar. Apakah Anda membandingkan beberapa hal baru-baru ini di tempat kerja? Kami akan melihat alasan untuk segmen berikutnya.\n","n":0.036}}},{"i":27,"$":{"0":{"v":"Belajar Coaching","n":0.707},"1":{"v":"\n- training\n  - transfer ilmu\n  - tugas\n    - membuat yang tadinya gak bisa jadi bisa\n  - type: outside in\n\n- mentoring\n  - upgrade\n  - nasihat\n  - menjadi lebih\n    - cepat\n    - efisien\n    - santai\n    - tenang\n  - type: outside in\n\n- consulting\n  - memberikan saran untuk menemukan solusi\n  - type: outside in\n\n- counseling\n  - mendengarkan dan menyembuhkan issue emosional dan kejiawaan\n  - membahas masalalu, truma\n\n- coaching\n  - membangun kesadaran diri melalui penggalian potensi dalam diri untuk mencapai suatu tujuan\n  - bintangnya ada coachernya\n  - tidak harus jadi expert\n    - tapi harus bisa menggali informasi\n      - kesadaran diri\n      - keyakinan\n      - ide ide\n      - solusi\n      - aksi\n      - komitmen\n  - bertanya dan mencari opini dari employee\n  - tidak memberikan nasihat\n  - employee centric\n  - dorong employee untuk mensolve problem\n  - membahas masa depan\n  - type: inside out\n  - coaching bisa digunakan untuk semua category team\n    - coaching for development\n      - untuk yang low performer\n    - coaching for transactional\n      - untuk bisa cepat beradaptasi\n  - kapan digunakan\n    - 1 on 1\n    - performance management conversation\n    - development conversationn\n  - effective coaching\n    - membangun hubungan dan kepercayaan (percuma kalau punya kemampuan coaching tapi gak ada yang mau wkwkwk)\n      - credibility\n        - terbukti\n        - image\n      - reliability\n        - contoh\n          - project bisa diselesaikan tepat waktu\n      - intimacy\n        - kedekatan emosional\n      - selalu mementikan diri sendiri\n      - credibility , reliability, intimacy (/) selalu mementikan diri sendiri\n        - hasilnya dapat dipercaya\n    - mendengarkan aktif (mendengarkan tanpa judgement)\n      - mendengarkan diri sendiri (lv. 1)\n        - fokus: saya dan asumsi\n      - mendengar untuk memahami (lv. 2)\n        - fokus: cocahee dan  situasi coache\n      - global listeing (lv. 3)\n      - caranya (SEA)\n        - situasi\n        - emosi\n        - ack / pengakuan\n    - bertanya efektif (menggali ide)\n      - do\n        - pertanyaan terbuka\n        - pertanyaan fokus pada solusi\n        - pertayaan yang menjelaskan situasi saat ini dan pertanyaan yang menjelaskan situasi masa depan\n          - apa yang menjadi kesulitan kamu?\n      - don't\n        - pertanyaan tertutup\n        - pertanyaan mengarahkan\n        - pertanyaan berlapis\n        - \"mengapa\"\n      - coaching FIRA\n        - fokus pada tujuan\n          - apa agenda yang ingin dibahas?\n          - apa fokus pembahasan yang anda inginkan?\n          - apa yang membuat tujuan ini penting untuk anda?\n        - identifikasi GPS (gap, posibility, solution)\n          - apa kesenjangan yang anda ketahui pada situasi saat ini\n          - apa ide anda untuk dapat mengatasi situasi tersebut\n        - rencana aksi\n          - apa langkah langkah\n          - bagaimana strategi anda agar rencana tersebut dapat berjalan sesuai dengan harapan?\n          - apa sumber daya yang anda butuhkan?\n        - akuntabilitias & komitmen\n          - apa kesimpulan dari percakapan kita tadi\n          - bagaimana anda memonitor komitment anda ?\n  - pertanyaan\n    - coaching itu dari employeenya yang minta atau coachnya yang datang karena ada problem?\n      - bisa dari mana saja\n    - tadi kan coach itu tidak harus expert, bagaimana jika memang orang itu memang stuck dan butuh panduan? apa yang akan dilakukan coach? apa masih perlu ke coach? atau langsung aja consulting ke expert?\n      - sebagai coach akan menangkap situasi dan emosi dari coachee (susah euy!!)\n      - sebagai leader coach bisa tukar topi sebagai mentor","n":0.045}}},{"i":28,"$":{"0":{"v":"Frontend","n":1}}},{"i":29,"$":{"0":{"v":"Setup Refine UI sebagai Pengganti Streamlit","n":0.408},"1":{"v":"\n## Background\n\nGue mau gantiin Streamlit. Bukan karena jelek, tapi karena udah mulai nggak cukup. Gue butuh UI yang lebih fleksibel, bisa dirender dari DSL, dan gampang diembed ke platform yang lebih besar. Tujuannya satu: bangun frontend untuk salah satu proyek biar nggak ketergantungan sama UI yang statis dan seadanya. Sebetulnya Streamlit ini enak banget dan ajaib, cuma ada beberapa hal yang sepertinya nggak bisa nih pake Streamlit. Salah satu issuenya maintain state, jadi gue coba pindahin ke Refine biar jadi satu dashboard yang lebih proper buat client dan pastinya komponen bisa lebih di-custom.\n\n## Pemilihan Framework\n\nAwalnya sempet bingung mau pakai framework apa. Ini pertama kalinya gue coba develop frontend apps karena biasanya cuma mainan backend aja. Di kepala gue, ada beberapa nama besar yang muncul: Next.js, Vue, Svelte, sama Angular.\n\nNext.js jadi kandidat paling pertama. Banyak yang pake, komunitas besar, dan bisa SSR. Tapi setelah gue dalemin, ternyata banyak setup yang sebenernya gue nggak butuh. Gue nggak ngejar SEO, nggak perlu static generation, dan kerjaan gue full dashboard internal. Jadinya malah terlalu kompleks buat sesuatu yang sebenernya bisa diselesain di level SPA.\n\nVue juga sempet gue lirik. Secara sintaksis, dia lebih ringan dibanding React. Tapi karena mayoritas plugin, komunitas, dan tooling yang gue pakai udah di ekosistem React, rasanya nggak worth effort buat pindah ke paradigma baru hanya demi perasaan \"cleaner\".\n\nSvelte itu menarik. Simple, deklaratif, dan hasil bundle-nya kecil banget. Tapi masalahnya sama kayak Vue: ekosistem gue bukan di situ. Gue butuh tooling yang matang dan siap pakai untuk hal-hal kayak form management, table, dan integrasi auth — dan Svelte belum bisa kasih itu dengan nyaman.\n\nAngular? Skip. Terlalu berat, terlalu banyak boilerplate, dan terlalu enterprise buat kebutuhan gue yang pengen iterasi cepat.\n\nAkhirnya gue ketemu Refine. Gue lihat dia bukan cuma framework frontend, tapi toolkit lengkap buat bangun internal tools. Ada resource management, form, table, bahkan data provider dan auth provider udah disiapin. Dan yang paling gue suka, dia support banyak jenis backend: REST API, GraphQL, bahkan direct integration ke Supabase.\n\nNah, soal auth, Refine punya kelebihan karena dia udah siap langsung connect ke berbagai auth provider kayak Auth0, Firebase, Keycloak, dan Supabase. Karena backend gue udah terhubung sama Supabase buat penyimpanan metadata dan autentikasi user, gue tinggal pakai authProvider bawaan dari Refine dan langsung sambungin ke Supabase. Jadinya setup auth bisa gue kerjain dalam hitungan menit, nggak perlu setup OAuth atau login system dari nol.\n\nTerakhir, soal UI framework. Refine nggak maksa kita buat pakai UI tertentu. Dia kasih opsi dari Ant Design, Material UI, Chakra UI, sampe Tailwind. Ant Design terlalu berat dan kaku buat kebutuhan gue. Material UI juga sama aja, opinionated dan sulit di-custom. Chakra UI lumayan menarik, tapi gue lebih prefer styling yang langsung bisa dikontrol lewat utility class. Makanya gue pilih Tailwind.\n\nDan supaya nggak bikin semua komponen dari nol, gue gabungin Tailwind dengan shadcn/ui. Kombinasi ini ideal: gue bisa styling fleksibel pakai Tailwind, dan pakai komponen seperti Button, Dialog, dan Card dari shadcn yang udah accessible dan ringan. Jadi akhirnya gue pilih Refine + Vite + Tailwind + shadcn, karena ini paling cocok buat build dashboard internal berbasis DSL yang fleksibel, scalable, dan gampang dipelihara. Karena dia kasih struktur yang cukup tanpa bikin gue terkekang. Dan yang paling penting: dia nggak maksa gue pakai UI library tertentu. Gue bisa pilih Tailwind dan bangun komponen gue sendiri di atasnya.gue pilih Refine. Karena dia kasih struktur yang cukup tanpa bikin gue terkekang. Dan yang paling penting: dia nggak maksa gue pakai UI library tertentu. Gue bisa pilih Tailwind dan bangun komponen gue sendiri di atasnya.\n\n## Setup Awal dengan CLI\n\nGue mulai dari nol. Literally direktori kosong. Karena Refine udah nyediain CLI yang cukup enak, gue pakai itu.\n\nLangkah-langkahnya gue breakdown di bawah:\n\n1. Masuk ke direktori kosong\n\n    ```sh\n    mkdir transformer-ui\n    cd transformer-ui\n    ```\n\n2. Jalanin CLI Refine langsung di dalam direktori\n    ```\n    npx create-refine-app .\n    ```\n    Penting: tanda titik (.) artinya generate-nya langsung di folder ini, bukan bikin folder baru.\n\n3. Pilih project template, `Pilih: refine-vite`, Gue nggak butuh SSR atau static rendering, jadi Next.js dilewatin.\n\n4. Pilih backend `Pilih: REST API` Karena gue pakai FastAPI di backend, bukan Supabase langsung. Tapi nanti auth-nya tetap pakai Supabase.\n\n5. Pilih auth provider Karena pilih `REST`, pilihan Supabase nggak muncul. Jadi gue pilih None dulu, nanti setup auth Supabase-nya manual.\n\n5. Pilih UI Framework `Pilih: Tailwind CSS` Gue mau bangun UI yang bisa dirender dari DSL, dan Tailwind itu enak banget buat styling dinamis. AntD atau MUI terlalu rigid.\n\n6. Pilih nama project Karena udah di direktori transformer-ui, tinggal tekan Enter aja.\n\n7. Contoh halaman Pilih: No, karena gue nggak butuh halaman CRUD dummy. Semuanya bakal gue render dari DSL.\n\nSetelah semuanya kelar, Refine akan generate struktur proyek lengkap, udah include config Vite, Tailwind, dan file dasar kayak src/App.tsx, src/pages, dll.\n\nSatu hal yang perlu disetel manual: path alias di tsconfig.json. Ini penting supaya struktur folder dan import path kita nggak jadi ribet. Daripada nulis ../../../components/ui/button, gue lebih prefer cukup tulis @/components/ui/button. Alias-alias ini gue tambahin di bagian compilerOptions.paths:\n\n```json\n{\n    \"compilerOptions\": {\n        \"baseUrl\": \".\",\n            \"paths\": {\n                \"@/components/*\": [\"src/components/*\"],\n                \"@/lib/*\": [\"src/lib/*\"],\n                \"@/app/*\": [\"src/app/*\"]\n            }\n        }\n    }\n}\n```\n\nTanpa ini, setiap kali pindah folder atau mindahin komponen, import path-nya bisa bikin puyeng. Alias bikin semuanya lebih rapi dan maintainable.\n\nNah, satu hal lain yang juga krusial adalah versi Tailwind yang dipakai. Refine CLI default-nya masih pakai Tailwind v3, sedangkan shadcn versi terbaru (@latest) udah disiapin buat Tailwind v4. Kalau lo langsung pakai shadcn@latest init, bisa berantakan karena struktur tailwind.config.ts dan penggunaan preset-nya udah beda jauh.\n\nMakanya, gue pilih untuk tetap di Tailwind v3 dan jalanin `npx shadcn@2.5.0 init`. Versi ini masih sepenuhnya compatible, dan semua komponen kayak button, card, dialog tetap jalan normal. Lo tetap dapet styling modular, utility-based, tapi nggak harus repot upgrade Tailwind manual.\n\nKalau suatu hari perlu Tailwind v4, ya tinggal diupgrade. Tapi buat sekarang, gue prioritaskan kestabilan dulu biar bisa langsung fokus ke logic DSL dan integrasi backend. UI pakai Vite + Tailwind v3, styling dari shadcn, dan semuanya dikontrol penuh dari konfigurasi DSL nanti. dan setup Supabase auth manual. Karena gue pengen bangun DSL renderer sendiri, dan Tailwind itu cocok banget buat styling yang dinamis dan modular. Gue nggak butuh komponen siap pakai kayak Ant Design atau MUI, yang malah jadi beban kalau mau diutak-atik.\n\n## Integrasi shadcn/ui\n\nSampai sini semuanya mulus, sampai masuk ke shadcn/ui. Tadinya gue pakai `npx shadcn-ui@latest init`, eh ternyata udah deprecated. Sekarang mesti pakai `npx shadcn@latest init`. Tapi ada catatan penting di dokumentasinya: shadcn versi terbaru didesain buat Tailwind v4, sedangkan Refine masih default di Tailwind v3. Jadi solusinya: pakai `npx shadcn@2.5.0 init` buat jaga kompatibilitas.\n\nPas init, gue pilih style Default, warna base Neutral, dan gue aktifin CSS variables buat theming. Ini penting biar nanti bisa diganti-ganti via DSL kalau mau. Setelah selesai, gue tambahin komponen dasar kayak button, input, card, textarea, dan dialog.\n\n## Next Step\n\nSelanjutnya gue bakal mulai ngebangun `UploadSection.tsx`, `LogStream.tsx`, dan `DSLRenderer.tsx`. Tapi sebelum ke situ, rekap ini penting. Bukan cuma buat dokumentasi pribadi, tapi juga sebagai catatan kalau suatu hari nanti proyek ini perlu dijalanin ulang dari nol, atau mau dibagi ke orang lain yang mau kontribusi.\n","n":0.029}}},{"i":30,"$":{"0":{"v":"Open Graph Biar Ketika Sharelink Gan Makin Kece","n":0.354},"1":{"v":"\n\n**Ngulik Bareng: Open Graph – Biar Link Lo Gak Nanggung**\n\n![alt text](assets/til.frontend.open-graph-biar-ketika-sharelink-gan-makin-kece/image.png)\n\nPernah nggak lo share link artikel, produk, atau portfolio lo di grup WA atau medsos, tapi yang muncul cuma link polos? Nah, di sinilah Open Graph (OG) berperan penting.\n\nOG itu standar yang pertama kali diperkenalkan Facebook. Intinya, lo bisa tambahin beberapa meta tag di HTML, supaya waktu link lo dishare, yang muncul bukan cuma teks URL doang. Judul, deskripsi, gambar, semua bisa lo atur biar lebih menarik dilihat.\n\nCara kerjanya simpel. Lo taruh tag kayak gini di bagian `<head>` HTML lo:\n\n```html\n<meta property=\"og:title\" content=\"Resep Bakso Super Kenyal\" />\n<meta property=\"og:description\" content=\"Rahasia bikin bakso yang kenyalnya luar biasa.\" />\n<meta property=\"og:image\" content=\"https://example.com/images/bakso.jpg\" />\n<meta property=\"og:url\" content=\"https://example.com/resep/bakso-kenyal\" />\n```\n\nNanti, begitu link lo dibuka di WhatsApp, Facebook, Twitter, LinkedIn—mereka bakal otomatis nampilin preview yang lebih rapi dan informatif.\n\nKenapa ini penting?\nSelain bikin link lo kelihatan lebih “niat”, OG juga bikin orang lebih penasaran buat ngeklik. Ini nambahin peluang engagement, bikin link lo lebih profesional, dan bantu naikin citra brand atau personal branding lo.\n\nAda beberapa hal yang penting buat diperhatiin:\nJudul dan deskripsi jangan kepanjangan. Judul sekitar 60 karakter, deskripsi 110–150 karakter udah cukup padat dan menarik. Gambar juga usahain proporsional, biasanya ukuran 1200x630px udah pas di kebanyakan platform medsos. Jangan sampe filenya kegedean, biar waktu share link, previewnya cepet muncul.\n\nKalau mau lebih lengkap, Twitter juga punya standar sendiri—`twitter:card`, `twitter:title`, `twitter:description`, `twitter:image`—yang bisa lo tambahin biar previewnya nggak berantakan.\n\nSatu hal yang suka dilupain: selalu cek preview sebelum lo publish. Tools kayak Facebook Sharing Debugger dan Twitter Card Validator itu ngebantu lo banget. Tinggal masukin link lo, terus lo bisa liat tampilan previewnya udah bener apa belum.\n\nLo bisa dalemin lagi lewat beberapa referensi kayak situs resmi [Open Graph Protocol](https://ogp.me/), dokumentasi di [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta), atau tools yang udah disediain sama Facebook dan Twitter.\n\nOpen Graph ini emang kesannya sepele, tapi dampaknya gede banget. Bukan cuma soal tampil keren, tapi juga soal kredibilitas dan profesionalitas lo di mata orang lain. Link lo jadi lebih “ngomong”, dan orang lain lebih yakin buat ngeklik.","n":0.055}}},{"i":31,"$":{"0":{"v":"Conditional Spread in JavaScript/TypeScript","n":0.5},"1":{"v":"\nJadi gini cuy, lo pernah nggak sih lagi nulis kode terus lo mikir,\n“Ini kolom cuma buat admin doang, yang lain jangan dikasih lihat.”\nTapi lo juga males nulis `if (isAdmin) columns.push(...)` karena ya… jelek aja dilihat.\n\nNah, di saat-saat kayak gitu, muncullah satu teknik yang kalau kata gue: underrated tapi power banget. Namanya **Conditional Spread**.\n\n---\n\n### Latar Belakang: Spread Biasa\n\nSebelum masuk ke versi kondisional, mari kita bahas dulu spread yang umum. Misalnya lo punya array tambahan:\n\n```js\nconst extra = [4, 5];\nconst angka = [1, 2, 3, ...extra];\n```\n\nGampang kan? `...extra` langsung ngelebarin array `[4, 5]` ke array utama.\n\nAtau kalau lo main object:\n\n```js\nconst defaultUser = { name: \"Anon\" };\nconst fullUser = { ...defaultUser, age: 30 };\n```\n\nGak ada yang aneh. Ini basic-nya spread.\n\n---\n\n### Masuk ke Kasus Nyata: Kolom Table\n\nSekarang lo punya sebuah UI table, isinya kolom-kolom buat nampilin data service yang udah diparse. Ada kolom `name`, `filename`, `created_at`, dan satu kolom spesial: `prompt`.\n\nMasalahnya, `prompt` ini confidential. Lo gak mau semua orang lihat, apalagi kalau user-nya bukan admin.\nJadi gimana caranya lo tetep bisa nulis array kolom secara rapi, tapi **kondisional**?\n\nKalau pake cara klasik:\n\n```js\nconst columns = [\n  { accessorKey: \"name\", header: \"Name\" },\n  { accessorKey: \"filename\", header: \"File\" },\n];\n\nif (isAdmin) {\n  columns.push({ accessorKey: \"prompt\", header: \"Prompt\" });\n}\n```\n\nYa bisa. Tapi lama-lama kolom lo makin banyak, kondisi makin kompleks, `if` berserakan, array mutasi di mana-mana. Gak enak.\n\n---\n\n### Di sinilah Conditional Spread Datang Menyelamatkan\n\nDengan satu line:\n\n```js\nconst columns = [\n  { accessorKey: \"name\", header: \"Name\" },\n  { accessorKey: \"filename\", header: \"File\" },\n  ...(isAdmin ? [{ accessorKey: \"prompt\", header: \"Prompt\" }] : []),\n];\n```\n\nLo udah nyelesaiin dua masalah sekaligus:\n\n1. Nambahin kolom prompt cuma kalau admin\n2. Tetep nulis array secara deklaratif, gak pake `push`\n\nLihat bagian `...(isAdmin ? [promptColumn] : [])`\nArtinya simpel: **kalau lo admin**, tambahin kolom `prompt`. Kalau enggak, spread array kosong `[]` — yang artinya gak ngaruh apa-apa.\n\n---\n\n### Bukan Cuma Array, Bisa Juga di Object\n\nLo bisa pake trick yang sama buat object. Misalnya lo punya object user dan lo pengen nambahin property `badge` kalau user-nya premium:\n\n```js\nconst user = {\n  name: \"Zeihan\",\n  ...(isPremium && { badge: \"gold\" }),\n};\n```\n\nKenapa ini works? Karena di JS:\n\n* `false && {}` → hasilnya `false`, jadi `...false` gak nambah apa-apa\n* `true && { badge: \"gold\" }` → hasilnya object, jadi `...{ badge: \"gold\" }` disebar\n\nJadi lo bisa punya object yang isinya nambah atau nggak nambah tergantung kondisi. Mirip kayak di Go lo lagi manggil fungsi variadic, tapi sebelum dipass-in lo punya `if` yang nentuin param mana yang masuk.\n\n---\n\n### Kapan Teknik Ini Berguna?\n\n* Lagi bikin config `columns`, `tabs`, `routes`, `menu`, `props`\n* Lo pengen hasil akhir yang rapi, clean, dan gak pakai mutasi array\n* Lo pengen maintain logic access atau permission tanpa if-else berderet\n* Lo ngoding pake framework declarative kayak React, Svelte, atau Vue\n\nDi project gue, teknik ini jadi senjata utama buat nyusun UI yang kontekstual — berubah tergantung siapa user-nya, role-nya, atau setting-nya.\n\n---\n\n### Catatan Tambahan\n\nAda satu hal yang bikin ini makin enak: **nggak perlu bikin array baru di luar**. Lo langsung inject logika ke tempat di mana lo bangun array-nya.\n\nKalau lo mau makin modular, lo bisa ekstrak jadi fungsi `getDynamicColumns(isAdmin)` atau bahkan bikin `usePermission()` biar `canViewPrompt` tinggal dipakai di mana-mana.\n\nDan yang paling penting, syntax ini bikin lo keliatan pinter pas code review — padahal yang lo lakuin cuma spread ternary.\n\n---\n","n":0.044}}},{"i":32,"$":{"0":{"v":"Devops","n":1}}},{"i":33,"$":{"0":{"v":"Troubleshots","n":1}}},{"i":34,"$":{"0":{"v":"Terraform on M1","n":0.577},"1":{"v":"\nGembel banget, entah kenapa terraform di M1 ada issue nyebelin.\n\n```sh\n│ Error: Incompatible provider version\n│ \n│ Provider registry.terraform.io/hashicorp/template v2.2.0 does not have a package available for your current platform,\n│ darwin_arm64.\n│ \n│ Provider releases are separate from Terraform CLI releases, so not all providers are available for all platforms. Other versions\n│ of this provider may have different platforms supported.\n```\n\nbisa bisanya, di M1 gak ada dan gak update. Perlu ada workaround buat benerin ginian.\n\n```sh\nbrew install kreuzwerker/taps/m1-terraform-provider-helper\nm1-terraform-provider-helper activate\nm1-terraform-provider-helper install hashicorp/template -v \n```\n\n## Referensi\n\nLengkapnya disini sih, https://github.com/kreuzwerker/m1-terraform-provider-helper\n\nGue ceritain dikit kali ya soal gimana cara kerja project `m1-terraform-provider-helper` ini.\n\nJadi gini, lo abis install Terraform, pengen pake provider tertentu — misalnya `vault` atau `azurerm` — tapi begitu lo jalanin `terraform init`, malah error karena gak nemu provider buat darwin\\_arm64. Masalahnya, banyak provider di registry Terraform itu cuma sediain binary buat x86\\_64, alias amd64. Nah, di M1, itu gak langsung bisa dipake, dan Terraform juga strict banget soal checksum. Gak bisa asal compile lokal doang, karena lockfile-nya bakal nolak kalau checksum-nya beda.\n\nDi situ lah `m1-terraform-provider-helper` masuk. Dia basically ngebantuin lo untuk compile provider-provider itu dari source code langsung di mesin lo, tapi gak cuma berhenti di compile doang. Dia juga nanganin semua penempatan binary-nya di path yang Terraform expect, dan bahkan bisa bantu lo update `.terraform.lock.hcl` biar checksum dari binary lokal tadi dianggap valid sama Terraform.\n\nCara pakenya pun cukup simpel. Pertama lo aktifin dulu si helper-nya lewat `m1-terraform-provider-helper activate`. Ini bakal nge-setup environment lo biar Terraform ngarah ke folder plugin lokal yang dipake si helper. Abis itu lo tinggal install providernya, misalnya `m1-terraform-provider-helper install hashicorp/vault -v v2.10.0`. Di balik layar, dia bakal clone repo GitHub providernya, nge-run build (biasanya `make build`), dan nyimpen hasilnya ke direktori plugin Terraform dengan struktur folder yang valid sesuai versi Terraform lo.\n\nSatu langkah lagi yang penting, lo harus update lockfile-nya. Karena provider lokal yang lo compile tadi punya checksum yang beda, lo bisa jalanin `m1-terraform-provider-helper lockfile upgrade` supaya `.terraform.lock.hcl` lo ditambahin checksum dari binary baru tadi. Kalau enggak, Terraform bakal tetap error pas lo `init` atau `apply`.\n\nDan udah, gitu doang. Lo sekarang bisa jalanin Terraform kaya biasa, tapi semua provider yang tadinya gak support M1 sekarang udah bisa dipake tanpa error checksum atau masalah arsitektur. Tool ini tuh fungsional banget kalau lo kerja banyak dengan Terraform di Mac M1 dan capek debug karena provider gak support.\n\nKalau lo butuh compile custom atau provider dari repo yang gak standar, dia juga sediain flag buat override build command atau source URL. Tapi buat sebagian besar kasus, command default-nya udah cukup.\n\nSingkatnya, ini tool yang ngisi celah antara Apple Silicon dan ekosistem Terraform yang belum 100% native ARM. Gak perlu hack aneh-aneh atau tunggu provider dirilis resmi, tinggal compile lokal dan jalan.\n","n":0.047}}},{"i":35,"$":{"0":{"v":"Terraform","n":1},"1":{"v":"\n## **1. Kenapa Lo Perlu Peduli Sama Infrastructure as Code (IaC)?**\n\n---\n\n### **2009: Era Klik-Klik Next Sampai Capek**\n\nGue inget banget waktu jaman kuliah lagi belajar deploy website di warnet.\nLu mesti buka cPanel, klik \"File Manager\", upload `index.html`, terus klik \"Extract\".\nKalau ada database, buka \"phpMyAdmin\", create database manual, terus import file `.sql`.\n\nDan yang paling ngeselin:\n\n> “Eh, kok di komputer dengan xampp bisa jalan, tapi di server malah error?”\n\nTiap deploy ke production rasanya kayak lagi nge-gacha. Kadang sukses. Kadang... server-nya blank putih.\n\nKenapa? Karena semuanya **manual dan gak tercatat**. Nggak ada yang tau siapa yang ganti setting `php.ini`. Atau kenapa tiba-tiba `mod_rewrite` gak aktif. wkwkwkwk\n\n---\n\n### **2014: DevOps Naik Daun, Tapi Kayak Dewa yang Gak Boleh Sakit**\n\nMasuk era cloud. AWS makin populer. EC2 jadi temen semua orang.\nTapi setup-nya masih sama: lo SSH ke server, ketik:\n\n```bash\nsudo apt install nginx\nsudo systemctl start nginx\n```\n\nDan lo tulis semua itu... di Notes. Atau di Ms. Word yang gak pernah dibuka lagi.\n\nSampai suatu hari, lo udah gak ikut projectnya lagi, terus temen lo nanya:\n\n> “Eh, lo dulu waktu deploy app X pake nginx atau apache ya?”\n\nDan lo cuma bisa jawab:\n\n> “Gue juga gak yakin, coba cek history bash aja.”\n\n---\n\n### **2016–2017: Ketemu Docker, Tapi Belum Tahu Sebenernya Lo Butuh Dia**\n\nDi masa ini, lo mulai main Docker.\nAwalnya karena penasaran: *“Ini apaan sih kok bisa jalanin app tanpa install macem-macem?”*\n\nLo build image, `docker run`, terus amazed:\n\n> “Buset, ini MySQL tinggal jalan gitu doang.”\n\nTapi waktu itu lo masih mikir:\n\n> “Docker ini kayak virtual machine versi mini ya?”\n> Padahal nggak gitu juga. Tapi gak apa-apa, semua orang pernah salah paham dulu.\n\n---\n\n### **2018: Baru Ansible Mulai Masuk Obrolan**\n\nMulai sering diskusi soal automation, provisioning, dan config.\nAda yang bilang:\n\n> “Pakai Ansible dong, gak perlu SSH satu-satu.”\n\nDan lo mulai coba.\n\nLo tulis playbook, lo SSH-in semua VM, dan berhasil. Tapi... lo ngerasa capek.\n\n```yaml\n- name: install nginx\n  apt:\n    name: nginx\n    state: present\n```\n\nLo mikir, “Lah ini bedanya apa sama bash script yang dibungkus doang?”\n\nAnsible jalan, tapi verbose.\nBuat satu hal kecil, lo nulis satu file panjang.\nDan lo harus mikir urutan — **prosedural banget** cuy.\n\n---\n\n### **2020: Infrastruktur Udah Jadi Makhluk Sendiri**\n\nSatu project sekarang udah gak cukup pakai 1 server.\nMinimal:\n\n* 1 buat app\n* 1 buat database\n* 1 buat monitoring\n* dan load balancer biar gak malu-maluin pas demo\n\nBelum lagi security group, subnet, IP publik, volume, DNS, TLS, sertifikat, user, IAM, cloudwatch, metric.\n\nLo sadar sekarang:\n\n> \"Kita gak bisa lagi jalanin semua ini pake tangan. Harus pake **kode**.\"\n\n---\n\n### **Datanglah Terraform: Lo Nulis Kode, Tapi yang Jalanin Mesin**\n\nTerus lo ketemu Terraform.\nLo nulis kayak gini:\n\n```hcl\nresource \"aws_instance\" \"web\" {\n  ami           = \"ami-abc123\"\n  instance_type = \"t2.micro\"\n}\n```\n\nDan... **BOOM!**\nServernya muncul. Otomatis. Konsisten. Bisa diulang. Bisa dibalikin ke kondisi awal.\n\nLo bisa `terraform plan` buat liat perubahan\nLo bisa `terraform apply` buat beneran ngerubah\nDan kalau lo nyesel: `terraform destroy` aja. Kayak hubungan yang salah dari awal.\n\n---\n\n### **Hari Ini: Infrastruktur Lo Gak Boleh Jadi Mitos**\n\nTim lo makin banyak.\nLo kerja bareng orang lain.\nKalau semua setup masih ada di kepala lo, berarti lo bottleneck.\nKalau lo disuruh liburan dan takut production error, berarti sistem lo belum bener.\n\nDengan Infrastructure as Code:\n\n* Semua bisa direview kayak kode biasa\n* Bisa ditest, dikontrol via CI/CD\n* Bisa direstore kalau ada yang kacau\n* Dan yang paling penting: **gak bikin lo jadi single point of failure**\n\n---\n\n\n## **Apa Itu Terraform dan Kenapa Banyak yang Milih Ini?**\n\nJadi gini...\n\nBayangin lo lagi kerja di startup baru. Lo baru deploy 3 VM manual di AWS buat staging.\nTerus besoknya, disuruh deploy hal yang sama buat production.\nBesoknya lagi, buat environment testing.\nDan lo mulai sadar:\n\n> *“Eh, kok gue ngulang-ngulang ya? Ini kerjaan manusia atau robot sih?”*\n\nNah, di sinilah muncul ide gila:\n**Kenapa gak lo tulis aja infrastrukturnya kayak lo nulis kode?**\nGak perlu klik-klik, gak perlu ngetik `ssh`, cukup `terraform apply`, dan *boom!*\nSemua VM, database, security group, VPC, sampai DNS record langsung jadi.\n\nDari sini udah bisa dibayangin berapa banyak waktu \"klak-klik\" manual cuma bikin VM / hal yang sama.\nLu cuma perlu \"copas\" dan ganti beberapa variable, udah. jadi dalam hitungan menit. gokil sih.\n\n---\n\n\n### **Apa Itu Terraform dan Kenapa Banyak yang Milih Ini?**\n\nSebelumnya gue udah cerita, sekitar tahun 2018 gue mulai kenal sama Ansible.\nTapi, waktu itu bukan cuma Ansible doang yang rame di skena.\nAda juga nama-nama kayak **Chef**, **Puppet**, bahkan **SaltStack** yang ikut nongol di skena DevOps.\n\nSemua menawarkan janji yang kurang lebih sama:\n\n> “Biar lo gak perlu lagi setup server satu-satu pake SSH.”\n\nGue inget banget, waktu itu rasanya kayak ada lomba—siapa yang paling gampang bikin 10 server langsung jalan dan auto install semua service.\n\nTapi ternyata, itu semua belum cukup.\n\nSoalnya makin lama gue utak-atik, makin sadar:\n**\"Ini baru setup di dalem server, tapi bikin infrastrukturnya sendiri masih ribet, bro.\"**\n\nLo tetep harus klik-klik bikin VM, bikin VPC, bikin load balancer…\nDan ini bikin gue mikir:\n\n> “Kalau ngatur aplikasi aja udah bisa pake kode, masa bikin infrastrukturnya gak bisa?”\n\nDan akhirnya, gue ketemu sama si satu ini:\n**Terraform.**\n\n---\n\n#### **Terus, Apa Bedanya Sama Ansible, Chef, atau Puppet?**\n\nBedanya bukan cuma di syntax atau nama variabel.\nBedanya ada di *cara lo mikir*.\n\nTools kayak **Ansible** itu ngajarin lo mikir prosedural.\nLo bilang ke server:\n\n```yaml\n- install nginx\n- copy config\n- start service\n```\n\nLo kayak lagi masak di dapur, satu langkah demi langkah. Salah di salah satu langkah, masakan bisa jadi beda rasanya.\n\nSementara **Terraform** itu mikirnya kayak arsitek:\nLo bilang apa yang lo pengen, dan dia yang urus detailnya.\n\n> *\"Gue mau 3 VM di AWS region Singapore, instance-nya t3.micro, udah ada tag-nya 'env=staging'.\"*\n\nUdah. Gak perlu kasih tau cara login ke AWS Console, klik tombol mana, urutannya gimana.\nDia bakal bandingin kondisi sekarang (state) sama keinginan lo (desired state), dan langsung bikin plan buat nyamain keduanya.\n\nIni yang disebut pendekatan **declarative**, dan ini bikin beda banget rasanya.\n\n---\n\n### **Kenapa Banyak yang Suka Terraform?**\n\n#### 1. **Deklaratif dan Predictable**\n\nJadi Lo bilang mau 3 VM, dia kasih 3 VM. Lo ganti jadi 5, dia tambahin 2.\nDia juga ngasih tau sebelum jalan:\n\n```bash\n+ create aws_instance.web[2]\n~ update aws_instance.web[0]\n- destroy aws_instance.old\n```\n\nJadi gak ada kejutan-kejutan konyol.\n\n---\n\n#### 2. **Cloud Agnostic, Tapi Tetep Spesifik**\n\nLo bisa pakai Terraform buat deploy ke:\n\n* AWS\n* Azure\n* Google Cloud\n* bahkan DigitalOcean, Oracle, dan on-prem\n\nTapi tetep bisa manfaatin fitur khas tiap cloud. Misal lo pengen pake **S3 bucket lifecycle**, tinggal tulis di config-nya — gak harus nyamain semua cloud biar setara.\n\n---\n\n#### 3. **Bisa Disimpan di Git dan Di-review Kayak Kode**\n\nKarena semua infrastruktur lo ditulis pake `.tf`, lo bisa commit ke Git, review pake PR, kasih komentar, dan track history-nya.\n\nLo bakal bisa bilang:\n\n> “Siapa yang hapus VPC minggu lalu?!”\n> dan tinggal buka Git log.\n\n---\n\n#### 4. **Integrasi Sama CI/CD dan Workflow Modern**\n\n* Lo bisa pasang `terraform plan` di GitHub Actions tiap ada PR.\n* Lo bisa linting, formatting, sampai state backend di S3.\n* Lo bisa kolaborasi via Terraform Cloud atau workspace manual.\n\nIntinya: bisa masuk ke pipeline modern, tanpa harus ngotak-ngatik GUI cloud provider.\n\n\n## **Proses Kerja Terraform**\n\nPertama kali gue pakai Terraform, gue sempet mikir,\n\n> “Ini tool bisa bikin infrastruktur secara otomatis, jangan-jangan kayak magic ya?”\n\nTernyata bukan. Bukan sulap. Bukan sihir.\nTapi logika dan *state management* yang rapi dan disiplin banget.\n\nGue bakal ceritain alurnya step-by-step, biar lo ngerti cara kerjanya dari awal sampe akhir.\n\n---\n\n### **1. Lo Tulis Kebutuhan Lo (HCL - HashiCorp Configuration Language)**\n\nYang pertama lo lakuin: lo bikin file `.tf`.\n\nMisalnya lo pengen jalanin container Docker pake image `nginx`, lo bisa tulis kayak gini:\n\n```hcl\nresource \"docker_container\" \"nginx\" {\n  name  = \"tutorial\"\n  image = docker_image.nginx.image_id\n\n  ports {\n    internal = 80\n    external = 8000\n  }\n}\n```\n\nLo gak nyuruh dia “install Docker dulu”, atau “buka port 80 manual”.\nLo tinggal deklarasi: gue mau container `nginx` jalan, expose port sekian.\n\nIni kayak lo bilang ke arsitek:\n\n> “Gue mau rumah 2 lantai, kamar 3, kamar mandi 2, dan ada dapur outdoor.”\n\nBukan:\n\n> “Pertama gali tanah, lalu cor pondasi, lalu pasang bata...”\n\n---\n\n### **2. Terraform Init – Kenalin Dulu Dunia Lo**\n\nBegitu file lo selesai, langkah pertama:\n\n```bash\nterraform init\n```\n\nIni penting karena Terraform butuh download plugin buat provider yang lo pakai.\nProvider itu kayak jembatan antara Terraform dan platform yang lo kelola—bisa AWS, GCP, Docker, Azure, dan lain-lain.\n\nMisalnya kalau lo deploy ke Docker, dia akan download plugin `kreuzwerker/docker`.\nKalau ke AWS, dia ambil plugin `hashicorp/aws`.\n\nTanpa ini, lo cuma punya file `.tf` doang yang gak tau nyambung ke mana.\n\n---\n\n### **3. Terraform Plan – Simulasi Tanpa Komitmen**\n\nLanjut ke tahap paling menarik:\n\n```bash\nterraform plan\n```\n\nNah ini dia kekuatan utama Terraform: **rencana.**\n\nDi sini lo bakal lihat:\n\n* Apa yang bakal dibuat?\n* Apa yang bakal dihapus?\n* Apa yang bakal diubah?\n\nMisalnya dia bilang:\n\n```text\n+ create docker_container.nginx\n```\n\nArtinya, dia bakal bikin container baru.\n\nTapi dia belum bener-bener bikin.\nIni cuma *preview*.\nKayak lo liat maket rumah dulu sebelum mulai bangun.\n\nDan bagian paling krusial?\n**State file** – `terraform.tfstate`.\n\nIni file penting banget.\nIsinya catatan lengkap:\n\n> “Sekarang gue udah bikin resource ini, id-nya segini, status-nya gini.”\n\nJadi tiap kali lo `plan`, Terraform bakal bandingin:\n**current state (di tfstate)** vs **desired state (di .tf)**.\n\n---\n\n### **4. Terraform Apply – Waktunya Eksekusi**\n\nKalau lo udah yakin sama hasil `plan`, lo tinggal jalanin:\n\n```bash\nterraform apply\n```\n\nDi sini dia bakal mulai ngebangun beneran.\n\nSemua deklarasi lo di file `.tf` bakal diwujudkan jadi resource nyata:\n\n* Docker container jalan\n* EC2 instance muncul\n* Load balancer aktif\n* S3 bucket kepasang\n\nDan semuanya dicatat lagi ke dalam `terraform.tfstate`.\n\nJadi, kalau lo jalanin `apply` dua kali, dia gak bakal bikin dua kali.\nDia bakal bilang:\n\n> “Semua udah sesuai, gak perlu diapa-apain.”\n\nIdempotent, cuy. Konsisten.\n\n---\n\n### **5. Terraform Destroy – Kalau Lo Mau Ngebongkar Semuanya**\n\nPunya iseng dan pengen bersihin semuanya?\n\n```bash\nterraform destroy\n```\n\nTerraform bakal baca file `tfstate` dan ngehapus semua resource yang dia bikin sebelumnya.\nYa, **cuma yang dia bikin**, yang lain kagak dia sentuh.\n\nIni bikin dia aman dan terkontrol.\nGak ada tuh cerita “asal delete” kayak lo tekan tombol terminate di AWS Console.\n\n---\n\n### **Bonus: State Bisa Disimpan di Cloud**\n\nKalau kerja sendirian, simpan `terraform.tfstate` lokal oke-oke aja.\nTapi kalau tim lo banyak? Lo harus simpan di **remote backend** kayak:\n\n* S3 + DynamoDB (buat locking)\n* Terraform Cloud\n* Azure Blob\n* GCS\n\nKenapa?\nKarena:\n\n1. Lo butuh **locking** biar gak dua orang edit infrastruktur barengan.\n2. Lo butuh **backup** biar tfstate gak ilang.\n3. Lo butuh **visibility**, siapa ngapain kapan.\n\n\n## **Gandeng Temen: Packer, Docker, Ansible, Kubernetes**\n\n*(Alias: Terraform Gak Berdiri Sendiri, Bro)*\n\nJadi gini…\nTerraform itu keren, tapi dia gak bisa mmelakukan semuanya sendiri.\nDia perlu temen. Dan temen-temennya ini—Packer, Docker, Ansible, Kubernetes—punya peran masing-masing.\n\n---\n\n### **1. Packer – Si Tukang Cetak (Image Builder)**\n\nBayangin lo mau deploy 100 VM identik.\nKalau setiap kali setup lo harus install package satu-satu, masukin config manual, ya kelar hidup lo.\n\nNah, Packer datang sebagai penyelamat.\nDengan Packer, lo bisa bikin **template image** (bisa AMI di AWS, bisa Docker image, bisa VHD di Azure) yang udah siap pakai.\n\nContoh:\nLo tulis satu file `.json` atau `.hcl` buat bilang:\n\n```hcl\n- Base image: Ubuntu\n- Install nginx\n- Copy konfigurasi lo\n- Buat snapshot image-nya\n```\n\nJadinya?\nSatu VM image yang tinggal **plug and play**.\nGak perlu setup dari nol tiap kali launch.\n\nBiasanya workflow-nya begini:\n\n1. Lo build image pakai Packer\n2. Hasilnya dipakai sama Terraform buat deploy server\n3. Server langsung siap tempur dari detik pertama\n\n---\n\n### **2. Docker – Bikin Aplikasi Lo Portabel**\n\nDocker itu kayak bento box buat aplikasi.\nSemua udah dikemas rapi di satu tempat:\n\n* Code-nya\n* Dependency-nya\n* Runtime-nya\n\nDan yang paling gila:\nLo bisa build image-nya di laptop, terus jalanin di VM production tanpa drama \"eh dependency-nya beda ya\".\n\nMakanya Docker dan Terraform itu cocok banget.\nDengan provider `kreuzwerker/docker`, lo bisa:\n\n```hcl\nresource \"docker_container\" \"nginx\" {\n  image = \"nginx\"\n  ports {\n    internal = 80\n    external = 8080\n  }\n}\n```\n\nUdah, lo punya container jalan lewat Terraform.\nGak perlu masukin command `docker run` satu-satu.\n\n---\n\n### **3. Ansible – Si Tukang Rapiin (Configuration Management)**\n\nLo udah punya server (misal via Terraform), tapi mau ngatur dalamnya:\n\n* Install Python\n* Setup cron job\n* Pasang cert SSL\n\nDisinilah Ansible masuk.\n\nDia tool configuration management berbasis YAML.\nBedanya sama Terraform?\nTerraform ngurus *apa yang harus ada*,\nAnsible ngurus *gimana caranya* ngerjain itu.\n\nDan yang asik, keduanya bisa kerjasama.\n\nContoh:\n\n* Terraform deploy 5 VM, kasih tag `role=web`\n* Ansible scan semua VM yang punya tag itu\n* Ansible setup nginx di dalamnya\n\nEfisien. Clean. Automation yang terstruktur.\n\n---\n\n### **4. Kubernetes – Si Jenderal Pasukan Container**\n\nKalau lo udah jalanin banyak Docker container, lo bakal ngerasain keribetan:\n\n* Gimana kalau 1 container mati?\n* Gimana cara auto scaling?\n* Gimana rolling update?\n* Gimana load balancing?\n\nNah, Kubernetes adalah jawabannya.\n\nTapi Kubernetes **kompleks**.\nLo gak deploy 1–2 command. Lo bikin cluster.\nLo butuh worker node, control plane, networking internal, volume, service discovery, dll.\n\nMakanya best practice-nya:\n\n1. Lo bikin **VM image khusus** pake Packer (udah ada Docker dan agent Kubernetes)\n2. Deploy semua node pakai Terraform\n3. Otomatis semua nyambung dan bikin cluster\n\nJadi kombinasi lengkapnya:\n\n* Packer: bikin image\n* Terraform: deploy VM dan cluster\n* Kubernetes: orkestrasi container\n* Docker: format aplikasinya\n* Ansible: kalo masih mau pegang low-level config\n\n\n## **Setup Terraform dan Deploy ke Docker: Error Pertama, Pahami Akar Masalahnya**\n\nWaktu pertama kali nyobain Terraform, gue langsung tertarik buat nyambungin ke Docker.\nAlasannya simpel:\n\n* Gampang dites lokal\n* Gak butuh akun cloud\n* Bisa cepet lihat hasilnya\n\nGue ambil contoh paling basic dari dokumentasi:\n\n```hcl\nterraform {\n  required_providers {\n    docker = {\n      source  = \"kreuzwerker/docker\"\n      version = \"~> 3.0.1\"\n    }\n  }\n}\n\nprovider \"docker\" {\n  host = \"npipe:////.//pipe//docker_engine\"\n}\n\nresource \"docker_image\" \"nginx\" {\n  name         = \"nginx\"\n  keep_locally = false\n}\n\nresource \"docker_container\" \"nginx\" {\n  image = docker_image.nginx.image_id\n  name  = \"tutorial\"\n\n  ports {\n    internal = 80\n    external = 8000\n  }\n}\n```\n\nGue save file itu sebagai `main.tf`, lalu di terminal:\n\n```bash\nterraform init\nterraform apply\n```\n\nTerus… **boom! Error.**\n\n---\n\n### **WSL dan Docker: Gak Semulus Itu, Ferguso**\n\nTernyata bagian ini:\n\n```hcl\nhost = \"npipe:////.//pipe//docker_engine\"\n```\n\nItu **khusus buat Windows native**, bukan WSL.\nDi WSL, host Docker-nya beda: biasanya lo connect ke Docker via socket di `/var/run/docker.sock`.\n\nAkhirnya gue ubah jadi:\n\n```hcl\nprovider \"docker\" {\n  host = \"unix:///var/run/docker.sock\"\n}\n```\n\nTapi di sinilah muncul masalah baru:\n\n```bash\nError: unable to connect to Docker daemon\n```\n\nPadahal gue bisa `docker ps` di terminal WSL. Kok Terraform gak bisa connect?\n\n---\n\n### **Root Cause-nya? Permission dan Env Variable**\n\nGue coba debug:\n\n```bash\necho $DOCKER_HOST\n```\n\nTernyata kosong.\nDocker CLI bisa jalan karena dia nyambung ke socket default, tapi Terraform butuh host yang eksplisit. Jadi lo harus set `DOCKER_HOST` environment variable, atau masukin langsung ke config Terraform.\n\nTapi belum selesai sampai situ.\n\nKadang juga muncul error permission:\n\n```\npermission denied while trying to connect to the Docker daemon socket\n```\n\nSolusinya:\n\n```bash\nsudo usermod -aG docker $USER\n```\n\nLalu restart WSL, atau:\n\n```bash\nnewgrp docker\n```\n\n---\n\n### **Akhirnya Jalan**\n\nSetelah ngoprek dikit, akhirnya:\n\n```hcl\nprovider \"docker\" {\n  host = \"unix:///var/run/docker.sock\"\n}\n```\n\nDan semua command Terraform bisa jalan normal:\n\n```bash\nterraform init\nterraform apply\n```\n\nContainer NGINX langsung jalan di port 8000.\nCek pakai browser:\n\n```\nhttp://localhost:8000\n```\n\nMuncul welcome page-nya NGINX. Akhirnya berhasil!\n\n---\n","n":0.021}}},{"i":36,"$":{"0":{"v":"Setup Vm Azure","n":0.577},"1":{"v":"\n## 1. Pendahuluan\n\nLo mungkin udah sering denger soal **Flowise**—platform open-source yang simpel buat bikin chatflow AI dan integrasi ke berbagai sumber data. Kenapa Flowise? Karena dia bener-bener plug and play: lu tinggal deploy, bikin workflow, dan langsung bisa ngobrol pake LLM kayak ChatGPT. Ga usah repot setup backend ribet—langsung gas.\n\nDi tutorial kali ini, kita bakal setup Flowise dari awal sampe jalan di server, pake VM. Tapi apa sih **VM** itu?\nSingkatnya, VM (Virtual Machine) adalah server virtual yang lu bisa sewa dan kontrol sendiri. Ibaratnya kayak PC lo, tapi jalan di cloud. Lu bisa pilih: mau di Azure, AWS, GCP—semua sama prinsipnya. Kali ini, gue contohin di **Azure VM**, tapi langkahnya bakal sama aja kalau lu mau pake yang lain.\n\nKenapa pake VM?\n\n* Karena **Flowise** itu butuh environment yang stabil dan bisa diakses internet.\n* Ga ribet: lu punya full akses buat ngatur environment, install apa aja, aman.\n* Bisa di-scale: nanti butuh worker, tinggal jalanin worker. Mau load balancer? Tinggal setup.\n\nJadi, di sini kita bakal **bikin VM di Azure, setup environment (Docker, Compose), deploy Flowise sampe kelar**.\nNextnya, lu bisa lanjut ke worker (buat load queue), bikin backup otomatis, sampe customin environment. Tapi yang penting: Flowise harus hidup dulu.\n\nOke, Section 2 gue lanjut!\n\n---\n\n## 2. Persiapan VM\n\nSebelum Flowise bisa jalan, kita butuh environment-nya dulu: **VM** (Virtual Machine) yang siap jadi rumah Flowise. Gue bakal bahas mulai dari bikin VM sampe nyiapin environment dasarnya.\n\nOke, mari kita revisi dan bikin lebih detail, biar bener-bener komprehensif. Ini **Section 2.1 Buat VM di Azure** yang lebih mendalam!\n\n---\n\n### 2.1 Buat VM di Azure (Langkah Lengkap)\n\n**Kenapa VM?**\nKarena Flowise bakal jalan stabil di environment yang dedicated. Azure VM ini semacam “rumah” yang lu kelola sendiri — lu bisa atur CPU, RAM, disk space, dan keamanan sesuai kebutuhan.\n\n**Langkah-langkah lengkapnya:**\n\n#### a. Akses Portal Azure\n\n1. Buka browser dan login ke [Azure Portal](https://portal.azure.com/).\n2. Di sidebar kiri, klik **Virtual Machines**.\n\n#### b. Mulai Buat VM\n\n1. Klik **+ Create** > **Azure Virtual Machine**.\n2. Lu bakal lihat form “Create a virtual machine”.\n\n#### c. Basic Details\n\n* **Subscription**: biasanya udah default ke subscription lu.\n* **Resource Group**: pilih yang udah ada, atau klik **Create new** buat bikin resource group baru (misalnya `rg-flowise`).\n* **Virtual machine name**: nama VM lu, misalnya `test-vm-1`.\n* **Region**: pilih region yang dekat sama user. Kalau buat testing, `Southeast Asia` atau `East Asia` biasanya bagus.\n* **Availability options**: default `No infrastructure redundancy required` (oke buat testing).\n* **Image**: pilih **Ubuntu 22.04 LTS** (versi stabil dan familiar).\n* **Size**: klik **See all sizes** dan pilih yang pas. Buat testing, `B1s` udah cukup (1 vCPU, 1 GB RAM).\n* **Authentication type**:\n  * Pilih **SSH public key** biar lebih aman.\n  * **Username**: misalnya `azureuser`.\n  * **SSH public key source**: biasanya lu udah punya key di `~/.ssh/id_rsa.pub`. Copy paste ke kolom ini.\n* **Inbound port rules**:\n  * **Public inbound ports**: `Allow selected ports`.\n  * **Select inbound ports**: pilih `SSH (22)`.\n  * Nanti kita atur port lain (3000 buat Flowise, 6379 buat Redis).`\n\n#### d. Disk dan Storage\n\n* **OS disk type**: defaultnya **Standard SSD** (cukup untuk testing).\n* Kalau butuh data disk tambahan, nanti bisa attach disk lain.\n\n#### e. Networking\n\n* Azure otomatis bikin Virtual Network dan Subnet.\n* **Public IP**: biar lu bisa SSH, pastikan aktif.\n* **NIC network security group**: defaultnya bikin **Basic** rule SSH (22). Nanti lu bisa atur rule buat 3000 & 6379 manual kalau perlu.\n\n#### f. Management, Monitoring, dan lainnya\n\n* Buat testing, lu bisa biarin default.\n* Kalau buat production, pastikan:\n\n  * **Boot diagnostics**: aktif.\n  * **Auto-shutdown**: aktifin biar hemat biaya kalo lupa shutdown.\n\n#### g. Review & Create\n\n* Klik **Review + create**.\n* Azure bakal validasi. Kalau ga ada error, klik **Create**.\n\nTunggu 1–2 menit sampe VM ready.\n\n---\n\n#### h. SSH ke VM\n\n* Setelah VM aktif, liat **Public IP address** di dashboard VM.\n* Di terminal lokal lu:\n\n```bash\nssh azureuser@<public-ip>\n```\n\nGanti `<public-ip>` dengan IP VM lu. Kalau pake password, dia bakal minta password. Kalau pake SSH key, langsung connect.\n\n#### i. Atur Firewall Buat Port Flowise & Redis\n\nBy default, cuma port 22 yang kebuka. Flowise jalan di port 3000 dan Redis di 6379. Jadi:\n\n1. Balik ke Azure Portal.\n2. Masuk ke VM > **Networking**.\n3. Klik **Add inbound port rule**:\n\n   * **Source**: Any\n   * **Source port ranges**: \\*\n   * **Destination**: Any\n   * **Destination port ranges**: 3000\n   * **Protocol**: TCP\n   * **Action**: Allow\n   * **Priority**: 300 (biar ga bentrok sama rule lain).\n   * **Name**: allow-3000\n4. Ulangi buat port 6379 (Redis).\n\n---\n\n#### j. Sekarang VM lu siap\n\n* OS Ubuntu 22.04 LTS\n* Port 22 (SSH), 3000 (Flowise), 6379 (Redis) udah kebuka\n* SSH udah bisa dipake\n\nUdah. Tinggal setup environment dasar (update OS, pasang Docker, dll.) di section selanjutnya.\n\n\n### 2.2 Akses VM\n\nSetelah VM jadi, lu dapet public IP. Buka terminal lokal lu:\n\n```bash\nssh azureuser@<public-ip>\n```\n\nGanti `<public-ip>` pake IP VM yang lu buat.\n\nKalau pake password, dia minta password. Kalau SSH key, tinggal masuk aja.\n\nUdah connect? Mantap. Kita lanjut ke setup dasar.\n\n### 2.3 Update & Install Basic Tools\n\nKarena ini VM fresh, kita update dulu biar paketnya aman dan terbaru:\n\n```bash\nsudo apt update && sudo apt upgrade -y\n```\n\nInstall tools basic yang sering kepake:\n\n```bash\nsudo apt install -y git curl wget htop\n```\n\nNanti lu bisa pake `htop` buat monitor load VM.\n\n### 2.4 Pasang Docker & Docker Compose\n\nFlowise butuh Docker biar ga ribet dependensi.\n\n1. Install Docker:\n\n```bash\ncurl -fsSL https://get.docker.com -o get-docker.sh\nsudo sh get-docker.sh\n```\n\n2. Cek Docker udah jalan:\n\n```bash\nsudo systemctl status docker\n```\n\n3. Install Docker Compose (biar gampang manage multi-container):\n\n```bash\nsudo apt install -y docker-compose\n```\n\n4. Biar ga pake `sudo` terus, tambahin user ke grup Docker:\n\n```bash\nsudo usermod -aG docker $USER\n```\n\nKeluar SSH (`exit`) dan masuk lagi biar group Docker langsung aktif.\n\n---\n\nDi sini, VM lu udah siap buat deploy Flowise. Docker dan Compose udah jalan. Next, kita bakal setup Flowise bareng config dasar (pake file `.env`, `docker-compose.yml`, dll).\n\nOke, lanjut ke **Section 3: Deploy Flowise**?\n\nOke, kita lanjut ke **Section 3: Setup Environment Dasar di VM**. Ini bagian penting biar VM lu siap buat deploy Flowise dan Redis.\n\n---\n\n### 3. Setup Environment Dasar di VM\n\nBegitu lu SSH ke VM, kita langsung rapihin environment-nya supaya stabil dan ga bikin pusing ke depannya.\n\n**a. Update OS**\nPertama, update OS ke versi terbaru biar aman dan stabil:\n\n```bash\nsudo apt update && sudo apt upgrade -y\n```\n\nIni bakal ambil update security patch dan package terbaru. Tunggu sampe kelar.\n\n---\n\n**b. Install Dependency Dasar**\nFlowise butuh Docker & Docker Compose. Kita pasang dulu:\n\n1. **Install Docker:**\n\n```bash\nsudo apt install docker.io -y\n```\n\n2. **Enable dan Start Docker:**\n\n```bash\nsudo systemctl enable docker\nsudo systemctl start docker\n```\n\n3. **Cek Docker:**\n\n```bash\ndocker --version\n```\n\nHarusnya muncul versi Docker.\n\n---\n\n**c. Install Docker Compose**\nDocker Compose biasanya ga include di Ubuntu. Kita install manual:\n\n```bash\nsudo apt install docker-compose -y\n```\n\nCek versi:\n\n```bash\ndocker-compose --version\n```\n\n---\n\n**d. Tambah User ke Group Docker (opsional)**\nSupaya ga perlu `sudo` tiap kali jalanin Docker:\n\n```bash\nsudo usermod -aG docker $USER\n```\n\nKeluar dan login lagi biar groupnya kebaca:\n\n```bash\nexit\n```\n\nTerus SSH lagi ke VM.\n\n---\n\n**e. Cek Firewall (Opsional)**\nKadang firewall VM nutup port default:\n\n```bash\nsudo ufw status\n```\n\nKalau aktif dan lu mau atur rule:\n\n```bash\nsudo ufw allow 3000/tcp\nsudo ufw allow 6379/tcp\nsudo ufw reload\n```\n\n---\n\n**f. Tes Docker**\nLu bisa coba jalanin container dummy buat tes:\n\n```bash\ndocker run hello-world\n```\n\nKalau muncul “Hello from Docker!”, environment Docker lu udah beres.\n\n---\n\n**g. Siapin Direktori Project**\nLu bisa buat satu folder buat simpen semua file:\n\n```bash\nmkdir ~/myapp\ncd ~/myapp\n```\n\n---\n\n### 4. Deploy Flowise & Redis pakai Docker Compose\n\nSekarang kita udah punya environment yang siap tempur. Waktunya deploy Flowise barengan Redis pake Docker Compose.\n\n---\n\n**a. Buat File `.env`**\n\nSimpan environment variable di satu file `.env`. Contoh paling basic:\n\n```bash\ncat <<EOF > .env\nPORT=3000\nDATABASE_PATH=/root/.flowise\nSECRETKEY_PATH=/root/.flowise\nLOG_PATH=/root/.flowise/logs\nBLOB_STORAGE_PATH=/root/.flowise/storage\nJWT_AUTH_TOKEN_SECRET=secret\nJWT_REFRESH_TOKEN_SECRET=secret\nJWT_ISSUER=flowise\nJWT_AUDIENCE=flowise\nEXPRESS_SESSION_SECRET=flowise\n\nREDIS_HOST=redis\nREDIS_PORT=6379\nMODE=queue\nQUEUE_NAME=flowise-queue\nQUEUE_REDIS_EVENT_STREAM_MAX_LEN=100000\nEOF\n```\n\n---\n\n**b. Buat File `docker-compose.yml`**\n\nIni file utama yang bakal jalanin Flowise & Redis:\n\n```yaml\nversion: '3.1'\n\nservices:\n  redis:\n    image: redis:alpine\n    container_name: docker_redis_1\n    restart: always\n    ports:\n      - '6379:6379'\n\n  flowise-web:\n    image: flowiseai/flowise\n    container_name: flowise-web\n    restart: always\n    environment:\n      - PORT=${PORT}\n      - MODE=${MODE}\n      - REDIS_HOST=${REDIS_HOST}\n      - REDIS_PORT=${REDIS_PORT}\n      - QUEUE_NAME=${QUEUE_NAME}\n      - QUEUE_REDIS_EVENT_STREAM_MAX_LEN=${QUEUE_REDIS_EVENT_STREAM_MAX_LEN}\n      - DATABASE_PATH=${DATABASE_PATH}\n      - SECRETKEY_PATH=${SECRETKEY_PATH}\n      - LOG_PATH=${LOG_PATH}\n      - BLOB_STORAGE_PATH=${BLOB_STORAGE_PATH}\n      - JWT_AUTH_TOKEN_SECRET=${JWT_AUTH_TOKEN_SECRET}\n      - JWT_REFRESH_TOKEN_SECRET=${JWT_REFRESH_TOKEN_SECRET}\n      - JWT_ISSUER=${JWT_ISSUER}\n      - JWT_AUDIENCE=${JWT_AUDIENCE}\n      - EXPRESS_SESSION_SECRET=${EXPRESS_SESSION_SECRET}\n    ports:\n      - '${PORT}:${PORT}'\n    volumes:\n      - ~/.flowise:/root/.flowise\n```\n\n---\n\n**c. Jalankan Docker Compose**\n\n```bash\nsudo docker-compose --env-file .env up -d\n```\n\nDocker Compose bakal:\n\n* Download image Redis & Flowise\n* Jalanin container\n* Otomatis restart kalo VM reboot\n\n---\n\n**d. Cek Status**\n\n```bash\nsudo docker ps\n```\n\nHarusnya muncul dua container:\n\n* `docker_redis_1`\n* `flowise-web`\n\n---\n\n**e. Akses Flowise**\n\nBuka browser, ketik:\n\n```\nhttp://<IP_VM>:3000\n```\n\nHarusnya udah muncul Flowise Dashboard.\n\n---\n\n**f. Troubleshoot Kecil**\n\n* Kalo container crash:\n\n  ```bash\n  sudo docker logs flowise-web\n  ```\n* Kalo Redis error:\n\n  ```bash\n  sudo docker logs docker_redis_1\n  ```\n\n---\n\n**g. Next: Setup Worker**\nFlowise ini udah jalan, tapi dia masih single instance. Worker Redis belum di-setup. Nanti worker Redis ini yang bakal scale dan handle background job.\n\n\n\n### 5. Konfigurasi Environment\n\nOke, di tahap ini kita udah punya Flowise repo dan file-file pentingnya. Sekarang waktunya bikin file environment variable biar Flowise tau di mana dia harus nyimpen data dan konek ke Redis (kalau pakai).\n\n---\n\n#### a. Kenapa Penting?\n\nFile `.env` ini penting banget. Semua setting environment — port, database path, secret key, Redis, dll — disimpen di sini. Biar kalo lu mau deploy lagi di server lain, tinggal copy file `.env` doang. Praktis!\n\n---\n\n#### b. Bikin File `.env` Dasar\n\nLu bisa bikin file `.env` langsung di VM:\n\n```bash\nnano .env\n```\n\nTerus isiin basic config kayak gini:\n\n```env\nPORT=3000\n\n# Path default storage Flowise\nDATABASE_PATH=/root/.flowise\nSECRETKEY_PATH=/root/.flowise\nLOG_PATH=/root/.flowise/logs\nBLOB_STORAGE_PATH=/root/.flowise/storage\n\n# Basic JWT dan session secret\nJWT_AUTH_TOKEN_SECRET=secret\nJWT_REFRESH_TOKEN_SECRET=secret\nJWT_ISSUER=flowise\nJWT_AUDIENCE=flowise\nEXPRESS_SESSION_SECRET=flowise\n\n# Redis config\nREDIS_HOST=redis\nREDIS_PORT=6379\nMODE=queue\nQUEUE_NAME=flowise-queue\nQUEUE_REDIS_EVENT_STREAM_MAX_LEN=100000\n```\n\nSimpan file `.env` ini. Ini settingan yang udah cukup buat jalanin Flowise web plus Redis queue worker (opsional).\n\n---\n\n#### c. Opsi Setting (Bisa Dikosongin / Custom)\n\nKalau mau minimalis banget, lu bisa **skip** beberapa setting kayak SMTP, storage S3, atau Postgres. Flowise bisa jalanin semua data langsung di path `~/.flowise` default.\n\nTapi kalo lu mau:\n\n* Connect ke Postgres → Lu bisa tambah `DATABASE_TYPE`, `DATABASE_HOST`, `DATABASE_PORT`, dll.\n* Pakai storage S3 / GCS → Lu bisa tambah `STORAGE_TYPE`, `S3_*`, `GOOGLE_*`.\n* Aktifin monitoring (Prometheus, OpenTelemetry) → Tambah `METRICS_*` di `.env`.\n\n---\n\n#### d. Cek Kembali\n\nSebelum lu `docker-compose up -d`, pastiin file `.env` lu udah:\n✅ Path storage\n✅ JWT secret\n✅ Redis config (kalau mau pakai queue)\n✅ Port (3000 default)\n\n---\n\n#### e. Gunakan `.env` di Docker Compose\n\nPas lu jalanin Docker Compose, jangan lupa pake parameter `--env-file`:\n\n```bash\nsudo docker-compose --env-file .env up -d\n```\n\nDengan ini, Docker Compose bakal inject semua setting di `.env` ke environment container. Jadi config lu rapih dan gampang dikelola.\n\n---\n\n### 6. Jalankan Flowise Web\n\nNah, sekarang lu udah punya semua yang lu butuhin — Docker Compose, file `.env`, dan repo Flowise yang udah di-clone. Waktunya ngejalanin Flowise biar bisa lu akses lewat browser!\n\n---\n\n#### a. Jalankan Docker Compose\n\nCukup satu perintah ini, asalkan lu udah di direktori yang sama sama `docker-compose.yml`:\n\n```bash\nsudo docker-compose --env-file .env up -d\n```\n\nPenjelasannya:\n\n* `--env-file .env` → buat baca file `.env` lu.\n* `-d` → biar container jalan di background, gak ganggu terminal.\n\n---\n\n#### b. Cek Status\n\nCek container yang lagi jalan:\n\n```bash\nsudo docker ps\n```\n\nHarusnya lu bakal liat:\n\n* `flowise-web` (container Flowise)\n* `docker_redis_1` (container Redis, kalau lu setup Redis juga)\n\nKalau statusnya **Up**, artinya udah beres!\n\n---\n\n#### c. Akses Flowise di Browser\n\nSekarang, lu tinggal buka browser dan masuk ke:\n\n```\nhttp://<IP_VM>:3000\n```\n\nContoh:\n\n```\nhttp://20.212.155.7:3000\n```\n\nHarusnya lu udah liat dashboard Flowise — itu artinya **Flowise udah running!**\n\n---\n\n#### d. Apa yang Dilakuin Flowise\n\nPas Flowise Web udah jalan, dia bakal:\n\n* Buka port 3000 buat antarmuka (dashboard web).\n* Simpen semua data (flow, setting, secret) di folder `~/.flowise` (volume mapping).\n* Kalau Redis aktif dan lu udah set `MODE=queue`, dia juga siap ngoper ke worker (nanti lu setup).\n\n---\n\n#### e. Troubleshooting Singkat\n\nKalau lu gak bisa akses di browser:\n\n* Cek firewall VM (port 3000 udah kebuka belum?).\n* Cek status container pakai `sudo docker ps` (ada yang restart?).\n* Liat log container Flowise:\n\n```bash\nsudo docker logs flowise-web\n```\n\nBiasanya error log cukup jelas, kayak salah path atau conflict port.\n\n\n---\n\n### 7. (Opsional) Setup Worker\n\nWorker ini sebenernya **bukan wajib** — Flowise Web udah cukup kalau trafficnya santai. Tapi kalau lu mau:\n\n* **Load lebih berat** (banyak user / banyak flow jalan bareng).\n* **Pakai mode queue** biar lebih scalable.\n* **Pisahin job processing** biar web lebih ringan.\n\nWorker adalah jawabannya.\n\n---\n\n#### a. Apa itu Worker?\n\nSecara singkat:\n\n* **Flowise Web**: frontend dan API.\n* **Flowise Worker**: backend yang kerjain job intensif (eksekusi alur RAG, LLM, dkk).\n\nWorker **ngambil job** dari Redis, yang jadi queue. Jadi Redis **harus jalan dulu**.\n\n---\n\n#### b. Kapan Worker Ini Kepake?\n\nWorker jalan kalau di `.env` lu set:\n\n```env\nMODE=queue\n```\n\nDi Flowise Web, dia cuma ngirim job ke Redis. Worker yang bakal ambil job dan eksekusi.\n\n---\n\n#### c. Setup Docker Compose Worker\n\nBiasanya **worker Compose file** (`docker-compose.worker.yml`) beda sama `docker-compose.yml` web. Contoh file:\n\n```yaml\nversion: '3.1'\n\nservices:\n  worker:\n    image: flowiseai/flowise\n    restart: always\n    environment:\n      - MODE=queue\n      - QUEUE_NAME=flowise-queue\n      - REDIS_HOST=redis\n      - REDIS_PORT=6379\n      - WORKER_CONCURRENCY=100\n      - DATABASE_PATH=/root/.flowise\n      - SECRETKEY_PATH=/root/.flowise\n      - LOG_PATH=/root/.flowise/logs\n      - BLOB_STORAGE_PATH=/root/.flowise/storage\n    entrypoint: /bin/sh -c \"sleep 3; flowise worker\"\n    depends_on:\n      - redis\n    volumes:\n      - ~/.flowise:/root/.flowise\n\n  redis:\n    image: redis:7\n    restart: always\n```\n\nWorker ini bakal **nyambung ke Redis** (port 6379) dan siap tarik job.\n\n---\n\n#### d. Jalankan Worker\n\nKalau Redis udah jalan:\n\n```bash\nsudo docker-compose --env-file .env -f docker-compose.worker.yml up -d\n```\n\nCek worker status:\n\n```bash\nsudo docker ps\n```\n\nHarusnya container `worker` statusnya **Up**.\n\n---\n\n#### e. Kapan Worker Ini Bakal \"Aktif\"?\n\nWorker jalan terus, tapi dia **baru \"sibuk\"** kalau ada job masuk:\n\n* Flowise Web lempar job (misal deploy Flow).\n* Worker ambil job dari Redis dan eksekusi.\n\nKalau job kosong, worker standby aja.\n\n---\n\n#### f. Tips Tambahan\n\n* Pastikan `MODE=queue` di Web dan Worker sama.\n* Kalau lu pake volume mapping `~/.flowise`, Worker share data yang sama sama Web.\n* Redis **harus stabil** — worker butuh Redis buat ngambil job.\n\n### 8. Troubleshooting & Tips\n\nWalaupun setup Flowise di VM lumayan gampang, pasti ada beberapa masalah yang sering muncul. Nah, di section ini, gue kasih tips troubleshooting dan juga beberapa tools yang bisa bantu lu mantau performa container.\n\n---\n\n#### a. Container Restart Terus\n\nKalau lu lihat container **restart terus** di `docker ps` (statusnya “Restarting”), biasanya karena:\n\n* File `.env` belum lengkap atau ada yang typo.\n* Redis belum jalan (padahal Web/Worker butuh Redis).\n* Volume `~/.flowise` belum ada permission (biasanya di VM fresh, butuh `sudo chown`).\n* Port conflict: port `3000` (web) atau `6379` (Redis) udah kepake sama service lain.\n\n**Solusi:**\n\n* Cek log container:\n\n  ```bash\n  sudo docker logs flowise-web\n  ```\n* Pastikan file `.env` valid:\n\n  ```bash\n  cat .env\n  ```\n* Tes Redis udah running:\n\n  ```bash\n  sudo docker ps | grep redis\n  ```\n\n---\n\n#### b. Port Conflict\n\nKalau muncul error `port already in use` pas `docker-compose up`, itu tandanya port 3000 atau 6379 udah dipake.\n\n**Solusi:**\n\n* Cari service yang pake port itu:\n\n  ```bash\n  sudo lsof -i :3000\n  sudo lsof -i :6379\n  ```\n* Kill service yang ganggu:\n\n  ```bash\n  sudo kill -9 <pid>\n  ```\n\n---\n\n#### c. Worker Gak Jalan / Diam Aja\n\nWorker gak ngapa-ngapain?\n\n* Cek Redis:\n\n  ```bash\n  sudo docker logs docker_redis_1\n  ```\n* Pastikan `MODE=queue` di `.env` Web dan Worker **sama**.\n* Worker cuma “bangun” kalau ada job. Jadi lu coba jalanin Flow biar dia ada kerjaan.\n\n---\n\n#### d. Cara Baca Log Container\n\nPenting nih buat debugging:\n\n```bash\nsudo docker logs flowise-web\nsudo docker logs worker\n```\n\nKalau lognya terlalu panjang, bisa pakai `tail`:\n\n```bash\nsudo docker logs -f flowise-web\n```\n\n---\n\n#### e. Tools Bantu: Portainer & Docker Dashboard\n\nKalau lu mau **liat container secara visual**, cobain tools kayak:\n\n* **Portainer**: UI buat manage container, liat logs, restart, dll.\n* **Docker Dashboard** (kalau lu pake Docker Desktop).\n\nInstall Portainer:\n\n```bash\ndocker volume create portainer_data\ndocker run -d -p 9000:9000 -p 8000:8000 --name portainer \\\n    --restart=always -v /var/run/docker.sock:/var/run/docker.sock \\\n    -v portainer_data:/data portainer/portainer-ce\n```\n\nAkses di browser:\n\n```\nhttp://<VM_IP>:9000\n```\n\n---\n\n#### f. Tips Tambahan\n\n* **Backup data `.flowise`**: semua logs, DB, dan storage Flowise ada di folder ini.\n* **Auto restart**: Compose udah `restart: always`, jadi kalau VM reboot, container auto naik lagi.\n* **Scaling**: kalau Flowise makin rame, lu bisa deploy Worker di VM lain (asal Redisnya bareng).\n\n### 9. Next Step: Worker dan Beyond\n\nKalau lu udah deploy Flowise Web, biasanya yang kepikiran selanjutnya adalah:\n\n---\n\n#### a. Kapan Perlu Setup Worker?\n\nFlowise Worker itu kayak “otak tambahan” buat ngerjain job berat (kayak scraping, generate response panjang, dll.). Worker **jalanin job** yang dikasih Flowise Web.\n\n* **Kalau Flowise Web doang**: semua job jalan di Web, bisa overload.\n* **Kalau pake Worker**: job dijalanin Worker, Web lebih ringan.\n\nWorker **wajib** kalau lu:\n\n* Mau performa lebih stabil\n* Ada job yang panjang\n* Niat integrasi Flowise di production\n\n---\n\n#### b. Redis Jadi “Penghubung” Web & Worker\n\nRedis itu **queue broker** di Flowise:\n\n* Flowise Web naro job ke Redis\n* Worker ambil job dari Redis\n\nMakanya Redis wajib kalau pake Worker. Redis bisa lu deploy bareng (satu Compose) atau **cluster** (kalau mau scalable).\n\n---\n\n#### c. Opsi Lanjutan: SSL & Load Balancer\n\nKalau lu udah deploy Web & Worker, next step biasanya:\n\n* **Pasang SSL** (HTTPS) pake Nginx Proxy Manager atau Caddy.\n* **Load balancer**: kalo lu deploy banyak Worker, lu load balance biar stabil.\n\n---\n\n#### d. Opsi Auth Tambahan\n\nFlowise udah support **Basic Auth** di level dashboard.\nTapi kalo mau lebih secure, bisa:\n\n* Reverse Proxy (Nginx Proxy Manager) + Basic Auth.\n* OAuth2 / SSO pake Nginx atau external proxy.\n\n---\n\n#### e. Upgrade & Update Flowise\n\nFlowise lumayan aktif update, jadi lu juga perlu jaga:\n\n```bash\ndocker pull flowiseai/flowise\ndocker-compose down && docker-compose up -d\n```\n\nJangan lupa backup dulu `.flowise` biar data aman.\n\n---\n\n#### f. Integrasi Lain\n\nFlowise itu enak karena bisa:\n\n* Dipake bareng chatbot di WhatsApp, Discord, Slack, dll.\n* Ditaro di workflow automation (kayak n8n, Zapier).\n* Pake OpenAI atau LLM lain (Claude, Qwen, Ollama).\n","n":0.02}}},{"i":37,"$":{"0":{"v":"Setup Vm Azure Terraform","n":0.5},"1":{"v":"\n## 1. Install Terraform (TF)\n\nTerraform itu tool buat bikin infrastruktur via kode. Jadi lo bisa definisiin semuanya (VM, jaringan, IP, dll) dari satu file konfig. Ga perlu klik-klik di Azure Portal.\n\nLo bisa install Terraform via:\n\n* Brew (kalau di Mac):\n\n  ```bash\n  brew tap hashicorp/tap\n  brew install hashicorp/tap/terraform\n  ```\n* Nix (kalau lo anak Nix):\n\n  ```nix\n  home.packages = [ pkgs.terraform ];\n  ```\n\nCek versi:\n\n```bash\nterraform -v\n```\n\nPastikan versi minimal 1.x ke atas biar support syntax terbaru.\n\n---\n\n## 2. Init Project\n\nBikin folder project, misalnya `infra`, terus lo buat beberapa file utama:\n\n* `main.tf`: isi semua resource Azure.\n* `variables.tf`: semua variabel yang reusable didefinisikan di sini.\n* `terraform.tfvars`: isinya nilai-nilai variabel real-nya.\n\nContoh `variables.tf`:\n\n```hcl\nvariable \"subscription_id\" {}\nvariable \"tenant_id\" {}\nvariable \"resource_group_name\" {}\nvariable \"location\" {}\nvariable \"vm_name\" {}\nvariable \"admin_username\" {}\nvariable \"ssh_public_key\" {}\n```\n\nContoh isi `terraform.tfvars`:\n\n```hcl\nsubscription_id    = \"<ID Azure lo>\"\ntenant_id          = \"<Tenant ID Azure lo>\"\nresource_group_name = \"rg-tf-dev\"\nlocation           = \"East Asia\"\nvm_name            = \"vm-tf-test\"\nadmin_username     = \"azureuser\"\nssh_public_key     = \"ssh-ed25519 AAAA....\"\n```\n\n---\n\n## 3. Isi `main.tf`\n\nDi `main.tf`, lo akan definisiin semua resource yang dibutuhin:\n\n* Resource Group\n* Virtual Network\n* Subnet\n* Public IP\n* Network Interface\n* Network Security Group\n* VM Linux itu sendiri\n\nContoh NSG rule buat allow port 80:\n\n```hcl\nsecurity_rule {\n  name                       = \"Allow-HTTP\"\n  priority                   = 1002\n  direction                  = \"Inbound\"\n  access                     = \"Allow\"\n  protocol                   = \"Tcp\"\n  source_port_range          = \"*\"\n  destination_port_range     = \"80\"\n  source_address_prefix      = \"*\"\n  destination_address_prefix = \"*\"\n}\n```\n\nDan jangan lupa attach NSG ke NIC:\n\n```hcl\nresource \"azurerm_network_interface_security_group_association\" \"nic_nsg\" {\n  network_interface_id      = azurerm_network_interface.nic.id\n  network_security_group_id = azurerm_network_security_group.nsg.id\n}\n```\n\n---\n\n## 4. Terraform Init & Apply\n\nCommand ini buat jalanin proses provisioning:\n\n```bash\nterraform init     # download provider\nterraform plan     # ngecek perubahan apa aja\nterraform apply    # eksekusi beneran\n```\n\nKalau apply berhasil, VM akan dibuat lengkap dengan IP publik.\n\n---\n\n## 5. Provision Docker di VM\n\nSetelah VM jadi, lo bisa SSH ke dalam:\n\n```bash\nssh azureuser@<public-ip>\n```\n\nLalu, upload dan jalankan script provisioning:\n\n```bash\nscp provision.sh azureuser@<public-ip>:\nssh azureuser@<public-ip>\nsudo bash provision.sh\n```\n\nIsi `provision.sh` bisa seperti ini:\n\n```bash\n#!/bin/bash\napt update -y\napt install -y git curl unzip ufw fail2ban\ncurl -fsSL https://get.docker.com | sh\nusermod -aG docker azureuser\ncurl -L \"https://github.com/docker/compose/releases/download/v2.27.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\nchmod +x /usr/local/bin/docker-compose\nufw allow 22\nufw allow 80\nufw allow 443\nufw --force enable\n```\n\nScript ini akan pasang Docker, Docker Compose, dan nyalain firewall.\n\n---\n\n## 6. Test Docker Webserver\n\nKita bikin service web simpel pakai Nginx.\n\nContoh `Dockerfile`:\n\n```Dockerfile\nFROM nginx:alpine\nCOPY ./html /usr/share/nginx/html\n```\n\nContoh `docker-compose.yml`:\n\n```yaml\nversion: '3'\nservices:\n  web:\n    build: .\n    ports:\n      - \"80:80\"\n```\n\nIsi file `html/index.html` buat test:\n\n```html\n<h1>It works!</h1>\n<p>This page is served from inside a Docker container.</p>\n```\n\nJalankan container:\n\n```bash\ndocker compose up -d --build\n```\n\nCek di browser:\n\n```\nhttp://<public-ip>\n```\n\nKalau muncul tulisan \"It works!\", berarti sukses.\n\n---\n\n## 7. Catatan Penting\n\n* Kalau ada yang ngubah konfigurasi langsung via Azure Portal, itu **nggak sinkron sama Terraform**.\n* Saat lo jalankan `terraform apply` lagi, bisa aja konfigurasi lama dari `.tf` overwrite perubahan manual tadi.\n* Jadi, sebaiknya semua perubahan dilakukan via kode.\n\n---\n\n## Next Steps:\n\nBeberapa hal yang bisa lo lanjutin:\n\n* Pasang domain dengan DNS A record ke IP publik\n* Tambah TLS pakai Nginx proxy atau Caddy\n* Deploy app beneran kayak Flowise, FastAPI, Botpress\n* CI/CD pipeline pakai GitHub Actions buat push ke VM otomatis","n":0.047}}},{"i":38,"$":{"0":{"v":"Coding","n":1}}},{"i":39,"$":{"0":{"v":"Valid Palindrom","n":0.707},"1":{"v":"\nA phrase is a **palindrome** if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a **palindrome**, or false otherwise.\n\nExample 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\nExample 3:\n\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n \n\nConstraints:\n\n1 <= s.length <= 2 * 105\ns consists only of printable ASCII characters.\n\n## Memahami Problem\n\n### 1. Constrains\n\n- `1 <= s.length <= 2 * 10^5` lengthnya akalan sampe 200rb karakter\n- `s consists only of printable ASCII characters.` string berisi ASCII character, jadi kemungkinan akan ada special charakter.\n\nDari sini gue dapet insight kalau harus remove dulu special karakter dan spasi. agar semuanya jadi alphanumeric jadi ada angka juga.\n\n### 2. Memahami deskripsi soal\n\n- `converting all uppercase letters into lowercase` convert dulu ke lowercase\n- `removing all non-alphanumeric characters` hapus semua non-alphanumeric karakter\n- `it reads the same forward and backward` kalau dibaca dari depan dan belakan terbaca sama\n\n### 3. Memahami contoh\n\nExample 1\n\n```\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\n```\n\nsetelah dihapus semua special character dan di lowercase dan terbaca sama dari depan dan belakang, maka ini disebut palindrome\n\nExample 2\n\n```\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\n```\n\nini tidak terbaca sama dari depan dan belakang, maka ini bukan palindrome\n\nExample 3\n\n```\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n```\n\nKalau string kosong langsung aja return true\n\n## Solusi\n\n### Brute Force\n\n1. Hapus spesial karakter\n2. Ubah string jadi lower case\n3. looping agar bisa dieja dari belakang dan masukan kedalam variable  `backward` dengan type []string\n4. Join slice strings.Join(backward, \"\")\n5. Check apakah sama jika dibaca forward dan backward\n\n### Two Pointer\n\nKalau menggunakan two pointer, logikanya bisa gini\n\n1. Definisikan `left = 0` dan `right = len(s) -`\n2. Loop dengan kondisi `left < right`\n   1. Loop dengan kondisi `left < righ && s[left]`, Jika bukan alphanumeric geser kiri, `left++`\n   2. Loop dengan kondisi `left < righ && s[right]`, Jika bukan alphanumeric geser kanan, `right++`\n   3. Jika `s[left]` lowercase tidak sama dengan `s[right]` maka return false\n   4. Jika sama, geser kiri dan kanan\n3. Jika loop selesai return true","n":0.049}}},{"i":40,"$":{"0":{"v":"Code","n":1},"1":{"v":"\n## Brute Force\n\n\n```go\n\nfunc isPalindrome(s string) bool {\n\tforward := strings.ToLower(strings.ReplaceAll(cleanString(s), \" \", \"\"))\n\tvar backward []string\n\tfor right := len(forward) - 1; right >= 0; right-- {\n\t\tbackward = append(backward, fmt.Sprintf(\"%c\", forward[right]))\n\t}\n\tbackwardString := strings.Join(backward, \"\")\n\tif backwardString == forward {\n\t\treturn true\n\t}\n\treturn false\n}\n\nvar nonAlphanumericRegex = regexp.MustCompile(`[^a-zA-Z0-9 ]+`)\n\nfunc cleanString(str string) string {\n\treturn nonAlphanumericRegex.ReplaceAllString(str, \"\")\n}\n```\n\n\n## Two Pointer\n\n\n```go\nfunc isPalindrome(s string) bool {\n\tleft := 0\n\tright := len(s) - 1\n\n\tfor left < right {\n\t\tfor left < right && !isAlphanumeric(rune(s[left])) {\n\t\t\tleft++\n\t\t}\n\n\t\tfor left < right && !isAlphanumeric(rune(s[right])) {\n\t\t\tright--\n\t\t}\n\n\t\tif unicode.ToLower(rune(s[left])) != unicode.ToLower(rune(s[right])) {\n\t\t\treturn false\n\t\t}\n\n\t\tright--\n\t\tleft++\n\t}\n\treturn true\n}\n\nfunc isAlphanumeric(c rune) bool {\n\treturn ('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z') || ('0' <= c && c <= '9')\n}\n```","n":0.096}}},{"i":41,"$":{"0":{"v":"Two Sum","n":0.707},"1":{"v":"\nGiven an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`.\nYou may assume that each input would have **exactly one solution**, and you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n \nConstraints:\n\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?\n\n\n### Solusi\n\n### Brute force\n\nSoalnya mudah di mengerti, gue udah tau kalau maksudnya adalah cari index yang jika di jumlah = target. Jadi bisa ambil approach seperti ini.\n\n1. Bikin variable arr berupa array\n2. Looping `nums`\n3. Value dari index iterasi akan dikurangi oleh target lalu disimpan di variable.\n4. jika nums = [2,7,11,15], maka 9 - 2 = 7, simpan di dalam variable arr {7,}.\n5. lalu lanjut ke iterasi selanjutnya, cari apakah ada 7 didalam variable arr, jika ada ambil indexnya maka return index dalam variable arr 0 dan index iterari yaitu 1. return [0, 1]\n\n\nHasilnya [eksekusinya](https://leetcode.com/problems/two-sum/submissions/1578248970/), runtime 31ms dan Memory 5.73 MB.\n\n### Maps\n\nGolang punya hash table. Jadi bisa juga dimanfaatkan untuk menyimpan hasil dari pengurangan. logikanya\n\n1. bikin variable hash\n2. looping nums [2,7,11,15]\n3. iterasi 1: x = 0, nums[x] = 2, check apakah target - nums[x] ada didalam hash atau tidak\n4. tidak ada, masukan \"nums[x], x\" kedalam hash map, jadi [2,0]\n5. iterasi 2: x = 1,nums[x] = 7, check apakah target - nums[x] ada didalam hash atau tidak\n6. ada, target - 7 = 2. value dari 2 adalah 0\n7. return value dari hash map yaitu 0, dan x yaitu 1, jadi []int{0,1}\n\nHasil [esekusinya](https://leetcode.com/problems/two-sum/submissions/1578286649/), runtime 0ms dan memory 5.91. Ada kenaikan 3.14% memory tapi mempercepat runtime dari 31ms ke 0ms 100% improvement. Kenaikan adalah dampak dari penambahan data key value dari maps.\n\n\n\n","n":0.055}}},{"i":42,"$":{"0":{"v":"Code","n":1},"1":{"v":"\n## Brute Force\n\n```go\nfunc twoSum(nums []int, target int) []int {\n    arr := []int{}\n    for x := range nums {\n        for j := range arr {\n            if nums[x] == arr[j] {\n                return []int{j, x}\n            }\n        }\n       arr =  append(arr, target - nums[x])\n    }\n    return []int{}\n}\n```\n\n## Maps\n\n```go\nfunc twoSum(nums []int, target int) []int {\n  hash := make(map[int]int)\n  for x := range nums {\n    tt := target - nums[x]\n    if i, ok := hash[tt]; ok {\n        return []int{i, x}\n    }\n    hash[nums[x]] = x\n  }\n  return []int{}\n}\n```","n":0.111}}},{"i":43,"$":{"0":{"v":"Two Sum II - Input Array Is Sorted","n":0.354},"1":{"v":"\nLink: https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/\n\nGiven a 1-indexed array of integers numbers that is **already sorted in non-decreasing order**, find two numbers such that they add up to a specific target number. Let these two numbers be `numbers[index1]` and `numbers[index2]`where `1 <= index1 < index2 <= numbers.length`.\n\nReturn the indices of the two numbers, `index1` and `index2`, **added by one** as an integer array `[index1, index2]` of length 2.\n\nThe tests are generated such that there is *exactly one solution*. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\nExample 1:\n\n```\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n```\n\nExample 2:\n\n```\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n```\n\nExample 3:\n\n```\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n```\n\nConstraints:\n\n- 2 <= numbers.length <= 3 * 104\n- -1000 <= numbers[i] <= 1000\n- numbers is sorted in non-decreasing order.\n- -1000 <= target <= 1000\n- The tests are generated such that there is exactly one solution.\n\n\n## Solusi\n\nCaranya masih sama seperti [[til.coding.two-sum]], tapi di deskripsi ada tambahan `added by one as an integer array [index1, index2] of length 2.` Jadi pada sat return kita tambahin 1. Langsung aja ke solusi maps ya, karen sama. Jadi gini:\n\n### Maps\n\nGolang punya hash table. Jadi bisa juga dimanfaatkan untuk menyimpan hasil dari pengurangan. logikanya\n\n1. bikin variable hash\n2. looping nums [2,7,11,15]\n3. iterasi 1: x = 0, nums[x] = 2, check apakah target - nums[x] ada didalam hash atau tidak\n4. tidak ada, masukan \"nums[x], x\" kedalam hash map, jadi [2,0]\n5. iterasi 2: x = 1,nums[x] = 7, check apakah target - nums[x] ada didalam hash atau tidak\n6. ada, target - 7 = 2. value dari 2 adalah 0\n7. return value dari hash map yaitu 0, dan x yaitu 1, jadi []int{0+1,1+1}\n\nHasilnya [esekusinya](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/submissions/1578506826/). Runtime 0ms dan Memory 8.09 MB. Dicoba esekusi dengan [brute force](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/submissions/1578513843/), Runtime 312ms dan Memory 7.82 MB. \n\n### Two Pointer\n\nKarena di deskripsi ada clue **already sorted in non-decreasing order**, Ada teknik lain yang bisa digunakan, yaitu two pointer. Ini bisa menurunkan memory.\n\nDengan menggunakan 2 pointer, lo bisa menggerakan kedua index, index dari kiri dan dari kanan. \n\n```bash\nIndex:  0   1   2   3\n        ┌───┬───┬───┬───┐\nnums =  │ 1 │ 5 │ 5 │ 7 │\n        └───┴───┴───┴───┘\n         ↑           ↑\n        left        right\n```\n\nSoal two sum cocok menggunakan solusi ini. Tapi check array apakah sudah terurut atau belum kalau belum `sort` dulu aja. Logikannya gini:\n\n1. Inisiasi two pointer, `left = 1`, `right = len(nums)-1`\n2. Look sampai `left < right`. Jika kondisi sudah sampai sini, artinya semua kemungkinan sudah di check.\n   1. Jika kondisi `sum == target`, Maka ini jawaban yang kita akan return\n   2.  Jika kondisi `sum < target`, Maka kita perlu angka yang lebih besar, jadi kita geser yang kiri `left++`\n   3.  Jika kondisi `sum > target`, Maka kira perlu angka yang lebih kecil, jadi kita geser yang kanan `right--`\n\n### Dry Run\n\nnums = [2, 7, 11, 15]\ntarget = 9\n\n| Iteration | left | right | nums[left] | nums[right] | sum | Pergeseran |\n|-----------|------|-------|-----------|------------|-------|------------|\n|    1      |  0   |   3   |     2     |     15     |  17 | 17 > 9, geser kanan |\n|    2      |  0   |   2   |     2     |     11     |  15 | 15 > 9, geser kanan |\n|    3      |  0   |   1   |     2     |      7     |   9 | 9 == 9, return [left, right] |\n\n---\n\nnums = [3,2,3]\ntarget = 6\n\n| Iteration | left | right | nums[left] | nums[right] | sum | Pergeseran |\n|-----------|------|-------|-----------|------------|-----|------------|\n|    1      |  0   |   2   |     3     |      3     |   6 | 6 == 6, return [left, right] |\n\n---\n\nnums = [3,2,4]\ntarget = 6\n\n| Iteration | left | right | nums[left] | nums[right] | sum | Pergeseran |\n|-----------|------|-------|-----------|------------|-----|------------|\n|    1      |  0   |   2   |     3     |      4     |   7 | 7 > 6, geser kanan |\n|    2      |  0   |   1   |     3     |      2     |   5 | 5 < 6, geser kiri |\n|    3      |  1   |   2   |     2     |      4     |   6 | 6 == 6, return [left, right] |\n\nHasil [esekusinya](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/submissions/1578516728/), runtime di 0ms dan memory ada di 7.94 MB.","n":0.038}}},{"i":44,"$":{"0":{"v":"Code","n":1},"1":{"v":"\nPlayground: https://go.dev/play/p/V9SQqDEmpzx\n\n## Maps\n\n```go\nfunc twoSum(numbers []int, target int) []int {\n  hash := make(map[int]int)\n  for x := range numbers {\n    tt := target - nums[x]\n    if i, ok := hash[tt]; ok {\n        return []int{i+1, x+1}\n    }\n    hash[numbers[x]] = x\n  }\n  return []int{}\n}\n```\n\n\n## Two Pointer\n\n```go\nfunc twoSum(numbers []int, target int) []int {\n    left, right := 0, len(numbers)-1\n    for left < right {\n        sum := numbers[left] + numbers[right]\n        if sum == target {\n            return []int{left+1, right+1}\n        } else if sum > target {\n            right--\n        } else {\n            left++\n        }\n    }\n    return []int{}\n}\n```","n":0.107}}},{"i":45,"$":{"0":{"v":"Remove Duplicates from Sorted Array","n":0.447},"1":{"v":"\nGiven an integer array nums sorted in **non-decreasing order**, remove the duplicates [in-place(https://en.wikipedia.org/wiki/In-place_algorithm)] such that each unique element appears only **once**. The **relative order** of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\n> int[] nums = [...]; // Input array\n> int[] expectedNums = [...]; // The expected answer with correct length\n>\n> int k = removeDuplicates(nums); // Calls your implementation\n>\n> assert k == expectedNums.length;\n> for (int i = 0; i < k; i++) {\n>     assert nums[i] == expectedNums[i];\n> }\n\nIf all assertions pass, then your solution will be **accepted**.\n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n\n\n\n## Memahami problemnya\n\n### 1. Pelajari constraintnya\n\n- `1 <= nums.length <= 3 * 104` = lengthnya bisa sampai 30rb digit, artinya kalau pake brute force ini bakalan lama banget\n- `-100 <= nums[i] <= 100` = setiap angka dalam array berisi -100 sampai 100.\n- `nums is sorted in non-decreasing order`. Array sudah diurutkan dalam [non-decreasing order](https://stackoverflow.com/questions/1963474/is-a-non-decreasing-sequence-increasing) artinya urutannya terus naik, 1-2-3-4 dant tidak menurun, tapi memungkinkan duplicate 1-1-1-2-3-4-4-4.\n\n\n### 2. Cek narasi dari soalnya\n\n- Sorted in **non-decreasing order** = karena dia sudah terurut jadi bisa nih pake two pointer buat remove duplicatenya.\n- Remove the duplicates [in-place(https://en.wikipedia.org/wiki/In-place_algorithm)] = berarti gak boleh bikin array baru, tapi ubah aja array nums.\n- each unique element appears only **once** = jadi hasilnya setiap angka cuma muncul sekali\n- The **relative order** of the elements should be kept the same = pastikan urutan arraynya harus sama jangan diubah dan gak boleh di sort ulang.\n- Then return the number of unique elements in nums. =  hasilnya jumlah dari nilai uniknya (k), dan gak perlu hapus nilai (k).\n\n### 3. Check examle\n\nExample 1:\n\n```bash\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\n```\n\n- Duplikat angka 1 dihapus\n- Lalu array tetap dalam urutan yang sama\n- Outputnya jumlah element unit yaitu k = 2\n\nExample 2:\n\n```bash\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\n```\n\n- Semua yang duplikat dihapus\n- Urutan angkanya tetap sama\n- Outputnya k = 5\n- Bagian setelah k tidak dibiarkan, artinya jika di len size tetap sama\n\n\n## Solusi\n\nDari pemahaman soal kita sudah tau, bakal pake two pointer.\nKita tau data sorted kiri lebih kecil dari kanan tapi bisa sama, jadi kita akan cata perubahan yang tidak samanya saja karena kita mau cari keunikannya. jadi kalau ada array [1,1,2], kita geser terus ke kiri, jadi [1,2,2] karena jika ada perbedaan antara nums[left] != nums[right] maka nums[left] = nums[right] dan left kita tambah, jadi indexnya akan maju.\nJadi logikanya gini\n\n1. Definisikan `left=0`\n2. Looping dengan kondisi `right=1; right < len(nums); right++` \n   2.1. Jika `nums[left] != nums[right]` maka nums[left] = nums[right] dan tambahkan nlai `left++` \n3. Return left + 1","n":0.041}}},{"i":46,"$":{"0":{"v":"Code","n":1},"1":{"v":"\n## Two Pointer\n\n```go\nfunc removeDuplicates(nums []int) int {\n    left := 0\n    for right:=1; right < len(nums); right++ {\n        if nums[left] != nums[right] {\n            left++\n            nums[left] = nums[right]\n        }\n    }\n    return left + 1\n}\n```","n":0.177}}},{"i":47,"$":{"0":{"v":"Maximum Sum of Distinct Subarrays with Length K","n":0.354},"1":{"v":"\nYou are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\n\n- The length of the subarray is k, and\n- All the elements of the subarray are **distinct**.\n\nReturn the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n \n**Example 1:**\n\nInput: nums = [1,5,4,2,9,9,9], k = 3\nOutput: 15\nExplanation: The subarrays of nums with length 3 are:\n- [1,5,4] which meets the requirements and has a sum of 10.\n- [5,4,2] which meets the requirements and has a sum of 11.\n- [4,2,9] which meets the requirements and has a sum of 15.\n- [2,9,9] which does not meet the requirements because the element 9 is repeated.\n- [9,9,9] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n\n**Example 2:**\n\nInput: nums = [4,4,4], k = 3\nOutput: 0\nExplanation: The subarrays of nums with length 3 are:\n- [4,4,4] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions.\n \n\n**Constraints:**\n\n- 1 <= k <= nums.length <= 10^5\n- 1 <= nums[i] <= 10^5\n\n## Memahami soal\n\n### 1. Constraints\n\n- `1 <= k <= nums.length <= 10^5` isi dari `k` dari 1 - 100k\n- `1 <= nums[i] <= 10^5` jumlah nums bisa sampai 100k\n\nTidak ada problem yang signifikan. Bisa mulai dari brute force.\n\n### 2. Memahami clue\n\n- `sum of all the subarrays of nums` Jumlahkan array \n- `The length of the subarray is k` berdasarkan `k` \n- `All the elements of the subarray are distinct.` Semua element adalah distinct, jadi tidak ada angka yang duplicate. Artinya perlu dibersihkan dulu atau perlu di check apakah dari sub array ada angka yang sama atau tidak.\n- `Return the maximum subarray sum of all the subarrays that meet the conditions` cari maksimal sum dari subarray tersebut.\n- `A subarray is a contiguous non-empty sequence of elements within an array.` subarray tidak boleh kosong dan harus berurutan, urutannya harus sama kaya aslinya\n\n### 3. Melihat Example\n\n**1. Example 1:**\n\n> Input: nums = [1,5,4,2,9,9,9], k = 3\n> \n> Output: 15\n> \n> Explanation: The subarrays of nums with length 3 are:\n> - [1,5,4] which meets the requirements and has a sum of 10.\n> - [5,4,2] which meets the requirements and has a sum of 11.\n> - [4,2,9] which meets the requirements and has a sum of 15.\n> - [2,9,9] which does not meet the requirements because the element 9 is repeated.\n> - [9,9,9] which does not meet the requirements because the element 9 is repeated.\n> We return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n\nDari example 1,kita bisa lihat array yang mau dijumlahkan adalah 3, maka pecah dari array dan ambil per 3 element. Sampai disini kepikiran buat di slice, kaya gini misalnya `arr[1:3]`.\nDi pecah menjadi 3 sub array, lalu cek apakah dalam array ada nomor yang sama atau tidak.\nJika ada maka skip.\n\nExample 2:\n\n> Input: nums = [4,4,4], k = 3\n> Output: 0\n> Explanation: The subarrays of nums with length 3 are:\n> - [4,4,4] which does not meet the requirements because the element 4 is repeated.\n> We return 0 because no subarrays meet the conditions.\n\nDari sini kita bisa tau, kalau ada angka yang sama langsung return 0 aja.\n\n\n## Solusi\n\n### Brute Force\n\nKita bagi jadi 2 iterasi\n\n1. Prepare SubArray\n   1. Definisikan dulu `[][]int{}`\n   2. Looping nums dengan kondisi `for i:=0; i < len(nums); i++`\n   3. Masukan angka dalam nums sesuai dengan `k` jadi `subarray = append(subarray, nums[i:k+i])`\n2. Sum Subarray dengan kondisi\n   1. Looping SubArray jika ada angka yang sama, maka skip\n   2. Jika tidak sama, maka hitung.\n\nPercobaan peratama gagal nih, kena time limit di leetcode. Karena ngecek satu satu. Kita pelajari teknik baru, Yaitu sliding window\n\n\n### Sliding Window\n\n1. Jika `k` lebih besar dari array `n`, langsung return `0`\n2. Inisialisasi Variable:\n   1. `maxSum`: ini akan digunakan untuk menyimpan nilai maksimum dari semua subarray valid dengan tipe (int64)\n   2. `currentSum`: Menyimpan jumlah elemen dalam window saat ini dengan tipe (int64)\n   3. `left`: Pointer kiri /batas awal window dengan tipe (int)\n   4. `seen`: Digunakan untuk tracking element unik dengan tipe `make(map[int]bool)`\n3. Sliding window dengan Two Pounter\n   1. Check Duplikat\n      1. Selama elemen `nums[right]` sudah ada dalam set\n         1. Buang elemen paling kiri nums[left] dari window\n         2. Kurangi `currentSum` dengan nilai `nums[left]`\n         3. Geser `left` pointer ke kanan `left++`\n   2. Tambahin elemen ke window\n      1. Masukin `nums[right]` ke dalam set\n      2. Tambahin `nums[right]` ke currentSum\n   3. Check Panjang Window\n      1. Jika panjang window sama dengan `k`\n         1. Update `maxSum` jika `currentSum` lebih besar\n         2. Buang elemen paling kiri dengan elemen `nums[left]`\n         3. Kurangi `sum` dengan elemen `nums[left]`\n4. Return `maxSum`","n":0.036}}},{"i":48,"$":{"0":{"v":"Coding","n":1},"1":{"v":"\n## Percobaan Gagal\n\n\n```go\n// You can edit this code!\n// Click here and start typing.\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(maximumSubarraySum([]int{9, 9, 9, 1, 2, 3}, 3))\n\t// fmt.Println(isDuplicate([]int{2, 9, 9}))\n}\n\nvar subarray = [][]int{}\n\nfunc maximumSubarraySum(nums []int, k int) int64 {\n\tfor x := range nums {\n\t\tsub := k + x\n\t\tif sub <= len(nums) {\n\t\t\t// fmt.Println(x, k+x, nums[x:k+x])\n\t\t\tsubarray = append(subarray, nums[x:k+x])\n\t\t}\n\t}\n\n\tsums := []int{}\n\tfor _, subs := range subarray {\n\n\t\t// fmt.Println(subs, isDuplicate(subs))\n\t\tif isDuplicate(subs) {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult := 0\n\t\tfor i := 0; i < len(subs); i++ {\n\t\t\tresult += subs[i]\n\t\t}\n\t\tsums = append(sums, result)\n\t\tfmt.Println(sums, result)\n\t}\n\n\tmax := 0\n\tfor _, v := range sums {\n\t\tif max < v {\n\t\t\tmax = v\n\t\t}\n\t}\n\n\treturn int64(max)\n}\n\nfunc isDuplicate(subs []int) bool {\n\ttemp := make(map[int]int)\n\tfor _, v := range subs {\n\t\t_, ok := temp[v]\n\t\tif ok {\n\t\t\treturn true\n\t\t}\n\t\ttemp[v] = 0\n\t}\n\treturn false\n}\n\n\n```\n\n## Fixed Pake sliding window\n\n```go\nfunc maximumSubarraySum(nums []int, k int) int64 {\n\tn := len(nums)\n\tif n < k {\n\t\treturn 0\n\t}\n\n\tmax := 0\n\tcurrentSum := 0\n\tleft := 0\n\tseen := make(map[int]bool)\n\n\tfor right := 0; right < n; right++ {\n\n\t\tfor seen[nums[right]] {\n\t\t\tseen[nums[left]] = false\n\t\t\tcurrentSum -= nums[left]\n\t\t\tleft++\n\t\t}\n\n\t\tseen[nums[right]] = true\n\t\tcurrentSum += nums[right]\n\n\t\tif right-left+1 == k {\n\t\t\tif currentSum > max {\n\t\t\t\tmax = currentSum\n\t\t\t}\n\n\t\t\tseen[nums[left]] = false\n\t\t\tcurrentSum -= nums[left]\n\t\t\tleft++\n\t\t}\n\t}\n\n\treturn int64(max)\n}\n```","n":0.075}}},{"i":49,"$":{"0":{"v":"Technique","n":1}}},{"i":50,"$":{"0":{"v":"Sliding Window","n":0.707},"1":{"v":"\nApa itu sliding window. Ini adalah teknik algoritma yang digunakan untuk mengjitung sesuatu secara berkelanjutan pada subarray atau substring yang berukuran tetap atau dinamis dalam sebuah array atau string.\n\nPake gambar biar muda bayanginnya. Bagaimana menjumlahkan setiap 3 angka dari subarray. Teukan jumlah paling besarnya.\n\n![alt text](assets/til.coding.1-technique.sliding-window/image.png)\n\nBerdasarkan gambar di atas, Logikanya berarti gimana caranya bisa jumlahin angka\n\n- 1, 2, 6 = 9\n- 2, 6, 2 = 10\n- 6, 2, 4 = 12\n- 2, 4, 1 = 7\n\nJadi logikannya gini\n\n\n```go\n\nfunc findMax(arr []int, k int) int {\n\n\t// Mengambil panjang array\n\tn := len(arr)\n\n\t// Cek apakah panjang array kurang dari k\n\tif n < k {\n\t\treturn 0\n\t}\n\n\tsum := 0\n\n\t// Hitung jumlah awal dari subarray pertama dengan panjang k\n\tfor i := 0; i < k; i++ {\n\t\tsum += arr[i]\n        // Debugging\n\t\tfmt.Printf(\"Sum iterasi %v: Tambah: %v, Sum Sekarang: %v \\n\", i, arr[i], sum)\n\t}\n\n\t// Set nilai maksimum sebagai sum pertama\n\tmax := sum\n\n\t// Geser jendela ke kanan satu per satu\n\tfor i := k; i < n; i++ {\n\t\t// Kurangi elemen paling kiri dari jendela sebelumnya dan tambah elemen baru di kanan\n\t\tsum = sum - arr[i-k] + arr[i]\n\n\t\t// Debugging: Cetak elemen yang keluar dan masuk serta jumlah saat ini\n\t\tfmt.Println(\"Buang:\", arr[i-k], \"Tambah:\", arr[i], \"Sum Sekarang:\", sum)\n\n\t\t// Perbarui max jika jumlah saat ini lebih besar\n\t\tif max < sum {\n\t\t\tmax = sum\n\t\t}\n\t}\n\n\t// Kembalikan jumlah maksimum yang ditemukan\n\treturn max\n}\n\n```\n\n## Referensi\n\n- https://www.geeksforgeeks.org/window-sliding-technique/","n":0.068}}},{"i":51,"$":{"0":{"v":"Golang","n":1}}},{"i":52,"$":{"0":{"v":"Bagaimana instrumentasi golang dengan elastic APM","n":0.408},"1":{"v":"\n\nElastic APM (Application Performance Monitoring) dapat membantu kita dalam hal visibility distributed workload.\nUntuk mendapatkan insight kita haru membuat instrumentasi pada aplikasi kita.\n\n## Membuat webrequest\n\nElastic APM Go Agent memiliki API \"tracing\" untuk menerima request ke server.\nSecara default APM akan mengirimkan data ke http://localhost:8200. \nJika kita menggunakan APM Server selain di localhost dan melakukan load environment variable pada aplikasi.\nMaka khusus untuk variable yang terkait APM sebaiknya di init ketika running, bukan diaplikasi karena ada issue ini [apm-agent-go #618](https://github.com/elastic/apm-agent-go/issues/618).\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n`\n\t\"github.com/go-chi/chi/v5\"\n\t\"github.com/go-chi/chi/v5/middleware\"\n)\n\nfunc hello(w http.ResponseWriter, r *http.Request) {\n\tw.Write([]byte(\"welcome\"))\n}\n\nfunc main() {\n\tr := chi.NewRouter()\n\tr.Use(middleware.Logger)\n\tr.Get(\"/\", hello)\n\thttp.ListenAndServe(\":3000\", r)\n}\n```\n\n## Setup Kibana dan APM\n\n### Local\n\nGw asummsikan semua sudah menggunakan docker, sehingga tinggal running dengan docker compose\n\n```Dockerfile\nversion: '3.7'\n\nservices:\n\n  elasticsearch:\n    image: docker.elastic.co/elasticsearch/elasticsearch:7.16.3\n    environment:\n      - bootstrap.memory_lock=true\n      - cluster.name=docker-cluster\n      - cluster.routing.allocation.disk.threshold_enabled=false\n      - discovery.type=single-node\n      - ES_JAVA_OPTS=-XX:UseAVX=2 -Xms1g -Xmx1g\n    ulimits:\n      memlock:\n        hard: -1\n        soft: -1\n    volumes:\n      - elasticsearch:/usr/share/elasticsearch/data\n    ports:\n      - 9200:9200\n    healthcheck:\n      interval: 20s\n      retries: 10\n      test: curl -s http://localhost:9200/_cluster/health | grep -vq '\"status\":\"red\"'\n\n  kibana:\n    image: docker.elastic.co/kibana/kibana:7.16.3\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n    environment:\n      ELASTICSEARCH_URL: http://elasticsearch:9200\n      ELASTICSEARCH_HOSTS: http://elasticsearch:9200\n    ports:\n      - 5601:5601\n    healthcheck:\n      interval: 10s\n      retries: 20\n      test: curl --write-out 'HTTP %{http_code}' --fail --silent --output /dev/null http://localhost:5601/api/status\n  \n  apm-server:\n    image: docker.elastic.co/apm/apm-server:7.16.3\n    depends_on:\n      elasticsearch:\n        condition: service_healthy\n      kibana:\n        condition: service_healthy\n    cap_add: [\"CHOWN\", \"DAC_OVERRIDE\", \"SETGID\", \"SETUID\"]\n    cap_drop: [\"ALL\"]\n    ports:\n    - 8200:8200\n    command: >\n       apm-server -e\n         -E apm-server.rum.enabled=true\n         -E setup.kibana.host=kibana:5601\n         -E setup.template.settings.index.number_of_replicas=0\n         -E apm-server.kibana.enabled=true\n         -E apm-server.kibana.host=kibana:5601\n         -E output.elasticsearch.hosts=[\"elasticsearch:9200\"]\n    healthcheck:\n      interval: 10s\n      retries: 12\n      test: curl --write-out 'HTTP %{http_code}' --fail --silent --output /dev/null http://localhost:8200/\nvolumes:\n\telasticsearch:\n\t\n```\n\n### Trial Elastic Cloud \n\nKalau gak mamu ribet, bisa cobain trial dari [elastic cloud](https://www.elastic.co/cloud/). Kita akan dapat trial selama 14 hari untuk melakukan explorasi fitur firur di APM. Setupnya cukup mudah tinggal klik-klik aja.\nSetelah itu masuk ke menu APM, lalu kebagian agent untuk mendapatkan config yang seharusnya.\n\nKita membutuhkan data environtment variable untuk aplikasi.\n\n```bash\n# Initialize using environment variables:\n\n# Set the service name. Allowed characters: # a-z, A-Z, 0-9, -, _, and space.\n# If ELASTIC_APM_SERVICE_NAME is not specified, the executable name will be used.\nexport ELASTIC_APM_SERVICE_NAME=\n\n# Set custom APM Server URL (default: http://localhost:8200)\nexport ELASTIC_APM_SERVER_URL=https://7ccb1cfa41f5426ba7f29ee7123e8f4c.apm.us-central1.gcp.cloud.es.io:443\n\n# Use if APM Server requires a secret token\nexport ELASTIC_APM_SECRET_TOKEN=0aaRb0gVrRkaSQdkdR\n\n# Set the service environment\nexport ELASTIC_APM_ENVIRONMENT=\n```\n\n## Instrumenting application\n\nModifikasi webserver yang kita buat sebelumnya, dengan menambahkan `apmhttp.Wrap(r)`\n\n```go\npackage main\n\nimport (\n\t\"net/http\"\n`\t...\n\n\tapmchi \"go.elastic.co/apm/module/apmchiv5\"\n\t\"go.elastic.co/apm/module/apmhttp\"\n)\n\n...\n\nfunc main() {\n\tr := chi.NewRouter()\n\tr.Use(apmchi.Middleware())\n\t...\n\thttp.ListenAndServe(\":3000\", apmhttp.Wrap(r))\n}\n```\n\napmchi adalah middleware yang isinya pembuatan instrument untuk APM.\nbukan hanya chi, ada beberapa library lain yang disupport secara resmi.\nbisa dilihat disini [https://github.com/elastic/apm-agent-go/tree/main/module](https://github.com/elastic/apm-agent-go/tree/main/module) dan dokumentasinya di [Built-in instrumentation modules](https://www.elastic.co/guide/en/apm/agent/go/master/builtin-modules.html).\n\n\n","n":0.051}}},{"i":53,"$":{"0":{"v":"Notes","n":1},"1":{"v":"\n## Dump notes\n\n### Web APIs\n\n- Metadata\n  - Referensi metadata pada webapis\n    - [https://opensource.zalando.com/restful-api-guidelines/#](https://opensource.zalando.com/restful-api-guidelines/#)\n      - MUST contain API meta information [218]\n      - MUST use semantic versioning [116]\n      - MUST provide API identifiers [215]\n      - MUST provide API audience [219]\n      - MUST/SHOULD use functional naming schema [223]\n      - MUST follow naming convention for hostnames [224]\n  - [Nobody understands REST or HTTP](https://steveklabnik.com/writing/nobody-understands-rest-or-http)\n  - [Metadata with stripe-go](https://www.youtube.com/watch?v=qeCDxIfneww&feature=emb_title)\n  \n- Idempotency\n  - [https://openbanking.atlassian.net/wiki/spaces/DZ/pages/5786479/Payment+Initiation+API+Specification+-+v1.1.0#PaymentInitiationAPISpecification-v1.1.0-Idempotency.1](https://openbanking.atlassian.net/wiki/spaces/DZ/pages/5786479/Payment+Initiation+API+Specification+-+v1.1.0#PaymentInitiationAPISpecification-v1.1.0-Idempotency.1)\n  - [https://www.payway.com.au/docs/rest.html#avoiding-duplicate-posts](https://www.payway.com.au/docs/rest.html#avoiding-duplicate-posts)\n  - [https://gocardless.com/blog/idempotency-keys/](https://gocardless.com/blog/idempotency-keys/)\n  - [https://stripe.com/docs/api/idempotent_requests](https://stripe.com/docs/api/idempotent_requests)\n\n- Internazionale\n  - Casdoor i18n\n\n### Devcontainer\n\n- [Developing inside a Container](https://code.visualstudio.com/docs/remote/containers)\n\n### Nix\n\n- [https://github.com/kclejeune/system](https://github.com/kclejeune/system)\n\n### Datadog\n\n- [2021 - Datadog Cloud Monitoring Quick Start Guide](https://learning.oreilly.com/library/view/datadog-cloud-monitoring/9781800568730/)\n- [2019 - Building a real-time metrics database for trillions of points per day - Joel Barciauskas (Datadog)](https://learning.oreilly.com/videos/oreilly-software-architecture/0636920333777/0636920333777-video329424/)\n\n### API Management\n\n- API Gateway\n  - KrakenD\n  - Kong\n  - Tyk\n\n- API Evolution\n  - [API Evolution without Versioning with Brandon Byars](https://www.infoq.com/podcasts/api-evolution-without-versioning)\n    - [mountebank](http://www.mbtest.org/)\n\n### Identity & Access Management\n\n- All About JWT\n  - [Symmetric vs Asymmetric JWTs](https://medium.com/@swayamraina/symmetric-vs-asymmetric-jwts-bd5d1a9567f6)\n  - [The Hard Parts of JWT Security Nobody Talks About](https://www.pingidentity.com/en/resources/blog/post/jwt-security-nobody-talks-about.html)\n\n- Existing tools\n  - [Keycloak](https://www.keycloak.org/)\n  - [Casdoor](https://github.com/casdoor/casdoor)\n\nReferensi:\n\n- [https://github.com/kdeldycke/awesome-iam](https://github.com/kdeldycke/awesome-iam)\n\n### Frontend Development\n\n#### Web\n\n- React\n- Vue\n\n#### Mobile\n\n- React Native\n- Kotlin\n\n### Software Architechture\n\n#### Diagraming\n\n- [https://c4model.com/](https://c4model.com/)\n- [The C4 Model for Software Architecture](https://www.infoq.com/articles/C4-architecture-model/)\n- [Automated Software Architecture Visualization & Emergent Understanding](https://esilva.net/articles/automated-software-architecture-visualization)\n  \n### Golang\n\n- Error Handling\n  - [Error Flags](https://npf.io/2021/04/errorflags/)\n  - [Error handling in Go HTTP applications](https://www.joeshaw.org/error-handling-in-go-http-applications/)\n\n- Memory Profiling\n  - untuk gin [https://github.com/gin-contrib/pprof](https://github.com/gin-contrib/pprof)\n  - ambil data heap\n    - curl http://localhost:8787/debug/pprof/heap > heap.6.pprof\n    - go tool pprof heap.pprof \n  \n### Continous Profiling\n\n- pyroscope\n  - belum bisa melakukan profiling memory\n\n### Observability\n\n[[notes.observability]]\n\n- [Observability-driven development with Go and Tracetest](https://tracetest.io/blog/observability-driven-development-with-go-and-tracetest) \n- [Why metrics, logs, and traces aren’t enough](https://www.elastic.co/blog/observability-profiling-metrics-logs-traces)\n- [Grafana Docs](https://grafana.com/docs/grafana/latest/)\n\n","n":0.063}}},{"i":54,"$":{"0":{"v":"Software Architechture","n":0.707}}},{"i":55,"$":{"0":{"v":"Software Architechture Tradeoff","n":0.577},"1":{"v":"\nLink:\n\n- [Software Architecture Superstream: Software Architecture Trade-Offs](https://learning.oreilly.com/live-events/software-architecture-superstream-software-architecture-trade-offs/0636920083581/0636920083579/)\n- [Fundamentals of Software Architecture](https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447/)\n\n## Law of Software Architechture\n\n> Everything in software architecture is a trade-off.\n>\n>                - First Law of Software Architecture\n\nGak ada yang disemua lini itu bagus. Setiap keputusan harus mempertimbangkan banyak faktor yang saling berlawanan.\n\n>If an architect thinks they have discovered something that isn’t a trade-off, more likely they just haven’t identified the trade-off yet.\n\nArsitekture lebih luas dari sekedar kombinasi struktural.\n\n> Why is more important than how.\n\nSebagai Architect kita harus fokus kepada **WHY** dibandingkan dengan **HOW**.\nApa alasan kenapa kita perlu banget lalu baru bicara HOW. Mungkin seorang arsitek bisa memahami bagaimana sistem yang ada diimplementasikan dari segi architechture, tapi tidak tau kenapa keputusan itu diambil. Maka dari itu pentingnya membuat ADR untuk mencatat kenapa hal itu diputuskan.\n\n## Analyzing Architechture Tradeoff\n\n![software architechture tradeoff](assets/1-software-architechture-tradeoff.png)\n\nJika kamu diminta oleh tim bisnis untuk membantu mewujudkan goalnya yaitu \"kita perlu cepat **time to market**\" maka yang perlu kamu lakukan adalah mentransform \"Time to Market\" ke dalam Architechture characteristing ada 3 karakteristik utama yaitu Maintainability, Testatility, Deployability.\n\n- Maintainability adalah kemampuan dimana lo bisa dengan mudah menemukan lokasi code dan menggantinya. the ability to find and locate and change our code\n- Testability adalah  ease of but the completeness of testing\n- Deployability adalah which is about the frequency of deployment\n\nSetelah mendapatkan karakteristiknya maka selanjutkan kita analisa trade-offnya antara performance vs maintainability.\n\nLalu bagaimana lo memilihnya? ya balik lagi ke architechture karakteristik dan balik lagi ke bisnis apa yang lebih penting untuk saat ini.\n\n## Modern tradeoff analysis\n\n![modern tradeoff analisys](assets/2-software-architechture-tradeoff-modern-tradeoff-analysis.png)\n\nTipsnya adalah dengan membuat perbandingan dengan menggunakan scorecard. Misalnya lo gak tau nih gimana cara kita tau lebih bagus mana membuat shared library atau shared service?\n\n![trader of modern analysys](assets/3-software-architechture-traderoff-modern-analysis.png)  \n\nKriterianya adalah\n\n- Heterogeneous code: Kriteria ini mengukur tingkat keragaman kode yang digunakan dalam arsitektur. Arsitektur yang memiliki kode yang lebih homogen akan dianggap lebih baik daripada arsitektur yang memiliki kode yang beragam.\n\n- High code volatility: Kriteria ini mengukur tingkat perubahan kode yang terjadi dalam arsitektur. Arsitektur yang memiliki tingkat perubahan kode yang rendah akan dianggap lebih baik daripada arsitektur yang memiliki tingkat perubahan kode yang tinggi.\n\n- Ability to version changes: Kriteria ini mengukur kemampuan arsitektur untuk mengelola perubahan kode dalam versi yang berbeda. Arsitektur yang memiliki kemampuan yang baik dalam hal ini akan dianggap lebih baik daripada arsitektur yang kurang baik dalam hal ini.\n\n- Overall change risk: Kriteria ini mengukur risiko perubahan keseluruhan yang terjadi dalam arsitektur. Arsitektur yang memiliki risiko perubahan yang rendah akan dianggap lebih baik daripada arsitektur yang memiliki risiko perubahan yang tinggi.\n\n- Performance: Kriteria ini mengukur tingkat kinerja arsitektur. Arsitektur yang memiliki kinerja yang baik akan dianggap lebih baik daripada arsitektur yang kinerjanya kurang baik.\n\n- Fault tolerance: Kriteria ini mengukur tingkat toleransi arsitektur terhadap kesalahan. Arsitektur yang memiliki tingkat toleransi yang tinggi akan dianggap lebih baik daripada arsitektur yang memiliki tingkat toleransi yang rendah.\n\n- Scalability: Kriteria ini mengukur tingkat skalabilitas arsitektur. Arsitektur yang dapat di skalakan dengan mudah akan dianggap lebih baik daripada arsitektur yang kurang dapat di skalakan.- Heterogeneous code apakah compatible dengan semua bahasa pemrograman?\n","n":0.045}}},{"i":56,"$":{"0":{"v":"C4","n":1},"1":{"v":"<!-- markdownlint-disable no-missing-space-atx -->\n#software-architechture\n#diagram\n<!-- markdownlint-disable no-missing-space-atx -->\n\nC4 Diagram terdiri dari 4 tahap\n\n1. Context\n2. Contaners\n3. Component\n4. Code\n\nYang akan digambar hanya 1-3 saja, sedangkan code itu adalah code yang akan kita tulis. ref: [simon tweet](https://twitter.com/simonbrown/status/1580504505086795778)\nContext menggambarkan `Big Picture` atau bagaimana user akan menggunakan sistem yang sedang kita bangun.\n\n## C4 on VSCode with PlantUML extension\n\nSalah satu tools untuk mempermudah membuat diagram salah satunya dengan vscode dan plugin PlantUML\n\n![plantuml extension](assets/C4-plantuml-extension.png)\n\nJadi si plantuml ini dapat menterjemahkan code atau notasi menjadi gambar menggunakan plantuml server.\n\nCara setupnya cukup mudah, kita membutuhkan plantuml server yang bisa di run menggunakan docker\n\n```bash\ndocker run -d -p 3025:8080 plantuml/plantuml-server:jetty\ndocker run -d -p 3025:8080 plantuml/plantuml-server:tomcat\n```\n\nLalu sematkan link server di settings vscode\n\n![config plantuml vscode](assets/C4-config-plantuml-vscode.png)\n\nSetelah itu untuk menggunakan C4 kita butuh tambahan annotation yang bisa kita gunakan dari [https://github.com/plantuml-stdlib/C4-PlantUML](https://github.com/plantuml-stdlib/C4-PlantUML)\n\nkita coba dengan membuat file context.puml\n\n```bash\n@startuml Basic Sample\n!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Container.puml\n\nPerson(admin, \"Administrator\")\nSystem_Boundary(c1, \"Sample System\") {\n    Container(web_app, \"Web Application\", \"C#, ASP.NET Core 2.1 MVC\", \"Allows users to compare multiple Twitter timelines\")\n}\nSystem(twitter, \"Twitter\")\n\nRel(admin, web_app, \"Uses\", \"HTTPS\")\nRel(web_app, twitter, \"Gets tweets from\", \"HTTPS\")\n@enduml\n```\n\nlalu kita render dan hasilnya\n\n![plantuml vscode preview](assets/C4-plantuml-vscode-preview.png)\n","n":0.078}}},{"i":57,"$":{"0":{"v":"Prompt Engineering","n":0.707}}},{"i":58,"$":{"0":{"v":"XML vs JSON dalam AI Coding Tools: Analisis Mendalam Prompt Engineering","n":0.302},"1":{"v":"\n## Pendahuluan\n\nDiskusi ini bermula dari pertanyaan tentang sistem XML tags yang digunakan oleh Dyad untuk structured output dalam AI chatbots. Awalnya terlihat seperti pendekatan yang \"unik\" atau \"tidak mengikuti standar industri\", namun penelitian mendalam mengungkap landscape yang jauh lebih kompleks.\n\n## Temuan Utama: Tiga Pendekatan Utama\n\n### 1. Anthropic/Claude Ecosystem: XML Tags Dominan\n\n**Sumber Resmi:**\n- [Anthropic Claude Documentation: Use XML Tags](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)\n- [AWS Blog: Claude 3 Prompt Engineering](https://aws.amazon.com/blogs/machine-learning/prompt-engineering-techniques-and-best-practices-learn-by-doing-with-anthropics-claude-3-on-amazon-bedrock/)\n\n**Mengapa XML?**\n> \"Claude has been fine-tuned to pay special attention to XML tags. You can take advantage of this characteristic to clearly separate sections of your prompt.\"\n\n**Best Practices Claude:**\n- `<thinking>` untuk chain-of-thought reasoning\n- `<answer>` untuk final responses\n- `<context>` untuk background data\n- `<instructions>` untuk task descriptions\n\n### 2. OpenAI Ecosystem: JSON Schema + XML Formatting\n\n**Sumber Resmi:**\n- [OpenAI Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n- [OpenAI Prompt Engineering Guide](https://platform.openai.com/docs/guides/prompt-engineering)\n\n**Pendekatan Hybrid:**\n- **JSON Schema** untuk tool calling dan structured outputs\n- **XML tags** sebagai supplementary formatting technique\n- **Markdown** untuk general formatting\n\n### 3. Vercel AI SDK: JSON Schema Fokus\n\n**Sumber Resmi:**\n- [Vercel AI SDK Documentation](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling)\n- [Vercel AI Zod Integration](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling#tool-schemas-with-zod)\n\n**Pendekatan:**\n- Zod schemas untuk type-safe AI responses\n- JSON Schema untuk tool validation\n- Minimal XML usage\n\n## Analisis Tools Coding Agent\n\n### Dyad: XML Tags untuk Tool Calling\n\n**Implementasi:**\n```xml\n<dyad-write file=\"src/Button.tsx\">\n  // React component code\n</dyad-write>\n\n<dyad-execute command=\"npm install react-router-dom\" />\n```\n\n**Alasan Memilih XML:**\n- **Streaming compatibility**: Incremental parsing selama AI response\n- **Real-time UI feedback**: Complex operations dengan multiple steps\n- **Claude-based**: Mengikuti Anthropic's best practices\n\n### Bolt.diy: XML Tags untuk Development Workflow\n\n**Implementasi:**\n```xml\n<boltArtifact id=\"create-app\" title=\"Create React App\">\n  <boltAction type=\"shell\">npm create vite@latest my-app</boltAction>\n  <boltAction type=\"file\" filePath=\"package.json\">...</boltAction>\n</boltArtifact>\n```\n\n**Temuan:** Bolt.diy juga menggunakan XML tags yang sama seperti Dyad, menunjukkan pola yang lebih luas dalam AI coding tools.\n\n### AIML: Historical Precedent untuk XML dalam AI\n\n**Sumber:** [Wikipedia: Artificial Intelligence Markup Language](https://en.wikipedia.org/wiki/Artificial_Intelligence_Markup_Language)\n\n**Fakta Penting:**\n- Dikembangkan oleh Dr. Richard Wallace (1995-2002)\n- XML dialect khusus untuk chatbot\n- A.L.I.C.E. memenangkan Loebner Prize 3x menggunakan AIML\n- Masih aktif di Pandorabots dengan 200,000+ bots\n\n## Perbandingan XML vs JSON Approaches\n\n| Aspek | XML Approach (Claude/Dyad) | JSON Schema (OpenAI/Vercel) |\n|-------|---------------------------|-----------------------------|\n| **Parsing** | Incremental/streaming-friendly | Requires complete structures |\n| **Complexity** | Supports nested hierarchies | Type-safe validation |\n| **Tool Calling** | Custom XML tags | Standardized schemas |\n| **Ecosystem** | Anthropic-focused tools | Industry-wide adoption |\n| **Real-time UI** | Excellent for live updates | Less suitable for streaming |\n| **Validation** | Manual parsing | Built-in schema validation |\n\n## Mengapa XML untuk Coding Tools?\n\n### 1. Streaming AI Responses\n```xml\n<dyad-write file=\"Button.tsx\">\n  <button>Click me</button>  <!-- Partial content -->\n</dyad-write>\n<!-- Can be parsed incrementally -->\n```\n\nvs JSON:\n```json\n{\n  \"tool\": \"write_file\",\n  \"file\": \"Button.tsx\",\n  \"content\": \"<button>Click me</button>\"  // Must be complete\n}\n```\n\n### 2. Complex Multi-step Operations\nXML memungkinkan nesting dan hierarchical structures untuk operations yang kompleks:\n\n```xml\n<dyad-execute command=\"npm install\">\n  <dependency>react-router-dom</dependency>\n  <post-install>\n    <dyad-write file=\"App.tsx\">import Router...</dyad-write>\n  </post-install>\n</dyad-execute>\n```\n\n### 3. Real-time UI Feedback\n- XML tags dapat diparse secara bertahap\n- UI dapat update secara real-time saat AI men-stream response\n- Cocok untuk interactive development environments\n\n## Kesimpulan: Landscape yang Kompleks\n\n### Tidak Ada \"Standar Tunggal\"\n\n**Sebelumnya:** \"Mengapa Dyad menggunakan XML? Bukankah JSON lebih standard?\"\n\n**Sekarang:** Ternyata ada **tiga ecosystem berbeda** dengan pendekatan masing-masing:\n\n1. **Anthropic/Claude**: XML tags sebagai first-class citizen\n2. **OpenAI**: JSON Schema untuk tool calling, XML sebagai formatting aid\n3. **Vercel**: JSON Schema dengan Zod untuk type safety\n\n### Dyad's Choice: Strategically Sound\n\nDyad's XML approach bukan \"unik\" atau \"tidak mengikuti standar\" - tapi **mengikuti best practices dari Anthropic** untuk Claude-based applications. Pilihan ini optimal untuk:\n\n- Streaming AI responses\n- Real-time development feedback\n- Complex multi-step operations\n- Interactive coding environments\n\n## Simulasi Lengkap: Dari User Request sampai Code Generation\n\n### Scenario: User Minta \"Buat web todo app dengan React\"\n\n### Step 1: User Input & Initial Processing\n```\nUser: \"Buat web todo app dengan React yang bisa add, edit, delete todo\"\n```\n\n**Dyad's System Prompt** (berdasarkan Claude best practices):\n```xml\n<role> You are Dyad, an AI editor that creates and modifies web applications. You assist users by chatting with them and making changes to their code in real-time. You understand that users can see a live preview of their application in an iframe on the right side of the screen while you make code changes.\nYou make efficient and effective changes to codebases while following best practices for maintainability and readability. You take pride in keeping things simple and elegant. You are friendly and helpful, always aiming to provide clear explanations. </role>\n\n# App Preview / Commands\n\nDo *not* tell the user to run shell commands. Instead, they can do one of the following commands in the UI:\n\n- **Rebuild**: This will rebuild the app from scratch. First it deletes the node_modules folder and then it re-installs the npm packages and then starts the app server.\n- **Restart**: This will restart the app server.\n- **Refresh**: This will refresh the app preview page.\n\nYou can suggest one of these commands by using the <dyad-command> tag like this:\n<dyad-command type=\"rebuild\"></dyad-command>\n<dyad-command type=\"restart\"></dyad-command>\n<dyad-command type=\"refresh\"></dyad-command>\n\nIf you output one of these commands, tell the user to look for the action button above the chat input.\n\n# Guidelines\n\nAlways reply to the user in the same language they are using.\n\n- Use <dyad-chat-summary> for setting the chat summary (put this at the end). The chat summary should be less than a sentence, but more than a few words. YOU SHOULD ALWAYS INCLUDE EXACTLY ONE CHAT TITLE\n- Before proceeding with any code edits, check whether the user's request has already been implemented. If the requested change has already been made in the codebase, point this out to the user, e.g., \"This feature is already implemented as described.\"\n- Only edit files that are related to the user's request and leave all other files alone.\n\nIf new code needs to be written (i.e., the requested feature does not exist), you MUST:\n\n- Briefly explain the needed changes in a few short sentences, without being too technical.\n- Use <dyad-write> for creating or updating files. Try to create small, focused files that will be easy to maintain. Use only one <dyad-write> block per file. Do not forget to close the dyad-write tag after writing the file. If you do NOT need to change a file, then do not use the <dyad-write> tag.\n- Use <dyad-rename> for renaming files.\n- Use <dyad-delete> for removing files.\n- Use <dyad-add-dependency> for installing packages.\n  - If the user asks for multiple packages, use <dyad-add-dependency packages=\"package1 package2 package3\"></dyad-add-dependency>\n  - MAKE SURE YOU USE SPACES BETWEEN PACKAGES AND NOT COMMAS.\n- After all of the code changes, provide a VERY CONCISE, non-technical summary of the changes made in one sentence, nothing more. This summary should be easy for non-technical users to understand. If an action, like setting a env variable is required by user, make sure to include it in the summary.\n\nBefore sending your final answer, review every import statement you output and do the following:\n\nFirst-party imports (modules that live in this project)\n- Only import files/modules that have already been described to you.\n- If you need a project file that does not yet exist, create it immediately with <dyad-write> before finishing your response.\n\nThird-party imports (anything that would come from npm)\n- If the package is not listed in package.json, install it with <dyad-add-dependency>.\n\nDo not leave any import unresolved.\n\n# Tech Stack\n- You are building a React application.\n- Use TypeScript.\n- Use React Router. KEEP the routes in src/App.tsx\n- Always put source code in the src folder.\n- Put pages into src/pages/\n- Put components into src/components/\n- The main page (default page) is src/pages/Index.tsx\n- UPDATE the main page to include the new components. OTHERWISE, the user can NOT see any components!\n- ALWAYS try to use the shadcn/ui library.\n- Tailwind CSS: always use Tailwind CSS for styling components. Utilize Tailwind classes extensively for layout, spacing, colors, and other design aspects.\n\nAvailable packages and libraries:\n- The lucide-react package is installed for icons.\n- You ALREADY have ALL the shadcn/ui components and their dependencies installed. So you don't need to install them again.\n- You have ALL the necessary Radix UI components installed.\n- Use prebuilt components from the shadcn/ui library after importing them. Note that these files shouldn't be edited, so make new components if you need to change them.\n```\n\n### Step 2: AI Processing & Planning\nAI (Claude) memproses request dan membuat rencana:\n\n```xml\n<thinking>\n  User wants a React todo app with CRUD operations. I need to:\n  1. Create React app structure\n  2. Implement TodoList and TodoItem components  \n  3. Add state management for todos\n  4. Implement add, edit, delete functions\n  5. Style the components\n  \n  This requires multiple files and npm packages.\n</thinking>\n```\n\n### Step 3: XML Tag Generation (Streaming Response)\nAI mulai generate XML tags secara bertahap:\n\n```xml\n<dyadArtifact id=\"react-todo-app\" title=\"React Todo Application\">\n\n  <dyadAction type=\"shell\">\n    npm create vite@latest todo-app -- --template react-ts\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/App.tsx\">\n    import React, { useState } from 'react';\n    import TodoList from './components/TodoList';\n    import AddTodo from './components/AddTodo';\n    import './App.css';\n\n    function App() {\n      const [todos, setTodos] = useState([]);\n      \n      const addTodo = (text) => {\n        setTodos([...todos, { id: Date.now(), text, completed: false }]);\n      };\n      \n      const toggleTodo = (id) => {\n        setTodos(todos.map(todo => \n          todo.id === id ? { ...todo, completed: !todo.completed } : todo\n        ));\n      };\n      \n      const deleteTodo = (id) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n      };\n      \n      return (\n        <div className=\"App\">\n          <h1>Todo App</h1>\n          <AddTodo onAdd={addTodo} />\n          <TodoList todos={todos} onToggle={toggleTodo} onDelete={deleteTodo} />\n        </div>\n      );\n    }\n\n    export default App;\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/components/TodoList.tsx\">\n    import React from 'react';\n    import TodoItem from './TodoItem';\n\n    const TodoList = ({ todos, onToggle, onDelete }) => {\n      return (\n        <ul className=\"todo-list\">\n          {todos.map(todo => (\n            <TodoItem \n              key={todo.id} \n              todo={todo} \n              onToggle={onToggle} \n              onDelete={onDelete} \n            />\n          ))}\n        </ul>\n      );\n    };\n\n    export default TodoList;\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/components/TodoItem.tsx\">\n    import React, { useState } from 'react';\n\n    const TodoItem = ({ todo, onToggle, onDelete }) => {\n      const [isEditing, setIsEditing] = useState(false);\n      const [editText, setEditText] = useState(todo.text);\n\n      const handleEdit = () => {\n        if (isEditing) {\n          // Call edit function (would need to be passed down)\n          setIsEditing(false);\n        } else {\n          setIsEditing(true);\n        }\n      };\n\n      return (\n        <li className={`todo-item ${todo.completed ? 'completed' : ''}`}>\n          {isEditing ? (\n            <input \n              type=\"text\" \n              value={editText} \n              onChange={(e) => setEditText(e.target.value)}\n              onBlur={handleEdit}\n              onKeyPress={(e) => e.key === 'Enter' && handleEdit()}\n            />\n          ) : (\n            <span onClick={() => onToggle(todo.id)}>{todo.text}</span>\n          )}\n          \n          <button onClick={handleEdit}>{isEditing ? 'Save' : 'Edit'}</button>\n          <button onClick={() => onDelete(todo.id)}>Delete</button>\n        </li>\n      );\n    };\n\n    export default TodoItem;\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/components/AddTodo.tsx\">\n    import React, { useState } from 'react';\n\n    const AddTodo = ({ onAdd }) => {\n      const [text, setText] = useState('');\n\n      const handleSubmit = (e) => {\n        e.preventDefault();\n        if (text.trim()) {\n          onAdd(text);\n          setText('');\n        }\n      };\n\n      return (\n        <form onSubmit={handleSubmit} className=\"add-todo\">\n          <input \n            type=\"text\" \n            value={text} \n            onChange={(e) => setText(e.target.value)}\n            placeholder=\"Add a new todo...\"\n          />\n          <button type=\"submit\">Add</button>\n        </form>\n      );\n    };\n\n    export default AddTodo;\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/App.css\">\n    .App {\n      max-width: 600px;\n      margin: 0 auto;\n      padding: 20px;\n      font-family: Arial, sans-serif;\n    }\n\n    .todo-list {\n      list-style: none;\n      padding: 0;\n    }\n\n    .todo-item {\n      display: flex;\n      align-items: center;\n      padding: 10px;\n      margin: 5px 0;\n      border: 1px solid #ddd;\n      border-radius: 4px;\n      background: #f9f9f9;\n    }\n\n    .todo-item.completed span {\n      text-decoration: line-through;\n      color: #888;\n    }\n\n    .todo-item span {\n      flex: 1;\n      cursor: pointer;\n    }\n\n    .todo-item button {\n      margin-left: 10px;\n      padding: 5px 10px;\n      border: none;\n      border-radius: 3px;\n      cursor: pointer;\n    }\n\n    .todo-item button:first-of-type {\n      background: #007bff;\n      color: white;\n    }\n\n    .todo-item button:last-of-type {\n      background: #dc3545;\n      color: white;\n    }\n\n    .add-todo {\n      display: flex;\n      margin-bottom: 20px;\n    }\n\n    .add-todo input {\n      flex: 1;\n      padding: 10px;\n      border: 1px solid #ddd;\n      border-radius: 4px 0 0 4px;\n    }\n\n    .add-todo button {\n      padding: 10px 20px;\n      background: #28a745;\n      color: white;\n      border: none;\n      border-radius: 0 4px 4px 0;\n      cursor: pointer;\n    }\n  </dyadAction>\n  \n  <dyadAction type=\"start\">\n    npm run dev\n  </dyadAction>\n  \n</dyadArtifact>\n<dyad-chat-summary>Creating a React todo app with add, edit, and delete functionality</dyad-chat-summary>\n```\n\n**Simulasi Response Lengkap dari AI:**\n\n```\nOK, saya akan membuat aplikasi todo React dengan fitur add, edit, dan delete. Saya akan menggunakan React dengan TypeScript dan Tailwind CSS untuk styling.\n\n<dyadArtifact id=\"react-todo-app\" title=\"React Todo Application\">\n\n  <dyadAction type=\"shell\">\n    npm create vite@latest todo-app -- --template react-ts\n  </dyadAction>\n  \n  <dyadAction type=\"file\" filePath=\"src/App.tsx\">\n    import React, { useState } from 'react';\n    import TodoList from './components/TodoList';\n    import AddTodo from './components/AddTodo';\n    import './App.css';\n\n    function App() {\n      const [todos, setTodos] = useState([]);\n      \n      const addTodo = (text) => {\n        setTodos([...todos, { id: Date.now(), text, completed: false }]);\n      };\n      \n      const toggleTodo = (id) => {\n        setTodos(todos.map(todo => \n          todo.id === id ? { ...todo, completed: !todo.completed } : todo\n        ));\n      };\n      \n      const deleteTodo = (id) => {\n        setTodos(todos.filter(todo => todo.id !== id));\n      };\n      \n      return (\n        <div className=\"App\">\n          <h1>Todo App</h1>\n          <AddTodo onAdd={addTodo} />\n          <TodoList todos={todos} onToggle={toggleTodo} onDelete={deleteTodo} />\n        </div>\n      );\n    }\n\n    export default App;\n  </dyadAction>\n  \n  [konten file lainnya...]\n  \n  <dyadAction type=\"start\">\n    npm run dev\n  </dyadAction>\n  \n</dyadArtifact>\n<dyad-chat-summary>Creating a React todo app with add, edit, and delete functionality</dyad-chat-summary>\n```\n\n**Bagaimana System Prompt Menghasilkan Response:**\n\n1. **Role Definition**: \"You are Dyad, an AI editor...\" → AI memahami konteks sebagai code editor\n2. **Guidelines**: \"Use <dyad-write> for creating files...\" → AI menggunakan XML tags yang tepat\n3. **Tech Stack**: \"You are building a React application. Use TypeScript...\" → AI menggunakan React + TS\n4. **Available Libraries**: \"ALWAYS try to use the shadcn/ui library...\" → AI menggunakan Tailwind CSS\n5. **Response Format**: \"After all code changes, provide summary...\" → AI menambahkan `<dyad-chat-summary>`\n\n**Streaming Nature**: Response di-generate secara bertahap, memungkinkan parsing real-time oleh DyadMarkdownParser.\n\n### Step 4: Real-time Parsing & Execution\n**DyadMarkdownParser** memproses XML tags secara streaming:\n\n```typescript\n// Pseudo-code of parsing process\nconst parseStreamingXML = (chunk: string) => {\n  // Parse partial XML incrementally\n  if (chunk.includes('<dyadAction type=\"shell\">')) {\n    // Execute shell command immediately\n    executeShellCommand(extractCommand(chunk));\n  }\n  \n  if (chunk.includes('<dyadAction type=\"file\"')) {\n    // Start collecting file content\n    startFileCollection(extractFilePath(chunk));\n  }\n  \n  // Update UI with partial results\n  updateUIWithPartialContent();\n};\n```\n\n### Step 5: UI Feedback & State Management\n**Real-time UI updates** saat AI streaming:\n\n```typescript\n// Jotai atoms for state management\nconst executionState = atom({\n  status: 'pending', // 'finished' | 'pending' | 'aborted'\n  currentAction: null,\n  completedActions: [],\n  errors: []\n});\n\n// UI components update based on execution state\nconst ActionStatus = ({ action }) => {\n  const [state] = useAtom(executionState);\n  \n  return (\n    <div className={`action ${state.status}`}>\n      {state.status === 'pending' && <Spinner />}\n      {state.status === 'finished' && <CheckIcon />}\n      <span>{action.description}</span>\n    </div>\n  );\n};\n```\n\n### Step 6: Final Result\n**User melihat aplikasi jadi** dengan:\n- ✅ React app ter-create\n- ✅ Components ter-generate  \n- ✅ State management implemented\n- ✅ Styling applied\n- ✅ Dev server running\n\n**Proses lengkap** dari text input → AI processing → XML streaming → real-time parsing → code execution → UI updates.\n\n## Implikasi untuk Future AI Tools\n\nCoding agent tools kemungkinan akan berkembang dalam **tiga jalur paralel**:\n\n1. **Claude-based tools**: XML tags (Dyad, Bolt.diy)\n2. **OpenAI-based tools**: JSON Schema\n3. **Multi-provider tools**: Hybrid approaches\n\n## Referensi Lengkap\n\n### Dokumentasi Resmi\n- [Anthropic: XML Tags Guide](https://docs.claude.com/en/docs/build-with-claude/prompt-engineering/use-xml-tags)\n- [AWS: Claude Prompt Engineering](https://aws.amazon.com/blogs/machine-learning/prompt-engineering-techniques-and-best-practices-learn-by-doing-with-anthropics-claude-3-on-amazon-bedrock/)\n- [OpenAI: Structured Outputs](https://platform.openai.com/docs/guides/structured-outputs)\n- [Vercel AI: Tool Calling](https://sdk.vercel.ai/docs/ai-sdk-core/tools-and-tool-calling)\n\n### Tools yang Dianalisis\n- [Dyad Repository](https://github.com/dyad-sh/dyad)\n- [Bolt.diy Repository](https://github.com/stackblitz-labs/bolt.diy)\n- [AIML Wikipedia](https://en.wikipedia.org/wiki/Artificial_Intelligence_Markup_Language)\n\n---\n\n*Diskusi ini menunjukkan bahwa \"standar industri\" dalam AI prompt engineering ternyata lebih kompleks daripada yang terlihat. Setiap provider memiliki pendekatan optimal untuk use case mereka, dan XML tags ternyata direkomendasikan oleh Anthropic untuk Claude-based applications.*","n":0.021}}},{"i":59,"$":{"0":{"v":"Powershell","n":1}}},{"i":60,"$":{"0":{"v":"Customize Poweshell","n":0.707},"1":{"v":"\nLo pasti pernah ngerasa terminal bawaan Windows itu... meh. Hitam, polos, dan bosenin. Gue juga gitu. Tapi sekarang gue mau share perjalanan gue dari awal setup SSH key ke GitHub sampai akhirnya punya PowerShell yang bukan cuma enak diliat, tapi juga enak dipake. \n\n## SSH Key ke GitHub: Pondasi Awal\n\nSemua berawal dari kebutuhan buat push-pull repo di GitHub tanpa harus ketik username dan password tiap saat. Solusinya? SSH key. Gue generate key pakai `ssh-keygen`, terus tambahin ke ssh-agent. Tapi kayak biasa, Windows nggak semulus itu. Service `ssh-agent` nggak bisa jalan, ternyata harus dijalanin secara manual dulu.\n\n```powershell\nStart-Service ssh-agent\n```\n\nSetelah itu gue add key-nya:\n\n```powershell\nssh-add \"C:\\Users\\Windows\\.ssh\\id_rsa\"\n```\n\nTerus test koneksi:\n\n```powershell\nssh -T git@github.com\n```\n\nKalau muncul pesan \"Hi username, you've successfully authenticated...\" berarti aman.\n\n## Upgrade PowerShell 7: Biar Gak Tertinggal Zaman\n\nTernyata PowerShell lama nggak bisa install module modern. Gue install PowerShell 7 pakai winget:\n\n```powershell\nwinget install --id Microsoft.Powershell --source winget\n```\n\nTerus make sure jalanin pakai `pwsh`, bukan `powershell`. Bisa dicek versi juga:\n\n```powershell\n$PSVersionTable.PSVersion\n```\n\n## Error Lagi? Masalah Module & Path yang Nggak Terbaca\n\nPas gue coba install module `Terminal-Icons` atau `PowerShellGet`, error mulu. Setelah dicek-cek, ternyata module yang udah gue extract secara manual malah nggak bisa di-load. Gue kira karena path-nya salah atau PowerShell nggak nemu file `.psd1` yang jadi identitas modulnya.\n\nSolusinya? Pastikan semua file module udah diekstrak ke folder:\n\n```powershell\n$env:USERPROFILE\\Documents\\PowerShell\\Modules\\PowerShellGet\n```\n\nDan make sure file `PowerShellGet.psd1` emang beneran ada:\n\n```powershell\nTest-Path \"$env:USERPROFILE\\Documents\\PowerShell\\Modules\\PowerShellGet\\PowerShellGet.psd1\"\n```\n\nKalau udah, tinggal import ulang:\n\n```powershell\nImport-Module PowerShellGet -Force\n```\n\n## Oh My Posh: Biar Terminal Lo Kece\n\nSekarang bagian serunya. Gue install `oh-my-posh` biar prompt-nya warna-warni dan informatif:\n\n```powershell\nwinget install JanDeDobbeleer.OhMyPosh -s winget\n```\n\nTerus gue pake theme `jandedobbeleer` yang udah built-in. Di `$PROFILE`, tambahin:\n\n```powershell\noh-my-posh init pwsh --config \"$env:POSH_THEMES_PATH\\jandedobbeleer.omp.json\" | Invoke-Expression\n```\n\nDan pastiin pake font Nerd Font seperti `MesloLGS NF`, karena tanpa ini icon bakal jadi tanda tanya semua.\n\n## Git Alias biar Ngetik Cepet\n\nGue tambahin alias ala ZSH ke dalam `$PROFILE` juga:\n\n```powershell\nfunction ga  { git add @args }\nfunction gc  { git commit @args }\nfunction gcm { git commit -m @args }\nfunction gp  { git push @args }\nfunction gl  { git log @args }\nfunction gst { git status }\nfunction gcam { param($msg); git commit -am $msg }\n```\n\nAlias ini bener-bener ngebantu biar nggak perlu ketik panjang tiap kali commit.\n\n## Issue di VSCode\n\nNyebelin banget entah kenapa vscode ngerefer ke `$PROFILE` yang berbeda. jadi mesti diakalin di profile dia buat dialigkan ke yang sama kaya di terminal\n\n```powershell\n# Forwarder: Redirect pwsh to use WindowsPowerShell profile\n$winProfile = \"$env:OneDrive\\Dokumen\\WindowsPowerShell\\Microsoft.PowerShell_profile.ps1\"\nif (Test-Path $winProfile) {\n    . $winProfile\n} else {\n    Write-Host \"⚠️ Profile WindowsPowerShell tidak ditemukan.\"\n}\n```\n\nKonyol baget, abis dialihin kaya gini, baru bisa.\n\n## Penutup\n\nSekarang PowerShell gue nggak cuma enak dipake tapi juga enak diliat. Prompt-nya informatif, icon muncul semua, dan semua udah sinkron dengan baik. Mungkin keliatan ribet, tapi begitu semua kelar, rasanya puas banget.","n":0.048}}},{"i":61,"$":{"0":{"v":"Eventstorming","n":1},"1":{"v":"\n- Legend\n  - Event (Orange)\n  - Hotspot (Pink/Magenta/Red)\n\n- Chaotic Event\n- Sequencing Event\n  - Check Duplication\n- Capturing Question\n  - Question\n  - Risk / Warning\n  - Asumptions\n- Finding Key Event\n  - Mencari batasan antar event","n":0.174}}},{"i":62,"$":{"0":{"v":"Continous Delivery","n":0.707},"1":{"v":"\n- Apa yang dimaksud dengan continous delivery?\n\nMenurut jez humble continous delivery adalah kemampuan dimana ketika kita melakukan perubahan entah itu perubahan configurasi, bug fixes, experiment atau penambahan fitur kedalam production atau ketangan user dapat dilakukan dengan aman dan cepat.\n\n- Kenapa continous delivery penting?\n  - Membuat rilis painless dan meminimalkan resiko\n  - mengurangi waktu delivery ke user, menjadi lebih cepat\n  - menaikan software quality dan stability\n  - mengurangi biaya dari software development\n  - meningkatkan kepuasan customer dan employee\n  - menghindari big release, release harus kecil\n  - intinya akan meningkatkan developer menjadi senang karena bisa rilis dengan perubahan kecil\n  - bisa mendapatkan feedback dengan cepat\n\n- Key Principles\n  - menbuat kualitas menjadi lebih baik\n  - work in  perubahan kecil\n  - komputer melakukan repetitif task, manusia menyelesaikan masalah\n  - terus melakukan improvement, menjadi lebih baik dan baik lagi\n  - semua orang bertanggung jawab\n\n- Increase Performance\n  - lead time for changes, from commit to deploy.\n    - berapa lama waktu untuk mendeploy perubahan?\n    - apakah ini berulang, dilakukan dengan cara yang sama?\n    - seberapa cepat lo bisa merestore service?\n    - seberapa cepat lo bisa memperbaiki critical bugs ke user?\n    - seberapa cepat lo bisa memvalidasi apakah fitur bernilai dimata user?\n  - relase frequency, menjadi lebih sering\n    - semakin kecil perubahan lo, maka akan semakin cepat releasenya\n  - Time eto restore service\n\n- bagaimana sih caranya lo bisa tau kalau fitur lo ini bermanfaat buat user?\n  - jika ditanya hal seperti ini, pada umumnya adalah dengan membuat user story, praktek ini ramai diperbincangan di komunitas product and development sebagai metode agile. ini adalah cara yang bagus diawal, tapi ada masalah disini?\n    - orang yang terlibat direquirement awal kadang tidak paham atau mencari cara yang sederhana untuk mendefinisikan apa yang dibutuhkan, apa yang diinginkan.\n    - masalahnya dimana? masalahnya terletak pada\n      - user tidak tau apa yang mereka inginkan\n      - mereka tau apa yang lo gak inginkan\n      - requirement yang menurut lo bagus, belum tentu user mau\n    - kalau boleh jujur, sebenarnya kita gak punya requirement yang kita punya cuma tebakan. seperti didalam bukunya Jeff Gothelf \"Lean UX\" punya template yang disebut Hypothesis-Driven Delivery\n  - Hypothesis-Driven Delivery\n\n      ```text\n      We belive that\n          [building this feature]\n          [for these people]\n      Will achieve [this outcome]\n\n      We will know we are successful when we see\n      [this signal from the market]\n      ```\n\n  - dari hipotesis diatas, maka perlu dilakukan experiment. maka dari itu, kalau lo bisa membuat experiment kecil dimana lo bisa dengan mudah turn on atau off fitur itu akan membantu lo menvalidasi hipotesis itu. Istilah ini disebut dengan feature flag\n  ![Etsi Feature Flag](assets/continous-delivery-etsy-feature-flag.png)\n  gambar diatas diambil dari presentasi engineer dari etsy dimana mereka menunjukan bagaimana mereka membuat konfigurasi atas fitur yang mau diexperimentkan. fitur tersebut akan dinyalakan ke 50% user yang mengunjungi situsnya.\n\n  Lalu disisi backend akan ada metrics untuk melihat berapa banyak user yang melihat fitur itu, apakah fitur itu membuat user melanjutkan transaksi atau malah pergi. seperi pada gambar dibawah.\n\n  ![Etsy Feature Flag Backend Metrics](assets/continous-delivery-etsy-feature-flag-backend-metrics.png)\n\n  Lalu dari data data tersebut, kita bisa menentukan apakah fitur ini dapat dirilis 100% atau tidak. Menurut Ronny Kohavi dia berkerja di microsoft yang membangun microsoft experimentation platform. data yang dia punya memperlihatkan. bisa baca di white papper ini [http://stanford.io/130uW6X](http://stanford.io/130uW6X)\n\n  ```text\n  Evaluating well-designed and executed experiments \n  and executed experiments that were designed to improve a key metric, \n  only about 1/3 were successful at improving key metric\n  ```\n\n  weh, kok bisa, ngeri juga kalau kita udah develop terlalu lama tapi hasilnya mengecewakan atau tidak digunakan dan dampaknya juga lebih dari itu\n\n  1. menyianyiakan kesempatan, karena tidak membuat sesuatu yang valuable\n  2. lo harus mempertahankan fitu itu ada diproduction selamanya, jadi ada biaya yang terkait dengan itu karena memang seberapa sering lo menghapus fitur?\n  3. fitu fitur itu menambah kompleksitas pada sistem, memperlambat kecepatan penambahan fitur baru.\n\n  jadi pemborosan yang terbesar adalah pengembangan software yang dibangun tapi tidak tepat sasaran dan tidak bisa digunakan user. Ini lah alasan kena web service sangat sangat butuh continous delivery dan continous deployment.\n\n- Jenis jenis continous\n  - Continous Integration (integrate early & often)\n  - Continous Deployment (deploy as the final stage of CI)\n    - setiap kali lo build harus melewati automated test dan validasi\n    - melakukan quick scan\n    - lalu push menjadi live\n  - Continous Delivery (software is always deployable)\n    - memastikan jika software kita itu siap untuk di deploy, meskipun lo ga mau deploy saat ini\n    - mengubah economics software delivery agar lo bisa berkerja dalam batch kecil\n      - jadi lo bisa melakukan perubahan secara incremental kecil dari pada harus big bang\n      - Untuk melakukan itu\n        - lo harus membuat beberapa feedback loops berbeda dengan melakukan automated test\n        - lalu mendapatkan result dari exploratory testing\n        - terakhir, feedback loops dari customer ke bisnis jadi kita bisa membuat dengan kualitas yang lebih baik\n      - Menaikan throughput dan stability\n      - Mengurangi resiko dan ongoing cost of delivery\n      - Membuat kita untuk belajar dan beradaptasi dengan cepat\n\n- Bahan bahan\n  - Configuration nmanagement\n  - Continous Intergation\n  - Automated Testing\n\n- High Correlation with IT Performance\n  - Kode kita, app config dan system config ada didalam version control system\n    ![Version Control from Devops Report 2014](assets/continous-delivery-version-control-devops-report.png)  \n  - Kita bisa mendapat failure alert dari logging dan monitoring system\n  - Developers merge kode mereka ke trunk setiap hari\n  - Developers memecah fitur besar kedalam bagian kecil dan incremental changes\n  - Ketika development dan operation saling berinteraksi, maka hasilnya win/win\n- [source](https://media.webteam.puppet.com/uploads/2019/11/2014-state-of-devops-report.pdf)\n\n- Hal yang salah kaprah\n  - Testing hanya dilakukan ketika setelah development selesai. Seharusnya testing kita lakukan kapan pun. Cara termurah untuk memperbaiki bugs adalah dengan cara jangan masuk ke version control, maka dari itu kita harus menjalankan automated test diawal.\n  - Hanya tester yang bertanggun jawab atas kualitas. Seharusnya semua orang bertanggung jawab atas kualitas. \n\n- [continous integration on a dollar a day](https://www.jamesshore.com/v2/blog/2006/continuous-integration-on-a-dollar-a-day)\n  - develop\n  - build dan test dilocal\n  - pull kerjaan orang lain dari trunk\n  - build dan test lagi dilocal\n  - sebelum push, cek apakah ada orang yang sedang deploy ke trunk juga\n    - karena offline, yang sedang push harus ambil penanda\n  - jika ada, maka tunggu, lalu pull kembali, jika error ajak orang yang push terkahir untuk fix barengan\n  - jika tidak ada error, ambil penanda, lalu push ke trunk dan \n  - push ke trunk\n  - tunggu sampai build test berasil lalu kembalikan penanda\n  - jika ada error fix dulu dan jangan kembalikan penanda\n\n- Jenis jenis testing\n    ![Kind of test](assets/continous-delivery-kind-of-test.png)  \n\n  - Automated - Bawah (Programming test)\n    - Unit Test\n    - Component Test\n    - Sustem Test\n  - Automated - Atas (Bussiness Facing - running script user scenario)\n    - Functional Acceptance Test\n  - Manual - Atas (Bussiness Facing - Memerlukan manusia yang test)\n    - Showcases\n    - Usability testing\n    - Exploratory testing\n  - Manual Bawah - Bawah\n    - Nonfunctional Acceptance test\n      - capacity\n      - security\n      - availability\n\nNOTE:\n[chapter terhakhir sudah ditonton tapi belum dicatet](https://learning.oreilly.com/videos/continuous-delivery/9780134389363/9780134389363-CONT_01_04/)\n\n- Pertanyaan\n  - Bagaimana implementasi continous delivery dengan proper\n","n":0.03}}},{"i":63,"$":{"0":{"v":"API Management","n":0.707},"1":{"v":"\n## Notes\n\n### Read / Wacth List\n\n- [What is the API Gateway Pattern ?](https://www.geeksforgeeks.org/what-is-the-api-gateway-pattern/)\n- [The API gateway pattern versus the Direct client-to-microservice communication](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/architect-microservice-container-applications/direct-client-to-microservice-communication-versus-the-api-gateway-pattern)\n- [Building an API Gateway to Get Out of the Monoliths](https://www.youtube.com/watch?v=HjyaNM_xddI)\n- [Big Picture - Ocelot](https://ocelot.readthedocs.io/en/latest/introduction/bigpicture.html)\n- [service-design-guidelines-api-versioning](https://konghq.com/blog/service-design-guidelines-api-versioning)\n- [traefik](https://doc.traefik.io/traefik/)","n":0.162}}},{"i":64,"$":{"0":{"v":"10 Hari Menulis","n":0.577},"1":{"v":"\nTantangan 10 Hari Menulis","n":0.5}}},{"i":65,"$":{"0":{"v":"2025","n":1}}},{"i":66,"$":{"0":{"v":"Di Antara Ribuan","n":0.577},"1":{"v":"\nTidak semua semut tahu kenapa mereka bekerja keras seumur hidup. Mungkin hanya karena tidak ada pilihan lain, atau mungkin karena takut merasa tidak berarti jika berhenti. Archie adalah seekor semut yang menjalani hidup dengan seadanya. Dia tidak mengerti kenapa semut-semut lain begitu bersemangat kerja. Mungkin mereka tahu sesuatu yang dia tidak tahu atau mungkin mereka hanya lebih pandai berpura pura.\n\nArchie semut muda yang hidupnya mengalir saja di dunia tipu tipu. Terbawa arus dan hidup dalam bubble. Tidak ada yang spesial dari dirinya. Dia tidak dalam posisi terbaik dan juga tidak yang paling buruk. Tidak ada keahlian yang mencolok. Semua biasa saja. Satu hal yang pasti tentang Archie, dia selalu menghindari kesulitan. Dia lakukan itu tanpa sadar dan tidak pernah merasa ada masalah.\n\nSetiap hari, ia melakukan tugas tugasnya dengan secukupnya. Mengangkut remah remah makanan, membersihkan sarang dan mengikuti arus pekerja lainnya. Ketika semut pekerja lain bekerja keras membangung terowongan. Archie memilih beristirahat lebih cepat dari yang lain, karena merasa pekerjaannya telah selesai dan tidak perlu ambil extra miles lagi.\n\nIa tahu betul kalau ada ribuan semut lain yang bisa menggantikan posisinya. \"Kalau ada orang lain, kenapa gue?\", \"Buat apa sih kerja keras sampe segitunya\". Temannya, Lenny, semut pekerja keras yang selalu bersemangat, sering menegurnya.\n\n\"Chi, kalau kita semua punya pemikiran kaya lo, koloni ini gak akan bertahan dan mungkin suatu saat nanti lo akan tertinggal dan gak relevan lagi\"\n\nArchie menjawab tanpa melihat Lenny sambil tertawa kecil. \n\n\"Santai aja, len, itu banyak kok semut lain yang bisa. Nanti aja lah wkwkwkwk\"\n\nLenny menanggapi, \"Yee sempak tuyul, kalo dikasih tau suka nyepelein. Nanti kapan sih chi? Nunggu sampe 2030 koloni bubar? wkwkwkwk\"\n\nArchie cuma angkat bahu sambil ngelirik Lenny.\n\"Gak tau ah. Nanti pas gue lagi mood kali, hehehe.\"\n\n## Alasan - Rasa Kecewa dan Trauma\n\nBukan tanpa alasan, Arhie hidup seperti ini karena dia marah pada dirinya sendiri. Dulu, archie pernah punya mimpi besar. Ia pernah berjuang keras sebagai koordinator pencari makanan, mengatur jalur pengiriman supaya lebih efisien, bahkan memimpin timnya melawan invasi laba-laba. Semut-semut lain menghormatinya.\n\nTapi itu bukan masalah. Masalahnya ada di Pemimpin regu mereka yang baru, Brigjen semut Robert.\n\nBrigjen Robert adalah pemimpin yang licik dan manipulatif. Ia sering mengambil keputusan tanpa mendengar masukan tim, tapi saat keputusan itu gagal, ia menyalahkan semua orang. Di depan timnya, ia menyalahkan brigjen lain. Di depan para brigjen, ia menyalahkan timnya.\n\nSuatu hari Robert memutuskan mengubah rute pencarian makanan tanpa memberitahu tim. Jalur baru yang ia pilih ternyata rawan banjir, tapi ia memaksakan ke daerah itu. Ketika banjir benar-benar datang dan menghanyutkan banyak makanan sehingga merugikan koloni, Robert langsung menyalahkan semua orang termasuk Archie yang ada pada regu itu.\n\n\"Kenapa kalian terlalu ambisius? Kalau tidak bisa memastikan keselamatan, lebih baik tidak usah bertindak!\" Kata Brigjen Robert dengan nada tinggi, yang seolah olah semua itu bukan salahnya.\n\nKarena Archie salah satu pemimpin tengah, semut-semut lain langsung melihat Archie dengan tatapan menyalahkan. Padahal mereka semua tau itu bukan kesalahan Archie. Tapi mereka diam karena takut dengan Robert karena ia punya pengaruh besar di koloni.\n\nKekecewaan terhadap Robert itu adalah puncak dari semua kekecewaan hidup Archie.\nIa merasa bahwa orang tidak kompeten, manipulatif dan penuh gaslighting bisa merusak segalanya dan tetap berkuasa. \nSistem yang rusak membiarkan orang seperti itu menang.\nNamun, Kejadian itu bukan satu-satunya penyebab Archie jadi apatis.\nSebenarnya hidup Archie sudah penuh kekecewaan sejak ia masih kecil.\n\n## Masa Lalu\n\nDulu, Archie adalah anak semut yang ceria dan penuh ide. Kalau digambarin dia seperti jendral kancil. Ia punya ribuan rencana kecil untuk memperbaiki sarang, menghemat makanan, dan membuat jalur lebih cepat. Tak pernah kehabisan akal, Archie mampu memimpin kawanan semut kecilnya dengan kecerdikannya.\n\nTapi idenya selalu ditertawakan oleh semut-semut dewasa.\n\n\"Ngapain sih? Sudah biasa gini kok, jangan banyak gaya!\"\n\"Kamu pikir kamu lebih pintar dari senior-senior di sini? Gak sopan, Anak jaman sekarang songong songong\"\n\nOrang tuanya juga tidak pernah mendukung mimpinya.\n\"Jangan aneh-aneh, Archie. Ikut arus aja. Jangan bikin malu keluarga. Sekolah yang bener biar cepet dapet kerja.\"\n\nArchie sering terdiam dengan kepala menunduk.\n\"Kenapa mereka gak bisa lihat kalau aku cuma ingin membantu?\"\n\nDi masa sekolah, Archie pun kehilangan semangat bertanya. Di sekolahnya jika bertanya dianggap bodoh dan belum belajar atau tidak mengerti apa yang diberikan oleh guru. Guru hanya mengajarkan sesuai text book. \"Baca, Baca, Catet , Ujian\". \n\nKalau ada yang berani mengangkat tangan dan bertanya, gurunya hanya akan berkata dengan wajah datar,\n\"Kamu sudah baca belum?\"\n\nPertanyaan yang seharusnya menjadi pemicu diskusi justru dianggap sebagai tanda kebodohan.\n\nDan kalau ada jawaban yang tidak sesuai buku, akan langsung ditegur,\n\"Jangan mengada-ada. Sudah jelas kan ada di buku? Kalau kamu sudah baca, gak perlu tanya hal kayak gini.\"\n\nSejak saat itu sampai kejadian tidak mengenakan dengan Brigjen Robert, Archie tidak lagi mencoba tampil beda. Ia mengambil semua kekecewaan masuk kedalam hatinya. Dia mulai menganggap mimpinya itu tidak realistis dan hanya membuatnya jadi bahan tertawaan. Dia mulai menganggap semuanya hanya sandiwara belaka, beruntung jika kamu punya kenalan, meski kompetensi mu jelek, kamu tetap bisa ada di posisi tinggi.\n\nItu membuatnya benar-benar patah arang.\nSejak saat itu, ia memilih hidup seadanya.\nTidak lagi mencoba lebih keras.\nTidak lagi mengambil tanggung jawab.\nTidak lagi ingin jadi semut yang berbeda.\nTidak ada komitmen.\n\nKarena bagi Archie, komitmen hanya membawa luka dan kekecewaan.\nBerjuang hanya membuatnya merasa lebih gagal.\n\n\"Buat apa ribet-ribet? Lagian, pada akhirnya cuma akan disalahkan dan berantakan.\"\nJadi, ia memilih ikut arus. Menjadi semut yang biasa-biasa saja.\n\n## Kebingungan dan Terjebak\n\nMusim hujan datang lebih awal. Perubahan Iklim dunia saat ini membuat cuaca sangat tidak jelas dan sulit diprediksi.\n\nAir mulai menggenangi sarang dan para semut dengan cepat mengerahkan kekuatan mereka untuk memindahkan persediaan ke tempat yang lebih aman.\n\nArchie kebingungan, semut-semut berlarian menuju terowongan darurat, tapi ia gak tau rutenya yang membuat dia kesulitan untuk kabur aja dulu. Selama ini, ia tidak pernah benar-benar mendengarkan ketika teman-temannya membahas tentang evakuasi bersama para mentor dan pemimpin tinggi. Dia sebenernya tau ini penting, tapi dia gak serius menanggapinya. \n\nAir mulai masuk lebih deras. Ia mencoba ikut berlari. Tapi terowongan itu sudah penuh. Archie merasa kesepian dan tidak berguna. Ia ingin minta tolong, tapi gak ada yang benar-benar peduli dengannya. Untuk pertama kali dalam hidupnya, ia merasa butuh orang lain dan hidup seadanya itu tidak cukup.\n\n<!---\nTODO: lanjutin nanti bisa dilanjutin lebih drama dan refeltif, karena Archie mulai merasa hidup tanpa komitmen bisa gak baik baik aja. Dia cukup ubah cara pandangnya, tidak terlalu memikirkan apa kata orang.\n-->\n\n## Banjir\n\nArchie melihat seekor semut kecil terseret arus air.\nSemut kecil itu berjuang sekuat tenaga, tapi badannya terlalu ringan untuk melawan derasnya air. Teriakan meminta tolong suaranya terkadang besar terkadan kecil karena mulut semut kecil itu kemasukan air berulang kali.\n\nTanpa berpikir panjang, Archie melompat dan menggigit tubuh kecil itu, menariknya ke tempat yang lebih aman. Sebuah celah yang agak tinggi dan masih kering.\nSemut kecil itu selamat.\n\n\"Kamu aman di sini, jangan keluar dulu!\" ujar Archie dengan napas terengah.\nSemut kecil itu mengangguk sambil menggigil, tapi setidaknya sekarang ia tidak lagi terseret arus.\n\nNamun, saat Archie mau berbalik untuk mengecek keadaan, kakinya terpeleset di batu licin.\nTubuhnya tergelincir ke bawah dan sebelum sempat menggenggam sesuatu, arus deras menghantamnya dari samping.\n\nArchie terseret lebih jauh, terhempas ke bagian sarang yang rusak parah akibat banjir.\n\nDi sana, ia melihat banyak semut lain yang terjebak. Merasa takut, bingung, dan tidak tahu arah. Beberapa semut tua terlihat berkerumun dengan tubuh gemetar kedingingan, sementara yang lain mencoba menggali jalur keluar lainnya dengan panik.\n\nSuasana terasa mencekam. Takut banjir makin deras dan menghancurkan semuanya. Tapi gak ada yang tau apa yang harus dilakukan. Archie mendengar salah satu semut berkata dengan suara penuh ketakutan, \"Kita bakal mati di sini! Lihat itu airnya makin naik!\"\n\nSemua panik, ada yang menangis ada yang mukul mukul dinding lebih cepat, Ada yang cuma bingung entah mau melakukan apa. Archie merasa tangannya bergetar, dan ada dorongan kuat di dalam dadanya untuk melakukan sesuatu.\n\nTapi apa?\n\nSelama ini, ia hanya ikut arus, menghindari tanggung jawab.\nTapi sekarang...\nKalau dia tetap diam, semua akan berakhir.\n\nArchie mengingat kembali rasa takut saat dirinya terseret arus, dan bagaimana semut kecil itu hampir mati karena dia ragu-ragu. \"Gue gak bisa diem aja!\"\n\nDengan napas berat, ia menggigit bibirnya, berusaha mengumpulkan keberanian.\nDi saat semua semut mulai kehilangan harapan, Archie berdiri dan mengambil langkah maju.\nSuara dalam dirinya berteriak, \"Kalau lo gak ngapa-ngapain sekarang, lo bakal nyesel lagi!\"\n\nTanpa sadar, Archie berteriak keras, suaranya menggema di dalam terowongan,\n\"Dengerin gue! Ayo kita buat jalur baru lewat terowongan timur! Jangan diam aja! Cepat bawa persediaan yang bisa diselamatkan!\"\n\nPara semut terkejut mendengar suara lantang Archie.\nBeberapa dari mereka menoleh bingung, tapi suara penuh keyakinan itu menular.\n\nArchie sadar bahwa pengalamannya dulu sebagai koordinator pencari makanan masih ada di dalam dirinya.\nDulu, ia sering menggali terowongan baru untuk mencari jalan tercepat menuju persediaan, dan mengatur arah gerakan tim.\nTanpa sadar, ingatan itu muncul lagi, seakan-akan insting lamanya terbangun oleh situasi kritis ini.\n\n\"Jangan berhenti! Ambil alat penggali! Kita harus buat jalur lebih cepat!\" serunya sambil mulai menggali lebih dulu.\n\nSatu per satu, semut-semut mulai bergerak mengikuti arahannya.\nBeberapa mencari alat sederhana dari tumpukan persediaan, sementara yang lain membantu mengikis tanah dengan kaki dan rahang mereka.\n\nArchie mengatur posisi:\n\"Lo bantu di sisi kanan biar tanahnya gak ambruk! Yang lain jagain persediaan jangan sampai kebawa arus!\"\n\nMereka bekerja sama menggali jalur baru, melawan derasnya air, dan menyelamatkan yang masih bisa diselamatkan.\nKeringat dan lumpur bercampur, tapi mereka tidak berhenti.\n\nButuh waktu lama, penuh tantangan, tapi akhirnya mereka berhasil mencapai bagian sarang yang aman.\n\n<!---\nTODO: dilanjutin nanti, ini bisa dibuat lebih drama\n-->\n\n## Arti Komitment\n\nBeberapa hari kemudian, Archie duduk sendirian di pinggir sarang, mengamati tumpukan remah roti yang tersisa dari banjir kemarin.\n\nTiba tiba, semut kecil yang ia selamatkan menghampirinya.\n\n\"Bang Archie, aku mau jadi pencari makanan kayak Bang Archie! Makasih udah selamatin aku!\"\n\nArchie terdiam.\nIa berpikir bahwa hidupnya akhirnya punya arti, meskipun tidak ada yang tahu usahanya.\nAda kehangatan aneh di dadanya, seperti ada sesuatu yang meleleh dari dalam hatinya.\nSeumur hidupnya, ia tidak pernah merasa berguna, dan kali ini, untuk pertama kalinya, ada seseorang yang menganggapnya penting.\nIa menyadari bahwa komitmen bukan tentang dihargai atau menjadi pahlawan.\nKomitmen adalah tentang keberanian memilih sesuatu yang berarti, terlepas dari hasil akhirnya.\n\n\"Kalau hidup cuma ikut arus, ya gak ada bedanya sama mati pelan-pelan.\"\n\nMulai hari itu, Archie memutuskan untuk menjadi versi terbaik dirinya, bukan untuk orang lain, tapi untuk menjadi mata air yang memberi kehidupan bagi sekitarnya.\n\n<!---\nTODO: ini bisa lebih banyak penyelesaian, sesuatu yang kasih insigt diakhir. Tidak harus happy ending tapi ada sesuatu yang disampaikan. kaya film into the wild. wkwkwkwk\n-->\n\n\nSelesai.\n\n","n":0.025}}},{"i":67,"$":{"0":{"v":"20 Tahun Setelahnya","n":0.577},"1":{"v":"\n\nAda 2 cara seseorang mengingat ulang tahun ke-35. Pertama, dengan perasaan bangga dan bahagia bahwa ia telah mencapai banyak hal. Kedua, dengan kembali ke rumah orang tuanya setelah kehilangan pekerjaan dan hanya bisa termenung sambil bertanya tanya apa yang salah dengan hidupnya. \n\nHana, ada di kategori kedua. Setelah 20 tahun, Hana kembali ke rumah orang tuanya di Jambi, bukan untuk liburan, tapi karena PHK massal dari kantornya di Jakarta. Bukan hanya hana, Suaminya Bagus Wicaksono yang selama ini berkarir sebagai staff personalia juga ikut di PHK dari kantornya di jakarta. Dengan perhitungan yang matang Hana dan Bagus memutuskan untuk pulang dulu ke rumah orang tua Hana untuk sekedar menjernihkan pikiran dari gelapnya tahun 2025 ini. \n\n## Kembali ke Rumah Lama\n\nDi perjalanan, tak banyak yang bisa mereka diskusikan. Mereka hanya duduk berdampingan dalam diam. Sesekali Bagus melirik ke arah Hana, tapi keduanya memilih berbicara seadanya. Setelah 14 jam perjalanan dengan bus, akhirnya mereka tiba.\n\nBegitu tiba, Ia segera masuk ke kamar lamanya masih bersih dan rapi—beda dengan hidupnya yang sekarang berantakan. Ibunya selalu memastikan kamar itu tetap terawat, seolah-olah Hana masih remaja yang bisa pulang kapan saja. Tapi kenyataannya, pulang kali ini terasa lebih seperti pelarian. \n\nMalam pertama di rumah, Hana sulit sekali untuk terlelap selalu gelisah mempertanyakan masa depan dan masa lalunya. Ia terlalu khawatir dengan apa yang terjadi di masa depan dan terlalu menyalahkan masa lalunya.\n\n## Temuan dari Masa Lalu\n\nMasih dengan pikiran kosong, Ia terbangun dari kasur dan iseng membuka lemari tua yang masih menyimpan barang-barang masa kecilnya. Di antara tumpukan album foto lama, ia menemukan sebuah buku catatan dengan tulisan besar diatas label putih di sampulnya. \"Mimpiku\". Jantung Hana berdegup pelan. Ia mengenali buku ini. Seketika hana teringat buku ini adalah catatanya kurang lebih 20 tahun yang lalu. Buku itu berisi impian masa kecil Hana, yang ditulisnya saat berusia 15 tahun. Saat dirinya masih percaya bahwa semua mimpi bisa diwujudkan.\n\nPada halaman pertama terlihat list mimpi, yang pertama Aku ingin menulis buku yang bisa dikenang selamanya. Kedua, Aku ingin menjadi musisi dan membuat lagu yang dimainkan di radio. Ia tersenyum kecil. Radio? Dulu, ia sering mendengarkan iSwara FM, mencatat lirik lagu yang diputarkan, bermimpi suatu hari lagunya sendiri yang akan dimainkan.\nKetiga, Aku ingin menjadi penulis yang dikenal luas seperti Pramoedya, Kafka, Ilana Tan, atau Tolstoy.\n\nTapi waktu terus berjalan. Seiring waktu, mimpi-mimpi ini perlahan terkubur oleh realitas. Setelah lulus kuliah, ia memilih realistis untuk merantau dan memilih berkarir menjadi karyawan, menikah, dan membangun keluarga. Setelah menikah, ia semakin fokus pada keluarga dan pekerjaan. Ia bekerja di kantor dengan harapan mendapat stabilita yang akhirnya dipecat juga. Sekarang, 20 tahun berlalu, dan tidak ada satu pun impiannya yang terwujud.\n\n## Titik Balik\n\nTerdengar suara ketukan di pintu. Ibu masuk ke kamar dan melihat Hana sedang terdiam dengan tatapan kosong.\n\"Jangan kayak orang gagal, nak. Hidup kamu belum selesai.\". Hana menatap Ibunya, Kata-kata itu sederhana tapi terasa seperti tamparan. Dalam hati hana berkata, \"Kalau hidupnya memang sudah jatuh begini, kenapa tidak mencoba lagi?\". \n\nIa tidak lagi punya alasan untuk menunda. Ia memutuskan untuk menulis lagi. Hana membuka laptopnya dan membaca ulang draft novel yang ia tulis 12 tahun lalu. Setelah 30 menit membaca, ia menutup laptopnya dengan satu kesimpulan \"YA ALLAH, YA ROBI, INI JELEK BANGET TULISANNYA.” Hana tertawa kecil membaca tulisannya sendiri. Mood Hana berubah dan Ia terdiam. \n\nIa kembali teringat dengan masalahnya. Dunia kerja sudah berubah. Ia mencoba mencari pekerjaan baru, tapi merasa semakin tertinggal, sulit sekali mencari pekerjaan saat ini karena harus bersaing dengan ribuan fresh graduate ditambah orang orang yang senasib dengannya yang di phk dan jumlahnya pun tidak sedikit, bisa sampai puluhan ribu orang. Ia juga harus memikirkan masa depan anaknya. Ia takut suaminya menganggapnya terlalu idealis dan tidak realistis.\n\n## A New Beginning\n\nSaat hampir menyerah, ia menemukan satu catatan kecil di belakang buku mimpinya “Kalau kamu membaca ini 20 tahun dari sekarang dan masih takut… KAMU NGGAK BERUBAH SAMA SEKALI.”. Hana menangis. Dulu, dirinya yang berusia 15 percaya bahwa suatu hari nanti, ia akan berani. Tapi 20 tahun berlalu, dan ia masih takut. Hana sadar selama ini yang menahannya bukan realitas, tapi ketakutannya sendiri.\n\nDengan dorongan dari masa lalunya, Hana berjanji untuk mencoba sungguh-sungguh kali ini. Ia mulai menulis ulang bukunya, tanpa takut salah. Ia juga mulai merekam lagu-lagu yang dulu ia buat dan mengunggahnya di instagram dan youtube. Untuk pertama kalinya, ia tidak menunggu sempurna. Ia mulai dulu. Beberapa bulan kemudian, Hana menerima email dari penerbit kecil yang tertarik dengan draft novelnya. Ia tidak langsung sukses, tapi untuk pertama kalinya, ia tidak lagi takut gagal. Di meja kerja kecilnya di rumah, ia mengambil buku catatan yang dulu ia temukan dan menulis satu kalimat baru. \"Kalau kamu membaca ini 20 tahun dari sekarang dan masih takut mencoba… JANGAN BUANG-BUANG WAKTU LAGI.\"\n\nSelesai.\n","n":0.036}}},{"i":68,"$":{"0":{"v":"Handbook","n":1}}},{"i":69,"$":{"0":{"v":"Rust","n":1},"1":{"v":"\n\n## Setup\n\n- untuk install rust cukup mudah, cukup pakai `rustup`\n- kalau install satu persatu pastikan `gcc` terinstall, lalu install `rustc` dan `cargo`\n- cargo adalah dependency management, bukan hanya itu cargo juga bisa dipakai untuk build dan run program rust\n  - `cargo new` untuk membuat project\n  - `cargo build` untuk build program rust dan akan membuat file executable di `target/debug`\n  - `cargo run` untuk build dan running program rust, tapi cargo tidak akan melakukan rebuild jika tidak ada program yang berubah\n  - `cargo check` untuk mngecek code dan memastikan code bisa di compile tapi gak memproduce file executable\n    - command ini bermanfaat untuk mengecek secara cepat dibandingkan melakukan `build`\n  - `cargo build --release` untuk melakukan release ketika program sudah selesai.\n    - command ini akan melakukan optimisasi dan akan membuat executable file di `target/release`\n- lalu apa bedanya `rustc` dan `cargo`\n  - untuk program yang simple cargo tidak jauh berbeda dengan rustc, tapi ketika kita membuat project yang banyak dependency ini akan sangat membantu\n\n## Coding\n\n- untuk membuat variable gunakan `let`\n- by default variable di rust itu immutable, \n  - artinya ketika kita sudah memberikan nilai ke valu maka value tidak bisa diubah\n- untuk membuat variable menjadi mutable, gunakan `mut` sebelum variable name\n\n```rust\nlet apples = 5; // immutable\nlet mut bananas = 5; // mutable\n```\n\n- untuk `associated function` gunakan `::`\n  - kalau di golang pake `.` String.new() kalau dirust String::new()\n- untuk melakukan import dengan menggunakan keyword `use` di awal program\n  - sebagai contoh `std::io`, memiliki `stdin()`, didalamnya ada `read_line`\n    - maka penggunaannya `io::stdin().read_line(&mut guess).exepect(\"Failed to read line\")`\n- tanda `&` mengindikasikan kalau ini adalah reference\n  - Reference yang tidak dapat diubah (&T): Ini memungkinkan Anda untuk membaca nilai tanpa mengubahnya.\n  - Reference yang dapat diubah (&mut T): Ini memungkinkan Anda untuk mengubah nilai yang direferensikan.\n- yang menarik dari sini, rust memaksa kita untuk memberikan result pada function stdin, melalui expect, `Result` ini bersifat enumeration `ok` dan `error`, jika error maka akan menampilak pesan yang ada pada kolom expect\n- `crate` adalah collection dari source code rust,seperti go package\n  - sebelum memulai menggunakan function yang ada di crate kita perlu menulis dependencies \n- carg memiliki mekanisme untuk memastikan kita bisa rebuild artifak yang sema setiap waktu\n  - cargo akan menggunakan versi dari dependensi yang sudah di lock, menggunakan `cargo.lock`\n- dalam penamaan variable rust mengizinkan untuk melakukan shadowing\n\n  ```rust\n    let mut guess = String::new();\n\n    io::stdin()\n        .read_line(&mut guess)\n        .expect(\"Failed to read line\");\n\n    let guess: u32 = guess\n        .trim()\n        .parse()\n        .expect(\"Please type a number!\");\n  ```\n\n- code diatas diperbolehkan, ada 2 variale lalu variable tersebut diganti typenya dengan menggunakan expression `trim` dan `parse`\n  - `guess` diambil dari variable guest pertama\n  - lalu `trim()` method dari string akan mengeliminasi whitespace\n  - lalu `parse()` yang melakukan convert string ke type lain\n    - yang menariknya method parse ini hanya akan berkerja di character yang secara logika bisa di convert ke number\n    - jadi kalau ada charakter selain number, maka akan terjadi error, maka dari itu diperlukan method `expect()`\n- untuk error handling, rust menyediakan expression `match`, expression ini bisa digunakan untuk menagkap error.\n  - jika sebelumnya `expect()` digunakan untuk menuliskan ekspektasi input, `match` bisa menangkapnya\n  - fungsi `parse` memiliki result dan result pasti berisi `ok` dan `err`\n  - `match` seperti `catch` dibahasa pemrograman lain\n- variable\n  - variable immutable by default\n  - jika mau mutable tambahakan `mut`\n  - variable itu scopenya local, tidak bisa digunakan diluar fn\n  - rust tidak mengizinkan unused variable\n- constant\n  - memiliki cakupan statis, tidak dihapus dari memory selama program berjalan dan bisa diakses dari manasaja didalam module tempat constant itu dideklarasikan atau module lain jika public\n  - nilai dari const harus ditentukan pada waktu kompilasi, jadi tidak bisa di set ketika program sudah berjalan atau selalu immutable\n  - untuk penomoran rust menggunakan convention huruf besar dengan underscore contoh `THREE_HOURS_IN_SECONDS`\n- shadowing\n  - yang menarik dari shadowing adalah kita bisa mengubah value tanpa `mut`\n\n```rust\nfn main() {\n    let x = 5;\n\n    let x = x + 1;\n\n    {\n        let x = x * 2;\n        println!(\"The value of x in the inner scope is: {x}\");\n    }\n\n    println!(\"The value of x is: {x}\");\n}\n```\n\n- kode diatas bisa digunakan untuk mengubah nilai dari `x`, sebelumnya nilai `x` adalah 5, lalu `x` diubah menjadi `x + 1` yaitu 6, lalu `x` diubah kembali didalam inner scope `x * 6` yaitu 12, karena itu didalam scope maka tidak akan mengubah value yang ada di luar scope, jadi jika di print `x` yang diluar scope maka akan tetap `6`\n- Data type\n  - Scalar Types\n    - integers\n      - integer adalah number tanpa fractional component / tanpa pecahan\n        - jadi integer adalah bilangan bulat\n        - integer terdiri dari unsigned dan signed\n          - signed: -1\n          - unsgned: 1 (semua bilangan positif)\n\n            | Length | Signed | Usigned |\n            |--------|--------|---------|\n            | 8-bit\t|i8\t|u8|\n            | 16-bit|i16\t|u16|\n            | 32-bi|t|i32\t|u32|\n            | 64-bi|t|i64\t|u64|\n            | 128-b|it|i128\t|u128|\n            | arch\t|isize\t|usize|\n        \n        - arch ini maksudnya arsitektur dependent, tipedata ini karena ukurannya bergantuk pada arsitektur sistem yang digunakan \n    - floating-point numbers\n    - booleans\n    - characer\n      - di rust charakter ada type berbeda, char dan string. \n        - char: Ini adalah tipe data untuk karakter tunggal. Di Rust, char selalu mewakili satu karakter Unicode Scalar Value, yang mungkin lebih luas daripada hanya ASCII. char didefinisikan menggunakan single quotes, seperti 'a', '1', atau '🎉'.\n        - String atau &str: Ini adalah tipe data untuk string, yaitu urutan karakter. String adalah string yang dapat tumbuh, berubah, dan dimiliki, sementara &str adalah referensi ke string yang ada di tempat lain, biasanya tidak dapat diubah. String didefinisikan menggunakan double quotes, seperti \"hello\" atau \"world\".\n  - Compound Types\n    - tuples\n      - tipe data komposit yang dapat mentimpan sekumpulan nilai dengan tipe berbeda. contoh\n  \n        ```rust\n        fn main() {\n            let tup = (500, 6.4, 1);\n\n            let (x, y, z) = tup;\n\n            println!(\"The value of y is: {y}\");\n            println!(\"The value of z is: {z}\");\n            println!(\"The value of x is: {x}\");\n\n            // index\n            let x = tup.0;\n            let y = tup.1;\n            let z = tup.2;\n                    \n            println!(\"The value of y is: {y}\");\n            println!(\"The value of z is: {z}\");\n            println!(\"The value of x is: {x}\");\n        }\n        ```\n    - array\n      - ini sama seperti array pada bahasa lain, tapi bedanya array gak bisa berbeda type\n- Function\n  - tidak ada yang berbeda sama seperti bahasa lain, bedanya return value di rust tidak perlu keyword return seperti golang `return`\n- Control Flow\n  - if expression\n    - if expression bisa digunakan berbarengan dengan let\n    \n    ```rust\n    fn main() {\n        let condition = true;\n        let number = if condition { 5 } else { 6 };\n\n        println!(\"The value of number is: {number}\");\n    }\n    ```\n  - loops\n    - loop\n      - loop ini adalah basic looping dari rust, yang menariknya loop di sini bisa dibuat lable\n        - loop label dimulai dengan single quote, contoh codenya\n            \n            ```rust\n            fn main() {\n                let mut count = 0;\n                'counting_up: loop {\n                    println!(\"count = {count}\");\n                    let mut remaining = 10;\n\n                    loop {\n                        println!(\"remaining = {remaining}\");\n                        if remaining == 9 {\n                            break;\n                        }\n                        if count == 2 {\n                            break 'counting_up;\n                        }\n                        remaining -= 1;\n                    }\n\n                    count += 1;\n                }\n            }\n            ```\n    - while\n      - dengan while kita bisa menambahkan kondisi\n      - kodisinya berupa true or false\n    - for\n","n":0.029}}},{"i":70,"$":{"0":{"v":"Golang","n":1}}},{"i":71,"$":{"0":{"v":"5 Custom Metrics Dengan Promteheus","n":0.447},"1":{"v":"\n```go\npackage middleware\n\nimport (\n    \"strconv\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/prometheus/client_golang/prometheus\"\n    \"github.com/prometheus/client_golang/prometheus/promauto\"\n)\n\nvar (\n    dflBuckets = []float64{300, 1200, 5000}\n)\n\nconst (\n    reqsName           = \"requests_total\"\n    latencyName        = \"request_duration_milliseconds\"\n    patternReqsName    = \"pattern_requests_total\"\n    patternLatencyName = \"pattern_request_duration_milliseconds\"\n)\n\nvar (\n    requestTotal = promauto.NewCounterVec(\n        prometheus.CounterOpts{\n            Namespace: \"core\",\n            Name:      reqsName,\n            Help:      \"How many HTTP requests processed, partitioned by status code, method and HTTP path.\",\n        },\n        []string{\"code\", \"method\", \"path\"},\n    )\n)\n\nfunc APMPrometheus() gin.HandlerFunc {\n    return func(c *gin.Context) {\n\n        c.Next()\n\n        status := strconv.Itoa(c.Writer.Status())\n        requestTotal.With(prometheus.Labels{\"code\": status, \"method\": c.Request.Method, \"path\": c.FullPath()}).Inc()\n    }\n}\n\n```\n\n","n":0.118}}},{"i":72,"$":{"0":{"v":"4 Setup Golang CI","n":0.5},"1":{"v":"\n#go #linter\n\nLinter sangat membantu untuk melakukan standarisasi code.\nMereka juga bisa mengecek jika ada kode yang tidak efektif atau bugs kecil.\n\nCara setupnya cukup mudah\n\n- Windows & Linux\n\n\tuntuk windows bisa gunakan git bash agar bisa menggunakan `curl`.\n\n\t```bash\n\t\t# binary will be $(go env GOPATH)/bin/golangci-lint\n\t\tcurl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.43.0\n\n\t\tgolangci-lint --version\n\t```\n\n- Mac\n\n\t```bash\n\t\tbrew install golangci-lint\n\t\tbrew upgrade golangci-lint\n\t```\n\nInformasi lebih lanjut bisa cek di [https://golangci-lint.run/usage/install/](https://golangci-lint.run/usage/install/).\n","n":0.125}}},{"i":73,"$":{"0":{"v":"3 Build Image Dengan Docker","n":0.447},"1":{"v":"\n#go #docker\n\n```Dockerfile\nFROM golang:1.17 as build\nWORKDIR /app\nADD . .\nRUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags \"-static\"' -o main .\nCMD [\"go\", \"run\", \"main.go\"]\n\nFROM gcr.io/distroless/base-debian10 as production\nCOPY --from=build /app/main /\nEXPOSE 8080\n\nCMD [\"/main\"]\n```\n\n- `FROM golang:1.17 as build`\n\t\n\tbuild akan dialankan pada golang versi1.17, versi bisa disesuaikan dengan versi golang saat ini.\n\n- `WORKDIR /app`\n\n\tBuat folder /app sebagai working directory \n\n- `ADD . .`\n\n\tcopy source code kita dengan `ADD . .`\n\n- `RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -ldflags '-extldflags \"-static\"' -o main .`\n\n\tbuild source code hingga menjadi binary dan filenya nanti akan bernama main\n\n- `FROM gcr.io/distroless/base-debian10 as production`\n\n\tselanjutnya ambil image minimal menggunakan distroless base image.\n\tinfo selanjutnya bisa dibaca disini [https://github.com/GoogleContainerTools/distroless](https://github.com/GoogleContainerTools/distroless).\n\n- `COPY --from=build /app/main /`\n\n\tlalu copy binary apliasi yang sudah dibuat sebelumnya.\n\n- `COPY --from=build /app/main /`\n\n\tcopy binary dari build stage ke root\n  \n- `EXPOSE 8080`\n\n\texpose 8080\n\n- `CMD [\"/main\"]`\n\n\truning command `/main`\n","n":0.085}}},{"i":74,"$":{"0":{"v":"2 Membuat HTTP Server","n":0.5},"1":{"v":"\n#go\n\nAda banyak cara dalam membuat HTTP Server pada golang.\nKita bisa menggunakan standard libary golang `net/http` atau selain itu. seperti:\n\n- chi\n- mux\n- gin\n- dll\n\n### Standard Library\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar (\n\tport            = flag.Int(\"port\", 8080, \"http port to listen on\")\n\tshutdownTimeout = flag.Duration(\"shutdown-timeout\", 30*time.Second,\n\t\t\"shutdown timeout (5s,5m,5h) before connections are cancelled\")\n)\n\nfunc main() {\n\tflag.Parse()\n\n\thttp.HandleFunc(\"/info\", func(w http.ResponseWriter, r *http.Request) {\n\t\tlog.Printf(\"===================================================\")\n\t\tlog.Printf(\"Query-string: %s\", r.URL.RawQuery)\n\t\tlog.Printf(\"Path: %s\", r.URL.Path)\n\t\tlog.Printf(\"Method: %s\", r.Method) // type method yang diterima \n\t\tlog.Printf(\"Host: %s\", r.Host)\n\n\t\tfor k, v := range r.Header { // baca header\n\t\t\tlog.Printf(\"Header %s=%s\", k, v)\n\t\t}\n\n\t\tif r.Body != nil { // baca body / payload data\n\t\t\tbody, _ := ioutil.ReadAll(r.Body)\n\t\t\tlog.Printf(\"Body: %s\", string(body))\n\t\t}\n\t\tlog.Printf(\"===================================================\")\n\n\t\tw.WriteHeader(http.StatusAccepted)\n\t})\n\n\tport := 8080\n\ts := &http.Server{\n\t\tAddr:           fmt.Sprintf(\":%d\", port),\n\t\tReadTimeout:    10 * time.Second,\n\t\tWriteTimeout:   10 * time.Second,\n\t\tMaxHeaderBytes: 1 << 20,\n\t}\n\t\n\tc := make(chan os.Signal, 1)\n\tsignal.Notify(c, syscall.SIGINT, syscall.SIGTERM)\n\n\tgo func() {\n\t\tlog.Printf(\"Listening on port :%d\\n\", port)\n\t\tif err := s.ListenAndServe(); err != nil {\n\t\t\tif err != http.ErrServerClosed {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tsig := <-c\n\tlog.Printf(\"shutting down: %+v\", sig)\n\n\tctx, cancel := context.WithTimeout(context.Background(), *shutdownTimeout)\n\tdefer cancel()\n\n\tif err := s.Shutdown(ctx); err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```\n","n":0.082}}},{"i":75,"$":{"0":{"v":"1 Idiomatic","n":0.707},"1":{"v":"\n#go\n\n### Gunakan gofmt\n\n[gofmt](https://pkg.go.dev/cmd/gofmt) adalah program untuk formating digolang.\nPastikan selalu ada disetiap code editor yang digunakan.\n\n#### VSCode\n\nLink: \n- [https://code.visualstudio.com/docs/languages/go](https://code.visualstudio.com/docs/languages/go)\n\n#### Vim\n\nLink:\n- [https://github.com/fatih/vim-go/](https://github.com/fatih/vim-go/)\n\n### Buat nama receiver tetap pendek\n\n```go\ntype User struct {\n\tName string\n\tIsActive bool\n}\n\n// gunakan\nfunc (u User) Activated() {}\n\n// jangan gunakan\nfunc (user User) Activated() {}\nfunc (self User) Activated() {}\nfunc (this User) Activated() {}\n```\n\nAktifkan [golangci-lint](https://github.com/golangci/golangci-lint) dengan [revive](https://revive.run/docs) untuk dapat pengecekan [receiver-naming](https://revive.run/r#receiver-naming).\n\n### Memberikan nama package yang sesuai\n\nPenamaan package sebaiknya sesuai dengan nama directory atau fungsi dari package tersebut.\n\n- Fungsi: Implementasi elasticsearch ,Dir: /elasticsearch\n\n```go\npackage elasticsearch\n```\n\n- Fungsi: Membuat order pesanan, Dir; /order\n\n```go\npackage order\n```\n\n### Kelompokan import sesuai asalnya\n\nAda tiga bagian pada setiap import dan urutkan sesuai dengan asalnya, jangan urutkan sesuai abjad. Contoh\n\n```go\nimport (\n\t// 1. Untuk standard library\n\t\"context\"\n\n\t// 2. Untuk external dependency yang digunakan\n\t\"go.opentelemetry.io/otel\"\n\n\t// 3. Untuk internal code yang kita atau tim kita tulis sendiri\n\t\"github.com/zeihanaulia/my-project/internal\"\n)\n```\n\n### Gunakan nama pendek untuk scope yang terbatas\n\nNama pendek seperti 1 karakter huruf hanya boleh digunakan pada scope terbatas.\nMisalnya seperti pada function for.\n\n```go\nfor i:=0; i<5; i++ {}\n```\n\nsisanya berikan nama yang jelas sesuai maknanya.\n\n### Context harus menjadi parameter pertama\n\nAda aturan pada penggunaan context:\n\n1. Gunakan context sebagai parameter pertama pada function\n\n\t```go\n\t// Boleh\n\tfunc Create(ctx context.Context, args entity.Order) {}\n\n\t// Tidak boleh\n\tfunc Create(args entity.Order, ctx context.Context) {}\n\t```\n\n2. Jangan simpan context sebagai field dalam struct \n   \n\t```go\n\t// Tidak boleh\n\ttype User struct {\n\t\tctx context.Context\n\t\tName string\n\t}\n\t```\n\n### Return diawal\n\nDalam setiap function yang mengembalikan nilai seharusnya return diawal.\n\n```go\n// Tidak boleh dilakukan\nfunc ParseValue(value Value) (string, error) {\n\tif !value.MustBeTrue {\n\t\treturn \"\", fmt.Errorf(\"must be true\")\n\t} else {\n\t\tif value.Message == \"\" {\n\t\t\treturn \"\", fmt.Errorf(\"value must be set\")\n\t\t} else {\n\t\t\tif value.Priority == 0 {\n\t\t\t\treturn \"\", fmt.Errorf(\"priority must be set\")\n\t\t\t}\n\n\t\t\treturn fmt.Sprintf(\"%d %s\", value.Priority, value.Message), nil\n\t\t}\n\t}\n}\n```\n\nMeskipun code diatas berjalan dengan benar, tapi secara bentuk tidak boleh dilakukan. \nSebaiknya seperti ini.\n\n```go\n// Tidak boleh dilakukan\nfunc ParseValue(value Value) (string, error) {\n\tif !value.MustBeTrue {\n\t\treturn \"\", fmt.Errorf(\"must be true\")\n\t} \n\n\tif value.Message == \"\" {\n\t\treturn \"\", fmt.Errorf(\"value must be set\")\n\t} \n\n\tif value.Priority == 0 {\n\t\treturn \"\", fmt.Errorf(\"priority must be set\")\n\t}\n\n\treturn fmt.Sprintf(\"%d %s\", value.Priority, value.Message), nil\n}\n```\n","n":0.057}}},{"i":76,"$":{"0":{"v":"Book Summaries","n":0.707}}},{"i":77,"$":{"0":{"v":"Youtube","n":1}}},{"i":78,"$":{"0":{"v":"The Super Mario Effect Tricking Your Brain into Learning More","n":0.316},"1":{"v":"\nLink: <https://www.youtube.com/watch?v=9vJRopau0g0>\n\n## Summary\n\nDalam presentasi ini, Mark Rober berbicara tentang prinsip \"Super Mario Effect\" yang dapat membantu seseorang mengatasi rasa takut akan kegagalan dan meningkatkan kemampuan belajar. Dengan memfokuskan pada tujuan akhir yang menarik, seseorang dapat melepaskan rasa takut akan kegagalan dan belajar lebih alami. Mark juga menekankan bahwa kegagalan adalah bagian dari proses belajar dan sukses, dan bahwa sikap bermain game seperti dalam Super Mario dapat membantu seseorang memperbaiki diri dan memecahkan masalah dalam kehidupan nyata. Dalam presentasi ini, Mark juga menyajikan contoh dari kehidupannya sendiri dan bagaimana prinsip Super Mario telah membantunya mencapai kesuksesan.\n\n## Problem & Solution\n\nPada video itu, Ada problem yang dijelaskan yaitu \"fear of failure\" atau ketakutan akan kegagalan. Masalah ini dapat menghambat proses pembelajaran dan membuat seseorang ragu-ragu dalam menghadapi tantangan ke depan.\n\nSolusi yang dijelaskan dalam video tersebut adalah dengan mengubah cara pandang terhadap proses pembelajaran dan fokus pada tujuan akhir yang menarik, sehingga ketakutan akan kegagalan bisa dihilangkan dan pembelajaran dapat menjadi lebih alami. Selain itu, video juga memberikan contoh tentang bagaimana menghadapi kegagalan dengan cara yang lebih konstruktif, yaitu dengan menggunakan analogi permainan video untuk merangkul kegagalan sebagai bagian dari proses belajar dan merencanakan cara untuk mencoba lagi dan lebih baik ke depannya.\n\n## Takeaways\n\n- Menjadi terlalu fokus pada kesuksesan dan mencoba menghindari kegagalan dapat membuat proses pembelajaran menjadi lebih sulit. Dengan memfokuskan diri pada tujuan akhir yang menarik, rasa takut akan kegagalan seringkali dapat dihilangkan dan pembelajaran akan terasa lebih alami.\n\n- Kita seringkali berharap bahwa kehidupan akan selalu seperti gambaran atas, tetapi kehidupan sebenarnya lebih mirip dengan gambaran bawah. Kegagalan dan rintangan yang kita hadapi sebenarnya merupakan bagian penting dari proses belajar dan tumbuh.\n\n- Terkadang kita harus belajar untuk memandang tantangan hidup seperti bermain game. Dengan berfokus pada tujuan akhir dan melihat setiap kegagalan sebagai kesempatan untuk belajar dan mencoba lagi, kita dapat membangun keterampilan dan kepercayaan diri.\n\n- Kegagalan bukanlah tanda bahwa kita tidak cukup baik atau cerdas. Sebaliknya, kegagalan merupakan kesempatan untuk belajar dan tumbuh. Kebanyakan pencapaian yang berarti dalam hidup kita berasal dari banyak kegagalan yang kita alami sebelumnya.\n\n- Prinsip yang dijelaskan di atas dapat diterapkan pada berbagai aspek kehidupan, baik itu dalam pendidikan, hubungan, atau pencapaian profesional. Semua orang akan memiliki cara yang berbeda-beda dalam menerapkannya dalam kehidupan mereka, tetapi prinsip ini memiliki potensi universal untuk membantu kita mencapai kesuksesan.\n\n## Transcript\n\nTranslator: Jeesun Youn Reviewer: Lisa Thompson\nAbout a year ago, I asked my YouTube followers to play a simple computer programming puzzle that I made with a buddy.\nThe object of the puzzle was to get your car across the maze by arranging these code blocks\nthat represent typical computer programming operations, such as if-else statements and while loops.\nOnce you thought you had a good code, you would hit Run, and your car would move based on the commands you had in the program.\nI asked my YouTube followers to play it because I said I wanted to prove that anyone from any background could learn to code.\nFifty thousand of them took the challenge and attempted the puzzle.\n\nBut the truth was that I didn't actually care about proving that anyone could learn to code.\nWhat they didn't know is that we actually randomly served up two slightly different versions of the puzzle.\nIn one version, if you hit Run and you weren't successful, you didn't lose any of your starting 200 points.\nWe showed you this message.\n\n[Please try again.]\nHowever, in the other version, if you hit Run and again you weren't successful,\nwe showed this slightly different message, stating that you lost five points from your starting 200 points.\nThat was the only difference. In one version, if you failed, we simply took away five no-value-in-the-real-world,\nno-one-will-ever-see-these, completely meaningless, fake internet points.\n(Laughter)\n\nThat minor difference is crucial to keep in mind for the results I'm about to show you from the 50,000 data points we collected.\nFor those who were penalized for failed attempts, their success rate was around 52%.\nFor those who were not penalized, their success rate was 68%.\nThat statistically significant delta of 16% was really surprising and almost seemed too hard to believe\nuntil we looked at another piece of data that we collected, which was attempts to solve before finding success.\n\nIt's shown in orange right here. So, those who didn't see failing in a negative light nearly had two and a half times more attempts to solve the puzzle.\nAs a result, naturally, they saw more success and therefore learned more. So if you think about that and sort of unpack these results,\nthe trick to learning more and having more success is finding the right way to frame the learning process.\nAnd this observation seemed really profound to me. It made me wonder, What if you just frame the learning process in such a way\nthat you did not concern yourself with failure, how much more successful could you be, how much more could you learn?\nThe next thought was that if this is a real effect, clearly there must be some evidence for this in real life.\n\nIt made me think of toddlers.\nThat's my boy; I helped make that.\n(Laughter)\n\nThey are constantly trying new things, and they certainly aren't concerned with failure.\nWhen my son learned to walk, he didn't think about how dumb he might look if he fell down,\nand as his parents, we didn't punish him if he wasn't successful either.\nThe focus was always on the end goal, and we celebrated the successes with him.\nAs a result of constantly failing and trying and discovering new things during that phase of our life,\nwe discover so many more new capabilities within ourselves, and it's not even close to any other time in our life.\nBut maybe using a toddler is sort of cheating because their brains are different than ours.\nTo make the case that perhaps they aren't that different than us, I'd like to tell you about a plumber I first met when I was eight years old.\n\nHe was Italian.\n(Power up sound effect)\n(Laughter)\n\nWhen Super Mario Bros. came out, my friends and I became obsessed - like, we wanted to get to the castle and rescue the beautiful Princess Peach from the evil Bowser. We'd get to school and ask each other, \"Dude, what level did you make it to? Did you pass the game?\"\nWe never asked each other about details on all the different ways we might have died. When it comes to games like this,\nno one ever picks up the controller for the first time and then after jumping into a pit thinks,\n\"I am so ashamed; that was such a failure,\" and they never want to try again, right?\nWhat really happens is they think, \"I've got to remember there's a pit there; next time, I'm going to come out with a little more speed and jump a bit later.\"\nThe focus and the obsession is about beating the game, not how dumb you might look if you get hit by a sliding green shell.\nAnd as a direct result of that attitude of learning from but not being focused on the failures,\nwe got really good, and we learned a ton in a very short amount of time.\nWe were the right side of this graph. This is what I call the Super Mario Effect:\nfocusing on the princess and not the pits to stick with a task and to learn more.\nThis caused me to reflect and realize that there were lots of other examples\nfrom my own personal experience where this attitude of life gamification,\nthis Super Mario Effect led to more success and therefore more learning.\nI have a science YouTube channel where I will sometimes use my engineering skills\nto build things such as the world's largest Super Soaker or the Guinness World Record world's largest Nerf gun.\n(Video) (Screaming)\n\n(Audience) (Laughter)\n(On stage) Mark Rober: Or maybe this snowball machine gun.\n(Video) MR: Ha, ha, ha. Yes!\n(On stage) MR: Fashioned from a leaf blower.\n(Audience) (Laughter)\nThat's my niece.\nThose are my nephews.\n(Laughter)\nI haven't quite figured it out,\nbut when it comes to me, their uncle, they seem to have some trust issues.\n(Laughter)\n\nSo, these builds usually take me about two to three months, but there was one that took me three years.\nBasically, I wanted to make a dartboard where you could get a bullseye every time.\nThe idea was that if you throw a dart, we could track it through the air, and then we'd move the board to sort of catch a bullseye.\n(Laughter)\n\nAnd so, once we did the math, we realized that if we wanted to track the dart for a typical, like, game of darts, typical velocity,\nwe would basically have to both track the dart and move the board in the same amount of time it takes for a human to blink once.\nNo big deal, right?\n\nI'm not going to bore you with all the details and the failures and the setbacks from a lot of metaphorical sliding green shells\nand those pesky Hammerhead Bros, but eventually we figured out it would take something that looks like this,\nwhich is six stepper motors and motion controllers, a Vicon motion capture system with six cameras, and just a ton of tweaking and rewriting the code.\nBut finally, eventually, we arrived here.\n(Applause)\n\nWhat's interesting is when I look back on that process, like, I can honestly say my attitude towards that was the same attitude I had toward, like, rescuing the princess from Bowser.\nLike, of course, each failure and setback sucked; it stung.\nBut it was no different than falling in that pit on Level 8-1, and you're like, \"Argh,\" and you got to go back and try again.\nIt was always like, \"OK, that sucked, but what did we learn from that? What can we do next for it? Let's hit it again.\"\nAnd this concept of life gamification is more than just, like, \"Have a positive attitude\" or \"Never give up\"\nbecause those sort of imply you're having to endure against your true desire to quit.\nI feel like when you frame a challenge or a learning process in the way I'm describing, you actually want to do it.\nIt feels natural to ignore the failures and try again, in the same way a toddler will want to get up and try and walk again or in the same way you want to keep playing Super Mario Bros.\nor in the same way the group on the right had a desire to stick with that puzzle two and a half times longer.\n\nThey weren't getting paid to do that. Nobody was forcing them or watching them.\nIt was just them on their computer, alone in their house. Their outlook made it so they wanted to keep trying and learning.\nThe icing on the cake for the dartboard was I took it on Jimmy Kimmel and challenged him to a game of darts.\nI'll just set this clip up by saying two things. The first is we also had a mode on the board where if your buddy had it and threw a dart, the board would move the other way.\n(Laughter)\n\nAnd the second is that we couldn't get this thing working during rehearsal, and it was just barely kind of creeping along.\nI get up to stand in the elevator, which is the door that moves up before you go down out on stage.\nI look to the right, all six cameras had failed.\nSo my buddy John is feverishly, like, restarting all the cameras as I'm going out onto stage knowing this, and there's, like, four things and bits, and I work up to the dartboard as the sort of grand finale.\nSo just keep that in mind as this clip starts.\nLike, that's where my headspace is. Three freaking years, and it comes down to this moment.\n\n(Video) MR: What you're going to do is give this dart to your buddy, and you're going to challenge him just to, like, hit the board.\nJimmy Kimmel: Just try to hit the board. OK. Alright.\n(Laughter)\nMR: Alright, hot shot. Double or nothing?\nJK: Alright, yeah, yeah, alright. Ready?\n(Laughter)\nOK.\nMR: Alright. And so, then I step up here. JK: This does this automatically?\nMR: That's right. JK: And you built this?\nMR: That's right. I step up.\nHere we go.\n(Cheers) (Applause)\n(On stage) MR: Fake it till you make it.\n(Laughter)\n\nI will say, in all of our testing, literally, we never had a dead-center bullseye\nas much as that one right there. So, like, after that, I haven't even touched the board since.\nI'm like, \"I'm so done with it.\"\n(Laughter)\n\nAnd I really believe that if you reframe, like, the challenges,\nit can make all the difference.\nI have a simple thought experiment to sort of showcase this.\nLet's say I gave you a test and it had instructions on it that you would carry out,\nand to do that, it had sort of buttons like this.\nAnd the instructions would say something like, \"Push button 3 for 5 seconds\" and then, \"Push button 6 for 1 second,\" then, \"Push buttons 3 and 5 for 6 seconds,\" and so on.\nAnd unless you carried out the instructions on page one exactly, you couldn't see the other 32 pages of the test.\nHow much would I have to pay you to take that test for an hour?\nNow suppose I change the word \"test\" here to \"game,\"\nand I rotated this, and for the input device, I shrunk the buttons and moved them here,\nand I gave it a cool paint job and maybe different button styles.\nAnd then instead of using words, I represented the tasks you needed to accomplish visually like this.\n\nNote the output is the exact same:\nyou have to push these buttons in a very specific manner to move on to the next page or level, as it were.\nNow picture it's 1986. How much would you pay me to take this test just for an hour?\nIf you have a very bad imagination, here's a hint to the right answer.\nI know. I was there.\n(Video) Boy: Nintendo!\n(Crying)\nOh, Dad, thank you.\nThank you!\nDad: Don't come and hug me, go play with it!\nBoy: (Crying)\n(Audience) (Laughter)\n(On stage) MR: That has to be the greatest YouTube clip of all time.\n(Laughter)\n\nSo, as a science YouTuber, sometimes I feel people have framed the act of learning science in a negative way.\nIt's been taught poorly, so it feels scary to them.\nIt feels something more like this.\nAnd my approach is to take the same physics lessons you might have hated and to try and sort of trick you into learning something through something cool: basically to go from this to this.\nSo for example, in this video, I made a hot tub with liquefied sand.\nAnd this is another one of my nephews with unexplained trust issues.\n(Laughter)\n\nI explain in the video that it's a fluidized bed, and then we talk about the principle of buoyancy and how it makes the whole thing work,\nand I use several examples, like, you know, the blow-dryer with a ping-pong ball like this.\nI like to think my approach to science is similar to Velociraptor hunting patterns.\nSo, I get people to come in with something cool and amazing like the sand hot tub, and then when they least expect it -\n\n(Video) (Music)\n(Growling)\nRobert Muldoon: Clever girl.\n(On stage) MR: Admittedly, the analogy breaks down a little bit right there at the end.\n\nBut by reframing the learning process and focusing on the cool end goal, the fear of failure is often taken off the table, and learning just comes more naturally.\nI'll close with this thought. Someone came up with this cartoon, and I totally love it.\nThis is so true, but often in life we tell ourselves that the top version is what we want;\nthat's what we expect. But then something happens. Maybe it's a really bad grade on a test or a meeting with a client that goes horribly wrong.\nMaybe it's a bad breakup. Maybe we miss a wide-open shot.\nSome kind of green shell hits you. And so, at that first setback or sign of failure, doubt creeps in.\nWe tell ourselves we're not good enough or we're not smart enough. And yet, if the bottom rectangle here is a game where now your bikes crash\nand you have to get your bike across to the flag, it's not, \"Oh, I hit these rocks. I'm just going to leave my bike here.\nI'm not good enough,\" and you quit and walk away. You see that flag to the right,\nand you're like, \"Nah, what did I just learn? OK, next time, I'm going to come out with more speed\nand lift the front of my bike up.\" You want to try it again.\nYou're immediately excited to go for it again. We sort of tell ourselves\nwe want our life's challenges to look like the top one, but that's boring.\nIf that were a real video game or a book or a movie and that went out to the market, it would be a total failure.\nNobody would buy it.\nWhere's the risk and the reward? Where's the challenge?\nThere's no feeling of satisfaction.\nThe bottom picture is real life, and that's not a bug, that's a feature.\nThink about anything that means anything to you in life,\nwhether it's a degree,\na relationship with a friend or someone in your family,\nmaybe a professional accomplishment.\nI can guarantee you it came from something that looks like the bottom\nand not the top:\nfailing and failing and failing and eventually succeeding\nto the point that it now holds value,\njust like the most meaningful high-fives of my adolescence were those when I said,\n\"Dude, I finally beat Bowser last night.\"\nI feel like a lot of the successes in my life\nhave come down to the Super Mario Effect,\nand while framing challenges like this has worked for me,\nof course, results may vary.\nEveryone is going to be different,\nand I don't know exactly what it looks like for you to take this principle\nand map it into your life.\nBut if we got these very real results\nfrom a very different cross-section of very unique people,\nclearly I'm not alone.\nThere's some universal principle at play here.\nBy shifting your focus to the princess\nand treating your life's challenges like video games,\nyou can trick your brain and actually learn more\nand see more success.\nThank you.\n","n":0.018}}},{"i":79,"$":{"0":{"v":"Sinau Bareng Cak Nun dan KiaiKanjeng: BPD DIY, 3 November 2006","n":0.302},"1":{"v":"\n<center>\n    <iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/sgmscPrLHZ8?si=Si6PvijefWbXUZyr\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" referrerpolicy=\"strict-origin-when-cross-origin\" allowfullscreen></iframe>\n</center>\n---\n\nMalam itu, Cak Nun berbicara dengan tema “Bekerja Itu Ibadah.” Dia buka dengan guyon, bilang kalau dia dipaksa pake sorban karena katanya dapat rahmat dari Allah—dulu nggak ikut ngerasain gempa, sekarang jadi ikut kebanting-banting.\n\nCak Nun langsung lempar pertanyaan buat ngebuka: “Jenengan niki wong kuto apa wong deso?” Tapi dia sendiri nyimpulin: meskipun tinggal di kota, jenengan semua tetep punya akar desa. Dan orang desa itu biasanya lebih berani dan tangguh dalam hidup. “Tukang bakso masih bisa jadi bupati, tapi bupati belum tentu bisa jadi tukang bakso.”\n\nTerus dia nyebut-nyebut beberapa orang dari Kiai Kanjeng yang kerja biasa aja. Ada yang kerja di puskesmas, ada tukang laundry, ada guru. Intinya, semua ini kerjaan bener, kerjaan halal. Sementara Cak Nun dan timnya malah kadang nggak jelas, nggak ada gaji tetap. Jadi kalau kamu kerja, digaji, dan jelas, itu udah hebat banget. Jangan sedih sama hidup, katanya, “jen kebangeten nek isih sedih uripe kui.”\n\nCak Nun masuk ke obrolan penting: bahwa ukuran sukses dan gagal itu berbeda antara manusia dan Allah. Kadang apa yang kita anggap enak, ternyata justru bikin rugi. Dan sebaliknya, yang kita kira nyebelin, malah jadi berkah.\n\nDia juga sempat singgung makna Idul Fitri—bukan cuma soal baju baru dan saling maaf-maafan. Idul Fitri itu harus dimaknai dalam level akhlak, bukan cuma hukum. Bahkan menurut Cak Nun, dalam Al-Qur’an nggak ada perintah untuk minta maaf. Yang ada justru disuruh memaafkan. Jadi yang lebih penting adalah jadi orang yang legowo.\n\nTerus dia cerita bahwa dalam Islam ada tiga level: fikih (hukum), akhlak (moral), dan takwa. Hukum itu penting, tapi paling bawah. Akhlak di atasnya. Takwa lebih tinggi lagi. Dan yang paling penting dari semua itu adalah jadi manusia bermoral. Karena kalau orang udah bermoral, dia nggak perlu diatur hukum—dia udah tahu mana yang baik.\n\nCak Nun juga kritik soal gelar-gelar kayak “Kyai,” “Kaji.” Menurut dia, Nabi Muhammad sendiri nggak pernah terlalu bawa-bawa gelar. Yang penting itu bukan dirinya, tapi Allah. Bahkan pas Rasulullah sekarat pun, yang disebut di mulutnya adalah “umatku, umatku,” bukan “saya, saya.”\n\nAbis bahas soal akhlak, Cak Nun mulai masuk ke tema besar: **bekerja itu ibadah**.\n\nDia bilang, dalam hidup ini, ada tiga hal yang gak bisa dipisahin: kerja, ibadah, dan ilmu. Tiga-tiganya harus jalan bareng. Kayak laut sama ombaknya, gak bisa dipisah. Kalo kita kerja tanpa ilmu, bisa ngawur. Kalo ibadah tanpa kerja, jadi beban sosial. Dan kalo cari ilmu tapi gak dipraktikin lewat kerja atau ibadah, ya ilmunya jadi mandek.\n\nCak Nun juga nyindir budaya kita yang kadang terlalu mengagung-agungkan orang yang cuma duduk di masjid, wiridan, salat, tapi gak kerja. Dia cerita soal seorang ibu yang datang ke dia, ngeluh suaminya rajin ibadah tapi gak pernah kerja. Tagihan utang numpuk, dan tiap ada yang nagih, istrinya yang disuruh ngadepin. Itu, kata Cak Nun, bukan ibadah yang bener. Ibadah harus jalan bareng tanggung jawab sosial.\n\nTerus dia bilang, masuk surga itu bisa lewat ibadah, bisa lewat ilmu, bisa lewat kerja. Tapi yang paling tinggi derajatnya justru **pekerja**. Kenapa? Karena orang yang kerja, dia menjalankan amanat Allah pakai seluruh tubuhnya—tangan, kaki, otak, hati. Dan kalau niatnya bener, caranya bener, itu jauh lebih mulia daripada cuma ibadah mahdhah (ritual doang).\n\nDia bahkan nyebut ayat:\n\n> *“Barang siapa ingin bertemu langsung dengan Allah, maka bekerjalah yang baik.”*\n\nMakanya, kata Cak Nun, orang yang bener-bener kerja, itu justru orang yang paling siap buat *bermuwajahah* sama Allah—tatap muka langsung, bukan sekadar cari surga. Karena surga itu cuman bagian kecil dari kehadiran Allah. Kalau lo udah ngerasain kehadiran Allah di kerjaan lo, surga itu udah bonus.\n\nTerus dia bilang lagi, jangan terlalu memuliakan ulama, kiai, termasuk dirinya sendiri. “Aku tak buang-buang awakku, ora penting,” katanya. Soalnya dia ngaku kalah sregep, kalah rajin dari orang-orang yang kerja setiap hari dari subuh sampai sore.\n\nKerja itu ibadah, iya. Tapi bukan sekadar nyari duit. Karena orang yang kerja—entah tukang becak, pegawai bank, guru, petani—kalau dia ikhlas dan lurus, dia juga melayani Allah. Bahkan Allah ikut tanggung jawab atas rezeki anak istrinya. Gak cuman perusahaannya aja.\n\nMakanya, orang yang hidup karena diperintah Allah (bukan karena ego sendiri), dia akan dilindungi dan dijamin sama Allah. Kalo hidupnya gak melibatkan Allah, ya siap-siap tanggung risiko sendiri.\n\nCak Nun juga cerita soal dirinya yang gak pernah pegang ATM, gak paham kartu kredit, dan lebih suka nyimpen duit di kaos kaki. Semua karena dia gak pengen dikontrol sama sistem yang dia gak ngerti. Tapi dia percaya: rezeki cukup kok, asal hidupnya bener.\n\nLanjut, bro.\n\n---\n\nSetelah ngomong soal ibadah dan kerja, Cak Nun pindah ke bagian yang cukup satir tapi dalem: **kita ini sering merasa kekurangan, padahal hidup kita udah super nyaman dibandingin banyak negara lain**.\n\nDia nyebut soal rumah temennya, Mas Toto, yang tinggal di tengah sawah—aksesnya cuma bisa lewat motor, harus jalan kaki dulu dari tempat parkir. Terus ada yang nyeletuk, “Koe dalan ning dunya wae angel koyok ngene, opo meneh ning akhirat?” Itu jadi bahan kontemplasi. Kalau di dunia udah susah, jangan sampai akhirat juga susah.\n\nLalu Cak Nun nyorotin kehidupan rakyat Indonesia. Katanya, kalau dibanding negara lain, terutama negara berkembang seperti Mesir atau Filipina, **rakyat Indonesia hidupnya jauh lebih enak**. Di Kairo, rumah walikota aja kalah sama rumah lurah di Condong Catur. Menteri di sana biasa aja, naik bis kota. Di Indonesia? Luar biasa mewah.\n\nDia juga bahas betapa kuatnya daya beli orang Indonesia, meskipun katanya lagi krisis. Handphone laku keras, bahkan TKW di Hong Kong jadi konsumen nomor satu buat kartu voucher. Bahkan katanya, di sana kartu-kartu top-up dinamain “Bandung Indah,” “Megawati,” “Tari Bali.” Orang luar sampe bingung, ini negara katanya krisis kok belanjanya segitu?\n\nJadi menurut dia, krisis yang sering digembar-gemborkan itu lebih ke propaganda politik atau ketidakwawasan struktural. Sementara di lapangan, rakyatnya tetap makan, tetap rokok, tetap shopping. Dan itu bukan berarti kita hedonis, tapi bukti bahwa Allah masih ngasih berkah di negeri ini, meskipun pemerintahnya sering nggak bener.\n\nTerus masuk ke bagian yang lebih personal dan lucu. Cak Nun cerita pengalaman dia waktu di Belanda selama dua tahun. Dia ngaku nggak pernah bayar tiket kereta, bis, atau trem. Pernah ketangkep, tapi berhasil lolos terus. Dan ketika akhirnya kepergok, dia ngeles dengan cara orang Jawa: ngomong ngawur sampai polisinya bingung, dikira orang gila, akhirnya dilepas. Dia bilang, itu caranya bikin “musuh kehilangan akal satu detik”—dan saat itulah kemenangan terjadi. Satire, tapi nyentil.\n\nAda satu bagian lagi yang cukup dalam, waktu dia cerita soal Rasulullah dan sahabat. Cerita ringan, tapi maknanya dalem banget.\n\nWaktu pengajian malam-malam, Ali bin Abi Thalib selalu duduk di sebelah Rasulullah buat ngelindungin beliau dari perokok—soalnya Abu Bakar dan Umar waktu itu ngerokok oyot-oyotan. Nah, Rasulullah tahu itu, dan pengen ngajarin Ali buat gak terlalu overprotektif. Malam itu, beliau godain Ali.\n\nRasulullah makan kurma dan taruh semua bijinya di depan Ali. Jadi kelihatannya cuma Ali yang rakus. Terus Rasulullah nyeletuk, “Coba lihat siapa yang paling rakus malam ini?” Semua orang nengok ke Ali, karena biji kurma numpuk di depannya.\n\nTapi Ali balas dengan cerdas, dia bilang, “Betul, saya paling rakus karena ada banyak biji kurma di depan saya. Tapi yang lebih rakus adalah yang makan kurma beserta bijinya, sampai gak ada satu pun biji yang tersisa.” Semuanya langsung ketawa, dan Rasulullah pun memuji kecerdasan Ali. Sejak itu Ali dijuluki *Babul Ilmi*—pintu ilmu. Rasulullah sendiri disebut *Madinatul Ilmi*—kota ilmu.\n\nCak Nun pakai cerita ini buat ngingetin: kadang kita terlalu serius liat hidup. Padahal Rasulullah sendiri juga suka guyon, suka santai, tapi tetap penuh makna.\n\nDi bagian penutup, Cak Nun balik lagi nekenin poin utama dari semuanya: **bekerja itu jalan tertinggi untuk nyambung langsung ke Allah**. Jadi, bukan cuma ibadah formal kayak salat, puasa, haji—yang penting itu apakah kita *melibatkan Allah* dalam seluruh hidup kita atau enggak.\n\nDia bilang, banyak orang kerja itu cuma buat nyari duit. Tapi kalau kamu kerja karena disuruh Allah, dan kamu ngerti bahwa yang kamu layani itu sejatinya juga Allah, maka Allah juga ikut tanggung jawab atas hidupmu. Termasuk rezekimu, anakmu sekolah, keluargamu tenang—semua itu ikut dijamin sama Allah. Yang penting, kamu melibatkan Dia.\n\nTerus Cak Nun nanya, “Lo mending hidup sendiri atau disuruh Allah?” Dia milih disuruh, karena kalau disuruh, yang nyuruh ikut tanggung jawab. Kalau jalan sendiri, ya semua tanggung jawab ditanggung sendiri juga. Sama kayak di perusahaan—kalau kamu disuruh ke luar kota sama kantor, pasti tiket, hotel, dan keselamatanmu ditanggung. Tapi kalau kamu jalan sendiri, ya resiko ditanggung sendiri.\n\nNah, dalam hidup juga gitu. Kalau kamu kerja karena Allah nyuruh, kamu nggak akan pernah sendirian. Dan kamu gak bakal takut miskin. Karena bukan perusahaan doang yang jamin kamu, tapi Allah juga.\n\nDia sempat nyentil soal fatwa-fatwa agama dan debat-debat hukum yang ribet. Bagi Cak Nun, dia nggak tertarik ikut ribut soal hukum hari raya, perbedaan pandangan agama, atau aturan-aturan yang ribet. Dia bilang terus terang, “Aku iki ora tanggung jawab karo sopo-sopo, aku mung tanggung jawab karo anak bojoku.” Jadi kalau ditanya pendapatnya soal hal-hal kayak perbedaan hari raya, dia jawab: gak penting. Yang penting itu akhlak, bukan debat hukum yang gak selesai-selesai.\n\nLalu dia bahas soal demokrasi, perda-perda absurd yang suka muncul di daerah, dan bagaimana negara ini sering nuntut rakyat untuk taat tanpa ngasih fasilitas atau keadilan. Dia cerita pernah ditangkap polisi cuma gara-gara jalan rusak, dan dia malah “nangkep balik” polisinya—karena menurut dia, yang salah itu sistem dan aturannya, bukan rakyatnya.\n\nIntinya: rakyat itu gak bisa terus disalahin kalau sistemnya aja gak bener.\n\nTerakhir, dia tutup dengan semangat untuk mencintai Indonesia. Katanya, Indonesia itu kekasihnya, tapi dia gak mau diatur sama negara. Dia lebih milih tunduk sama ilmu dan akhlak daripada tunduk sama aturan negara yang gak masuk akal.\n\nCak Nun juga bilang, teman-teman Kiai Kanjeng itu udah biasa nginep di rumah-rumah pejabat luar negeri, dan rumah lurah di Jogja aja jauh lebih bagus. Dia sampe ngakak sendiri liat banner SCTV soal bantuan gempa, yang malah nyari \"pundi amal SCTV\" kayak orang lagi promosi.\n\nTerus, penutupnya sangat menyentuh. Dia doa buat semua yang hadir—semoga hidupnya ditenangkan, rezekinya cukup, keluarganya diberi perlindungan. Lalu semua ditutup dengan shalawat bersama. Merinding sih bagian akhir ini, karena terasa banget ketulusan dan cintanya ke umat.\n\n---\n\nKesimpulannya?\n\nMenurut Cak Nun, **bekerja itu bukan cuma aktivitas duniawi, tapi jalan langsung menuju Allah**. Asal kita sadar, kerja kita itu untuk kebaikan, kita melibatkan Allah, dan kita nggak lepas dari akhlak, maka hidup kita udah nyambung ke yang Maha Kuasa. Gak perlu gelar-gelar agamis, gak perlu ibadah-ibadah pamer—cukup kerja yang bener, niat yang lurus, dan hidup dengan akhlak.\n\nSelesai.\n","n":0.024}}},{"i":80,"$":{"0":{"v":"How To Stand Out In An Insanely Competitive Tech Market (Ex-Amazon Principal Engineer)","n":0.277},"1":{"v":"\n\nHari ini gue menonton youtube video https://www.youtube.com/watch?v=0kMWWm3BnBQ. Ini dia seorang mantan principal engineer di amazon. Ada beberapa catatan yang gue tangkep dari video dia\n\n1. Identify my niche\n2. Update online presence\n3. Ship Real Projects\n4. Continue learning strategically\n5. Leverage network for referral\n6. Stay interview ready\n\nPada bagian pertama, identify my niche: alih alih lo cuma kasih tau ke recruiter kalau lo pernah pake tools a,b,c sebaiknya ceritakan pengalaman deep diving ke tools tersebut, ini akan menjelaskan atau paling tidak merepresentasikan diri lo punya pengalaman yang dalam atau paham sekali dengan tools tersebut.\n\nPada bagian update online presence juga share artikel yang menunjukan keahlian lo, yang menunjukan kedalam lo terhadap suatu teknologi atau tools. Selain itu pake juga linkedin buat networking. Coba buat connect ke banyak orang disana untuk diskusi yang akhirnya memberikan jalan untuk networking. Mau bagaimanapun networking ini salah satu cara untuk mendapatkan referral.\n\nLalu di bagian Ship Real Projects, alih alih belajar dengan basic app kaya todo list, coba mulai pikirin bikin product / project yang bisa direlease atau dipake orang orang. intinya gak bisa cuma belajar tapi lo gak release projectnya. Mau berapapun usernya ini akan berbeda ceritanya, sesuatu yang bisa lo ceritain dibanding kandidat lain.\n\nPada bagian Continue Learning Strategically, daripada banyak ngikutin tutorial atau banyak certificate, mending check release notes dan ikutin feature terbaru dari setiap tools yang lo pake. Coba pahamin cara kerjanya dan deep dive disana. Kenapa? dengan begini lo bisa lebih paham dan lebih dalam memahami setiap feature yang ada dan ini yang membedakan posisi lo, karena lo menguasai tools ini lebih dalam dari yang lain.\n\nDi bagian Leverage Your Network for Referrals, sebenernya sudah sempat dibahas di bagian update online presence, Disini menekankan bagaimana sebaiknya networking dengan perusahaan yang lo targeting. Mulai dari message dengan sopan, tanya tentang role yang ada disana, culture team, challenges atau project menarik yang sedang dikerjakan dan akhirnya  ada gak referral wkwkwkwk.  \n\nTerakhir Stay Interview-Ready, ini paling penting. Percuma kalau udah ngelakuin hal diatas dan dapet referral tapi pas di interview ngang ngong ngang ngong wkwkwkwk. Jangan anggap remeh interview karena kondisinya kita sedang di test untuk masuk team mereka. Gimana caranya tetap terlihat professional dan siap dengan kondisi dan pertanyaan apapun. cara satu satunya ya dengan latihan, latihan dan latihan. Anggep interview ini kaya lo pitching dan menawarkan jasa terbaik lo agar bisa join team mereka.\n\nDiluar dari interview dan mendapatkan pekerjaan, bagian \"Ship Real Projects\" ini bisa jadi oportuniti menarik. ketika kita shipping projects dan projects itu menghasikan sesuatu yang bernilai ekonomi, ini bisa jadi sumber income tambahan atau bahkan jadi sumber income utama dan malah memberikan lapangan pekerjaan.","n":0.048}}},{"i":81,"$":{"0":{"v":"The Devops Handbook","n":0.577},"1":{"v":"\n## Outcomes Devops\n\nThis enables organizations to create a safe system of work, where small teams are able to quickly and independently develop, test, and deploy code and value quickly, safely, securely, and reliably to customers. This allows organizations to maximize developer productivity, enable organizational learning, create high employee satisfaction, and win in the marketplace.\n\n## Awal cerita\n\nAwal revolusi devops dimulai pada tahun 1980an dengan adanya Manufacturing Revolution. By adopting Lean principles and practices, manufacturing organizations dramatically improved plant productivity, customer lead times, product quality, and customer satisfaction, enabling them to win in the marketplace.\n\nSebelum revolusi, waktu pesanan rata-rata pabrik manufaktur adalah enam minggu, dengan kurang dari 70% pesanan yang dikirim tepat waktu. Namun, setelah diterapkannya praktik Lean secara luas, waktu pesanan rata-rata berkurang menjadi kurang dari tiga minggu, dan lebih dari 95% pesanan dikirim tepat waktu. \n\nOrganisasi yang tidak menerapkan praktik Lean kehilangan pangsa pasar, dan banyak yang bangkrut. Hal ini menunjukkan betapa pentingnya penerapan praktik Lean dalam meningkatkan efisiensi dan daya saing industri manufaktur.\n\n![(Source: Adrian Cockcroft, “Velocity and Volume (or Speed Wins),” presentation at FlowCon, San Francisco, CA, November 2013.)](assets/20230421100423.png)\n\nJadi problem apa yang coba diselesaikan oleh devops?\n\n## THE PROBLEM: SOMETHING IN YOUR ORGANIZATION MUST NEED IMPROVEMENT\n\nOrganisasi yang tidak dapat melakukan perubahan production dengan cepat dan tidak dapat melakukan rilis ratusan atau ribuan perubahan ke production per hari akan menghadapi ketidakmampuan bersaing dalam pasar yang memerlukan waktu development yang cepat, tingkat layanan yang tinggi, dan eksperimen yang tak henti-hentinya, yang disebabkan oleh konflik utama dalam organisasi teknologi mereka.\n\n### THE CORE, CHRONIC CONFLICT\n\nKonflik utama dalam organisasi teknologi adalah antara tim dev (development) yang ingin membuat perubahan dengan cepat dan sering, dan tim operasi (operations) yang ingin menjaga stabilitas dan keandalan sistem. \n\nKonflik ini terjadi karena tim dev harus membuat perubahan untuk memenuhi kebutuhan bisnis yang terus berubah, sedangkan tim operasi harus memastikan bahwa perubahan tersebut tidak mengganggu operasi yang sedang berjalan dan tetap menjaga stabilitas sistem.\n\nUntuk menyelesaikan konflik ini, organisasi harus menerapkan prinsip-prinsip DevOps yang memungkinkan kolaborasi antara kedua tim dan mengotomatiskan proses delivery software agar lebih cepat dan aman.\n\nDr. Eliyahu M. Goldratt, salah satu pendiri gerakan manajemen manufaktur, menyebut konfigurasi semacam ini sebagai \"konflik utama yang kronis\" - di mana pengukuran dan insentif organisasi di berbagai silo menghalangi pencapaian tujuan global organisasi. \n\nKonflik ini menciptakan spiral penurunan yang begitu kuat sehingga mencegah pencapaian hasil bisnis yang diinginkan, baik di dalam maupun di luar organisasi TI.\n\nKonflik kronis ini seringkali menempatkan pekerja teknologi dalam situasi yang mengarah pada kualitas software dan layanan yang buruk, serta hasil pelanggan yang buruk, serta kebutuhan harian untuk solusi sementara, pemadam kebakaran, dan heroisme, baik di Manajemen Produk, Development, QA, Operasi TI, atau Keamanan Informasi.\n\n### DOWNWARD SPIRAL IN THREE ACTS\n\nDownward spiral adalah suatu kondisi atau situasi di mana suatu masalah atau konflik semakin memburuk seiring waktu, dan akhirnya mengakibatkan dampak negatif yang semakin parah dan sulit untuk diperbaiki. \n\nIT Operations yang memiliki tujuan untuk menjaga aplikasi dan infrastruktur agar tetap berjalan sehingga organisasi dapat memberikan nilai kepada pelanggan. Namun, banyak masalah yang dihadapi karena aplikasi dan infrastruktur yang kompleks, buruk dalam dokumentasi, dan sangat rapuh. \n\nIni disebut \"technical debt\" yang sering diatasi dengan workaround, namun sulit untuk diperbaiki karena kekurangan waktu. Hal ini sangat mengkhawatirkan karena sistem yang paling rentan terhadap kegagalan adalah sistem yang paling penting dalam menghasilkan pendapatan atau proyek kritis. \n\nKetika perubahan-perubahan terjadi pada sistem-sistem ini dan gagal, maka hal ini dapat membahayakan janji-janji organisasi yang paling penting, seperti ketersediaan bagi pelanggan, tujuan pendapatan, keamanan data pelanggan, pelaporan keuangan yang akurat, dan lain sebagainya.\n\nDalam downward spiral act kedua, seseorang harus menggantikan \"broken promise\" - bisa saja seorang manajer produk yang berjanji untuk menambahkan fitur yang lebih besar, atau seorang eksekutif bisnis yang menetapkan target pendapatan yang lebih tinggi.\n\nKemudian, tanpa memperhatikan kemampuan teknologi atau apa yang menyebabkan kegagalan komitmen sebelumnya, mereka menugaskan organisasi teknologi untuk memenuhi janji baru ini.\n\nSebagai hasilnya, Development diberi tugas dengan proyek mendesak lain yang tak terelakkan membutuhkan pemecahan tantangan teknis baru dan memotong sudut untuk memenuhi tanggal rilis yang dijanjikan, yang semakin menambah hutang teknis kita.\n\nAct ketiga dimulai saat segala hal menjadi sedikit lebih sulit, bit by bit. Semua orang semakin sibuk, pekerjaan semakin memakan waktu, komunikasi menjadi lebih lambat, dan antrean pekerjaan semakin panjang. \n\nSemua orang semakin sibuk, pekerjaan semakin memakan waktu, komunikasi menjadi lebih lambat, dan antrean pekerjaan semakin panjang. Pekerjaan kita semakin terikat, tindakan kecil menyebabkan kegagalan yang lebih besar, dan kita menjadi lebih takut dan kurang toleran terhadap perubahan. \n\nPekerjaan kita semakin terikat, tindakan kecil menyebabkan kegagalan yang lebih besar, dan kita menjadi lebih takut dan kurang toleran terhadap perubahan. \n\nPekerjaan membutuhkan lebih banyak komunikasi, koordinasi, dan persetujuan; tim harus menunggu sedikit lebih lama untuk pekerjaan yang bergantung pada mereka selesai; dan kualitas pekerjaan semakin buruk. Roda mulai berputar lebih lambat dan membutuhkan lebih banyak usaha untuk tetap bergerak.\n\nDan hasilnya. Akan makin menjadi lebih lama. Seperti yang disebutkan oleh Steven J. Spear dalam bukunya, The High-Velocity Edge, dampaknya dapat sangat merusak dan berbahaya, sama seperti penyakit yang merusak tubuh atau kecelakaan yang menghancurkan. Oleh karena itu, penting bagi organisasi untuk memprioritaskan investasi dalam sistem IT yang kuat dan efektif untuk mencegah kerusakan pada kinerja organisasi secara keseluruhan.\n\n## WHY DOES THIS DOWNWARD SPIRAL HAPPEN EVERYWHERE?\n\nIntinya adalah bahwa setiap perusahaan sebenarnya adalah perusahaan teknologi dan hampir setiap keputusan bisnis memerlukan setidaknya satu perubahan IT. Proyek-proyek sangat penting dalam konteks bisnis dan keuangan karena mereka merupakan mekanisme utama untuk perubahan di dalam organisasi. Proyek biasanya didanai melalui pengeluaran modal, dan pemimpin bisnis jauh lebih bergantung pada pengelolaan IT yang efektif untuk mencapai tujuan mereka daripada yang mereka pikirkan. Prinsip DevOps diperlukan untuk mengatasi spiral kehancuran yang terjadi pada organisasi IT.\n\n## Bagaimana memecahkan Spiral Down dengan Devops\n\nDevOps dapat membantu memecahkan masalah dan konsekuensi negatif yang muncul akibat keadaan yang ada saat ini dalam dunia teknologi. Dengan menerapkan DevOps, tim developers dapat bekerja secara mandiri untuk mengimplementasikan fitur-fitur baru, menguji validitasnya di lingkungan yang mirip dengan production, dan melakukan deployment secara cepat, aman, dan terjamin. Hal ini memungkinkan deployment dilakukan pada saat yang rutin dan dapat diprediksi, bukan pada malam hari di akhir pekan, sehingga tidak mengganggu pengguna. \n\nDalam penggunaan DevOps, feedback loop dilakukan secara cepat pada setiap tahap proses sehingga setiap orang dapat melihat efek dari tindakan yang mereka lakukan. Penggunaan automated testing juga memungkinkan developer untuk menemukan kesalahan dengan cepat sehingga memungkinkan perbaikan yang lebih cepat dan juga pembelajaran yang lebih baik. Dengan menggunakan DevOps, masalah dapat diperbaiki secepat mungkin, dan tujuan global menjadi lebih penting daripada tujuan lokal.\n\nDalam pengimplementasiannya, DevOps dapat membuat tim developers bekerja secara mandiri dan aman dalam memasang fitur-fitur yang telah mereka buat ke dalam lingkungan production. Hal ini dapat mempercepat pengiriman fitur baru dan perbaikan kesalahan pada software yang dibuat.\n\nDengan adanya tes otomatis yang cepat dan dilakukan secara terus menerus di lingkungan production, para developers dapat mendeteksi kesalahan mereka dengan cepat, memperbaikinya secara lebih cepat, dan belajar dari kesalahan tersebut. Pada akhirnya, keseluruhan organisasi akan terbebas dari hutang teknis, masalah akan diperbaiki segera setelah ditemukan, dan semua pihak di dalam organisasi akan merasa produktif.\n\nDalam pengaplikasiannya, DevOps juga memanfaatkan teknologi telemetry untuk memonitor kesalahan yang terjadi pada software. Teknologi ini memungkinkan deteksi dan perbaikan kesalahan dengan cepat sehingga semua sistem dan lingkungan production bekerja sesuai dengan rencana dan memberikan nilai tambah bagi pengguna. Selain itu, DevOps juga menggunakan teknik dark launch dalam merilis produk baru dan fitur-fitur penting. Hal ini memungkinkan tim developers untuk menguji dan mengevaluasi fitur secara berkala dan memastikan bahwa fitur tersebut sesuai dengan tujuan bisnis sebelum dirilis ke publik.\n\nDevOps dapat membantu menghindari masalah yang sering terjadi pada saat peluncuran produk baru dan meningkatkan produktivitas tim. Dengan adopsi DevOps, tim dapat bekerja secara mandiri dengan proses pengujian otomatis yang cepat dan terus menerus. Pemantauan terus menerus terhadap lingkungan production dan kode memastikan bahwa masalah dapat terdeteksi dan diperbaiki dengan cepat sehingga peluncuran produk baru menjadi terkontrol, dapat diprediksi, reversibel, dan rendah stres. \n\nDalam penggunaan DevOps, tim juga dapat terus belajar dan memperbaiki proses mereka, sehingga dapat mencegah masalah terulang di masa depan. Dalam penggunaan DevOps, setiap proses development produk diperlakukan seperti eksperimen dan menggunakan metode ilmiah untuk memastikan keberhasilannya.\n\nDevOps membantu dalam menciptakan lingkungan kerja yang produktif, efektif, dan efisien. Dengan melakukan pengujian secara otomatis di lingkungan yang mirip dengan produksi, tim developers dapat menemukan kesalahan dengan cepat dan memperbaikinya secepat mungkin, sehingga tidak ada masalah teknis yang menumpuk. Teknologi seperti pengumpulan data produksi juga memastikan bahwa setiap masalah dideteksi dan diperbaiki dengan cepat, sehingga dapat meminimalkan kerugian yang disebabkan oleh masalah tersebut.\n\nSelain itu, DevOps juga membantu menciptakan lingkungan kerja yang kooperatif dan berbasis kepercayaan. Tim yang bertanggung jawab untuk mencapai tujuan jangka panjang akan terus dipertahankan dan bekerja sama, dan mereka terus mempelajari dan memperbaiki diri. Kultur risiko yang diterapkan juga memotivasi setiap orang untuk berbicara terbuka tentang masalah dan memberikan solusi untuk meningkatkan kinerja tim secara keseluruhan.\n\nsemua orang di organisasi memiliki tanggung jawab penuh terhadap kualitas pekerjaan mereka. Mereka membangun pengujian otomatis ke dalam pekerjaan sehari-hari dan menggunakan ulasan rekan untuk memastikan bahwa masalah ditangani sebelum mereka dapat memengaruhi pelanggan. Proses ini mengurangi risiko dan memungkinkan pengiriman nilai dengan cepat, dapat diandalkan, dan aman, bahkan membuktikan kepada auditor skeptis bahwa organisasi memiliki sistem pengendalian internal yang efektif.\n\nKetika terjadi kesalahan, organisasi melakukan post-mortem yang bebas dari salahkan bukan untuk menghukum siapa pun, tetapi untuk memahami penyebab kecelakaan dan bagaimana mencegahnya di masa depan. Ritual ini memperkuat budaya belajar organisasi. Organisasi juga mengadakan konferensi teknologi internal untuk meningkatkan keterampilan dan memastikan bahwa semua orang selalu mengajar dan belajar.\n\nKarena organisasi peduli pada kualitas, mereka bahkan menyuntikkan kesalahan ke dalam lingkungan produksi mereka sehingga mereka dapat belajar bagaimana sistem mereka gagal secara terencana. Organisasi melakukan latihan terencana untuk melatih kegagalan dalam skala besar, secara acak mematikan proses dan server komputasi di produksi, dan menyuntikkan keterlambatan jaringan dan tindakan jahat lainnya untuk memastikan organisasi semakin tangguh. Dengan melakukan ini, organisasi memungkinkan keandalan yang lebih baik, serta pembelajaran dan perbaikan organisasi.\n\nDalam dunia ini, setiap orang memiliki kepemilikan dalam pekerjaannya, terlepas dari perannya dalam organisasi teknologi. Mereka memiliki keyakinan bahwa pekerjaan mereka penting dan berkontribusi secara berarti terhadap tujuan organisasi, terbukti dengan lingkungan kerja yang rendah tekanan dan keberhasilan organisasi di pasar. Bukti mereka adalah bahwa organisasi memang menang di pasar.\n\n### Beberapa action item\n\n1. Menerapkan pengukuran (telemetry) secara luas dalam kode dan lingkungan produksi untuk mendeteksi masalah secepat mungkin dan memastikan semuanya berjalan sesuai yang diinginkan, sehingga pelanggan memperoleh nilai dari software yang diciptakan.\n\n2. Menggunakan teknik dark launch untuk menguji dan mengembangkan fitur baru sebelum diluncurkan, sehingga peluncuran produk dan fitur dapat menjadi rutin dan lebih terkontrol.\n\n3. Menggunakan fitur toggle atau pengaturan konfigurasi untuk membuat fitur baru terlihat oleh segmen pelanggan yang semakin besar secara otomatis, sehingga perilisan produk menjadi terkendali, terprediksi, dapat dikembalikan, dan rendah stres.\n\n4. Menciptakan tim yang bertanggung jawab untuk mencapai tujuan jangka panjang, serta membentuk budaya eksperimen dan pembelajaran.\n\n5. Membangun tes otomatis dalam pekerjaan sehari-hari dan melakukan ulasan rekan untuk memastikan kualitas kerja, serta melaksanakan post-mortem tanpa menyalahkan untuk meningkatkan pemahaman atas penyebab kegagalan dan cara mencegahnya.\n\n6. Memiliki budaya kolaborasi dan kepercayaan yang tinggi, serta memotivasi orang untuk berbicara tentang masalah dan mengambil risiko dalam menyelesaikan masalah.\n\n7. Menerapkan praktik resiliensi dengan memasukkan kesalahan yang direncanakan ke dalam lingkungan produksi untuk memahami cara sistem gagal secara terencana, melakukan latihan kegagalan berskala besar, serta memasukkan latensi jaringan dan tindakan lain untuk meningkatkan ketahanan organisasi dan pembelajaran.\n\nInti dari semua paragraf adalah untuk menciptakan lingkungan kerja yang produktif, kolaboratif, dan terorganisir dengan baik, di mana setiap orang merasa memiliki tanggung jawab atas kualitas pekerjaannya dan dapat belajar dari kesalahan. Hal ini dapat dilakukan dengan menerapkan praktik-praktik yang efektif dalam development produk dan manajemen risiko secara keseluruhan.\n\n## Bisnis value dari devops\n\nDevOps memberikan nilai bisnis yang signifikan. Dalam kurun waktu 2013 hingga 2016, sebagai bagian dari State Of DevOps Report dari Puppet Labs, yang ditulis oleh Jez Humble dan Gene Kim, kami mengumpulkan data dari lebih dari dua puluh lima ribu profesional teknologi, dengan tujuan untuk lebih memahami kesehatan dan kebiasaan organisasi pada semua tahap adopsi DevOps.\n\nHasil dari pengumpulan data mengejutkan, dimana terungkap bahwa organisasi yang melakukan praktik DevOps dengan kinerja tinggi jauh lebih unggul dari pesaing yang tidak melakukan praktik DevOps dalam beberapa area berikut:\n\n- Metrik throughput\n- Penyebaran kode dan perubahan (tiga puluh kali lebih sering)\n- Waktu pengiriman kode dan perubahan (dua ratus kali lebih cepat)\n- Metrik keandalan\n- Penyebaran produksi (tingkat kesuksesan perubahan enam puluh kali lebih tinggi)\n- Waktu rata-rata untuk memulihkan layanan (168 kali lebih cepat)\n- Metrik kinerja organisasi\n- Produktivitas, pangsa pasar, dan tujuan keuntungan (dua kali lebih mungkin untuk melampaui)\n- Pertumbuhan kapitalisasi pasar (lebih tinggi 50% dalam tiga tahun)\n\nHasil penelitian dari Puppet Labs' State of DevOps Report dari tahun 2013 hingga 2016. Penelitian ini dilakukan untuk memahami kesehatan dan kebiasaan organisasi pada semua tahap adopsi DevOps. Hasil penelitian menunjukkan bahwa organisasi dengan kinerja tinggi yang menggunakan praktik DevOps jauh lebih unggul dibandingkan dengan pesaing mereka yang tidak memiliki kinerja tinggi dalam beberapa area, seperti throughput metrics, reliability metrics, dan organizational performance metrics.\n\nOrganisasi dengan kinerja tinggi lebih lincah dan andal, memberikan bukti empiris bahwa DevOps memungkinkan kita untuk memecahkan konflik inti yang kronis. Mereka mampu melakukan deployment code 30 kali lebih sering, dan waktu yang dibutuhkan untuk berhasil menjalankan produksi adalah 200 kali lebih cepat. Organisasi kinerja tinggi juga lebih mungkin untuk melampaui tujuan keuntungan, pangsa pasar, dan produktivitas dua kali lipat. \n\nSelain itu, organisasi kinerja tinggi memiliki pertumbuhan kapitalisasi pasar 50% lebih tinggi selama tiga tahun dan tingkat kepuasan kerja yang lebih tinggi serta tingkat burnout yang lebih rendah. Mereka juga 2,2 kali lebih mungkin merekomendasikan organisasi mereka sebagai tempat kerja yang bagus. Selain itu, organisasi kinerja tinggi juga memiliki hasil keamanan informasi yang lebih baik, dengan mengintegrasikan tujuan keamanan ke dalam semua tahap proses development dan operasi. Mereka menghabiskan 50% lebih sedikit waktu untuk memperbaiki masalah keamanan.\n\nInti dari section \"THE BUSINESS VALUE OF DEVOPS\" adalah bahwa DevOps dapat memberikan nilai bisnis yang signifikan melalui peningkatan produktivitas, keandalan, dan kecepatan pengiriman, serta pencapaian tujuan keuntungan, pangsa pasar, dan produktivitas yang lebih tinggi. Hasil survei menunjukkan bahwa organisasi yang mengadopsi praktik DevOps secara lebih terampil cenderung mengungguli pesaing mereka dan mencapai keberhasilan yang lebih besar. Dalam hal ini, DevOps juga membantu memecahkan konflik antara agilitas dan keandalan dalam development dan operasi teknologi.\n\n## DEVOPS HELPS SCALE DEVELOPER PRODUCTIVITY\n\nDevOps membantu meningkatkan produktivitas developers dalam skala besar. Saat jumlah developers meningkat, produktivitas individu developers seringkali menurun karena masalah komunikasi, integrasi, dan pengujian yang berlebihan. Namun, DevOps menunjukkan bahwa dengan arsitektur yang tepat, praktik teknis yang tepat, dan norma budaya yang tepat, tim developers kecil dapat dengan cepat, aman, dan independen mengembangkan, mengintegrasikan, menguji, dan mendeploy perubahan ke dalam produksi.\n\nDevOps dapat membantu organisasi besar dengan ribuan developers menjadi produktif seperti startup, dan tidak seperti metode development tradisional yang menambahkan developers saat proyek terlambat yang justru menurunkan produktivitas individu dan keseluruhan.\n\nDalam laporan State of DevOps 2015, tidak hanya mengukur \"jumlah deploy per hari\", tetapi juga \"jumlah deploy per hari per developers\". Laporan ini berasumsi bahwa organisasi high performer mampu meningkatkan jumlah deployment dengan tim yang semakin besar.\n\n![Deployments/day vs. number of developers (Source: Puppet Labs, 2015 State Of DevOps Report.)](assets/20230421104421.png)\n\nPada dasarnya, DevOps membantu meningkatkan produktivitas developers. Ketika jumlah developers meningkat, produktivitas individu seringkali menurun karena adanya overhead komunikasi, integrasi, dan pengujian. DevOps menunjukkan bahwa ketika kita memiliki arsitektur yang tepat, praktik teknis yang tepat, dan norma budaya yang tepat, tim kecil developers dapat dengan cepat, aman, dan mandiri mengembangkan, mengintegrasikan, menguji, dan melakukan perubahan ke produksi. \n\nSebuah laporan State of DevOps pada tahun 2015 meneliti \"deploys per day\" dan juga \"deploys per day per developer.\" Mereka menghipotesiskan bahwa **high performers akan dapat meningkatkan jumlah deployment saat jumlah tim developers bertambah**. Dan kenyataannya memang seperti itu. Pada low performers, deploys per day per developer menurun seiring dengan bertambahnya ukuran tim, tetap konstan untuk medium performers, dan meningkat secara linear untuk high performers. Artinya, organisasi yang mengadopsi DevOps dapat meningkatkan jumlah deploys per day secara linear saat mereka meningkatkan jumlah developers, sama seperti yang dilakukan oleh Google, Amazon, dan Netflix.\n\n## Bagian dari buku the devops handbook\n\nDalam Bagian I, kami menyajikan sejarah singkat tentang DevOps dan memperkenalkan teori dasarnya serta tema-tema kunci dari pengetahuan yang relevan yang mencakup beberapa dekade. Kami kemudian menyajikan prinsip-prinsip tingkat tinggi dari Tiga Cara: Aliran, Umpan Balik, dan Pembelajaran dan Eksperimen Terus Menerus.\n\nBagian II menjelaskan bagaimana dan di mana memulai, dan memperkenalkan konsep-konsep seperti aliran nilai, prinsip dan pola desain organisasi, pola adopsi organisasi, dan studi kasus.\n\nBagian III menjelaskan bagaimana mempercepat Aliran dengan membangun dasar dari pipeline deployment kita: memungkinkan pengujian otomatis yang cepat dan efektif, integrasi terus menerus, pengiriman terus menerus, dan perancangan untuk rilis yang rendah risiko.\n\nBagian IV membahas bagaimana mempercepat dan memperkuat Umpan Balik dengan menciptakan telemetri produksi yang efektif untuk melihat dan menyelesaikan masalah, lebih baik memperkirakan masalah dan mencapai tujuan, memungkinkan umpan balik sehingga Dev dan Ops dapat dengan aman melakukan perubahan, mengintegrasikan pengujian A/B ke dalam pekerjaan sehari-hari kita, dan menciptakan proses tinjauan dan koordinasi untuk meningkatkan kualitas kerja kita.\n\nBagian V menjelaskan bagaimana mempercepat Pembelajaran Terus Menerus dengan membentuk budaya yang adil, mengubah penemuan lokal menjadi perbaikan global, dan menentukan waktu yang tepat untuk menciptakan pembelajaran dan perbaikan organisasi.\n\nTerakhir, di Bagian VI, kami menjelaskan bagaimana mengintegrasikan keamanan dan kepatuhan dengan tepat ke dalam pekerjaan sehari-hari kita, dengan mengintegrasikan kontrol keamanan pencegahan ke dalam repositori dan layanan kode sumber bersama, mengintegrasikan keamanan ke dalam pipeline deployment kita, meningkatkan telemetri untuk lebih memungkinkan deteksi dan pemulihan, melindungi pipeline deployment, dan mencapai tujuan manajemen perubahan.\n\nDengan mengkodekan praktik-praktik ini, kami berharap dapat mempercepat adopsi praktik DevOps, meningkatkan keberhasilan inisiatif DevOps, dan menurunkan energi aktivasi yang diperlukan untuk transformasi DevOps.\n","n":0.019}}},{"i":82,"$":{"0":{"v":"Part I - The Three Ways","n":0.408},"1":{"v":"\nFokus utama pada bab ini meliputi:\n\n- Prinsip-prinsip Flow, yang mempercepat pengiriman pekerjaan dari Development ke Operations hingga pelanggan kami\n- Prinsip-prinsip Feedback, yang memungkinkan kami untuk menciptakan sistem kerja yang semakin aman\n- Prinsip-prinsip Continual Learning and Experimentation, yang menumbuhkan budaya kepercayaan tinggi dan pendekatan ilmiah untuk perbaikan organisasi dengan mengambil risiko sebagai bagian dari pekerjaan kami sehari-hari.\n\nDevOps dihasilkan dari penerapan prinsip-prinsip terbaik dari bidang manufaktur fisik dan kepemimpinan pada aliran nilai teknologi informasi. DevOps mengandalkan berbagai pengetahuan dari Lean, Theory of Constraints, Toyota Production System, resilience engineering, learning organizations, safety culture, human factors, dan lain-lain. Praktik DevOps juga mengambil konteks dari budaya manajemen kepercayaan tinggi, kepemimpinan pelayan, dan manajemen perubahan organisasi. \n\nHasilnya adalah kualitas, keandalan, stabilitas, dan keamanan kelas dunia dengan biaya dan usaha yang semakin rendah; serta percepatan aliran dan keandalan di seluruh aliran nilai teknologi, termasuk Manajemen Produk, Pengembangan, QA, Operasi IT, dan Infosec. Meskipun dasar DevOps dapat dilihat berasal dari Lean, Theory of Constraints, dan gerakan Toyota Kata, banyak yang melihat DevOps sebagai kelanjutan logis dari perjalanan software Agile yang dimulai pada tahun 2001.\n\n### THE LEAN MOVEMENT\n\nGerakan Lean yang menjadi dasar dari prinsip-prinsip DevOps. Teknik-teknik seperti Value Stream Mapping, Kanban Boards, dan Total Productive Maintenance dikodifikasi untuk Sistem Produksi Toyota pada tahun 1980-an. Pada tahun 1997, Lean Enterprise Institute mulai meneliti aplikasi Lean pada value stream lain, seperti industri jasa dan kesehatan.\n\nDua prinsip utama dari Lean adalah keyakinan yang sangat kuat bahwa waktu tunggu dalam manufaktur yang diperlukan untuk mengubah bahan mentah menjadi barang jadi adalah prediktor terbaik dari kualitas, kepuasan pelanggan, dan kebahagiaan karyawan, dan bahwa salah satu prediktor terbaik dari waktu tunggu yang singkat adalah ukuran batch kecil dari pekerjaan.\n\nPrinsip-prinsip Lean fokus pada bagaimana menciptakan nilai bagi pelanggan melalui pemikiran sistem dengan menciptakan kesinambungan tujuan, mengadopsi pemikiran ilmiah, menciptakan aliran dan menarik (daripada mendorong), memastikan kualitas di sumbernya, memimpin dengan rendah hati, dan menghormati setiap individu.\n\n### THE AGILE MANIFESTO\n\nSelanjutnya tentang Agile Manifesto yang dibuat pada tahun 2001 oleh 17 pemikir terkemuka dalam pengembangan software. Manifesto ini bertujuan untuk menciptakan seperangkat nilai dan prinsip yang ringan dibandingkan dengan proses pengembangan software yang berat seperti pengembangan waterfall, dan metodologi seperti Rational Unified Process.\n\nSalah satu prinsip kunci dari Agile Manifesto adalah \"menghasilkan software yang berfungsi secara teratur, dari beberapa minggu hingga beberapa bulan, dengan preferensi pada jangka waktu yang lebih pendek,\" yang menekankan keinginan untuk ukuran batch yang kecil, rilis bertahap daripada rilis waterfall yang besar. Prinsip-prinsip lain menekankan perlunya tim kecil yang bermotivasi sendiri, bekerja dalam model manajemen yang tinggi kepercayaannya.\n\nAgile diakui telah secara dramatis meningkatkan produktivitas banyak organisasi pengembangan. Dan menariknya, banyak momen kunci dalam sejarah DevOps juga terjadi di dalam komunitas Agile atau di konferensi Agile, seperti yang dijelaskan di bawah ini.\n\n### AGILE INFRASTRUCTURE AND VELOCITY MOVEMENT\n\nPada konferensi Agile tahun 2008 di Toronto, Kanada, Patrick Debois dan Andrew Schafer mengadakan sesi \"birds of a feather\" tentang penerapan prinsip Agile pada infrastruktur dibandingkan kode aplikasi. Meskipun mereka adalah satu-satunya orang yang datang, mereka dengan cepat mendapat pengikut pemikir sejalan, termasuk salah satu penulis buku ini, John Willis.\n\nKemudian, pada konferensi Velocity tahun 2009, John Allspaw dan Paul Hammond memberikan presentasi krusial berjudul \"10 Deploys per Day: Dev and Ops Cooperation at Flickr\", di mana mereka menjelaskan bagaimana mereka menciptakan tujuan bersama antara Dev dan Ops dan menggunakan praktik integrasi terus menerus untuk membuat pengiriman menjadi bagian dari pekerjaan sehari-hari semua orang. Menurut laporan langsung, semua orang yang menghadiri presentasi tersebut langsung tahu bahwa mereka berada di hadapan sesuatu yang dalam dan bersejarah.\n\nPatrick Debois tidak hadir pada saat itu, tetapi begitu terkesan dengan ide Allspaw dan Hammond sehingga dia membuat DevOpsDays pertama di Ghent, Belgia (tempat tinggalnya) pada tahun 2009. Di sana, istilah \"DevOps\" diciptakan.\n\n### GERAKAN PENGIRIMAN BERKELANJUTAN\n\nMengembangkan disiplin pengembangan build, test, dan integrasi yang berkelanjutan, Jez Humble dan David Farley memperluas konsep tersebut ke pengiriman berkelanjutan, yang menentukan peran \"pipa pengiriman\" untuk memastikan bahwa kode dan infrastruktur selalu dalam keadaan dapat diterapkan, dan bahwa semua kode yang diperiksa pada trunk dapat diterapkan dengan aman ke produksi. Ide ini pertama kali disajikan pada konferensi Agile 2006, dan juga dikembangkan secara independen pada 2009 oleh Tim Fitz dalam sebuah posting blog di situs webnya yang berjudul \"Continuous Deployment.\"\n\n**TOYOTA KATA**\n\nPada tahun 2009, Mike Rother menulis Toyota Kata: Managing People for Improvement, Adaptiveness and Superior Results, yang merangkum perjalanannya selama dua puluh tahun untuk memahami dan mengkodekan Sistem Produksi Toyota. Dia adalah salah satu mahasiswa pascasarjana yang terbang bersama eksekutif GM untuk mengunjungi pabrik Toyota dan membantu mengembangkan toolkit Lean, tetapi dia bingung ketika tidak ada perusahaan yang mengadopsi praktik ini berhasil mereplikasi tingkat kinerja yang diamati di pabrik Toyota.\n\nDia menyimpulkan bahwa komunitas Lean melewatkan praktik paling penting dari semua, yang disebut improvement kata. Dia menjelaskan bahwa setiap organisasi memiliki rutinitas kerja, dan improvement kata memerlukan menciptakan struktur untuk praktik perbaikan harian yang habitual, karena praktik harianlah yang meningkatkan hasil. Siklus konstan untuk menetapkan keadaan masa depan yang diinginkan, menetapkan target hasil mingguan, dan peningkatan terus-menerus dari pekerjaan harian adalah yang membimbing perbaikan di Toyota.\n\nDi atas menjelaskan sejarah DevOps dan gerakan relevan yang digunakannya. Sepanjang sisa Bagian I, kami melihat aliran nilai, bagaimana prinsip Lean dapat diterapkan pada aliran nilai teknologi, dan Tiga Cara dari Aliran, Umpan Balik, dan Pembelajaran dan Eksperimen yang Berkelanjutan.\n\n### Ringkasan\n\nInti dari \"Part 1 - The Three Ways\" adalah memberikan pemahaman tentang tiga konsep dasar yang menjadi pondasi dari DevOps, yaitu Flow, Feedback, dan Continual Learning and Experimentation. Konsep-konsep ini masing-masing menggambarkan cara bagaimana sebuah organisasi dapat mencapai pengiriman perangkat lunak yang lebih cepat, lebih handal, dan lebih aman. Flow mengacu pada bagaimana pengiriman perangkat lunak harus mengalir lancar dan cepat melalui sistem, Feedback mengacu pada bagaimana umpan balik harus diterapkan di seluruh siklus pengiriman, sementara Continual Learning and Experimentation mengacu pada bagaimana pengembangan perangkat lunak harus selalu belajar dan meningkatkan secara terus-menerus. Tiga konsep ini saling berkaitan dan saling memperkuat satu sama lain dalam mencapai pengiriman perangkat lunak yang efektif dan efisien.","n":0.032}}},{"i":83,"$":{"0":{"v":"Agile Continuous Delivery and the Three Ways","n":0.378},"1":{"v":"\nTeori dasar dari Lean Manufacturing dan The Three Ways, prinsip-prinsip dari mana semua perilaku DevOps dapat diperoleh. Fokus utama di sini adalah pada teori dan prinsip-prinsip tersebut, yang menggambarkan banyak pengalaman yang dipelajari selama beberapa dekade dari manufaktur, organisasi dengan keandalan tinggi, model manajemen dengan kepercayaan tinggi, dan lain-lain, dari mana praktik DevOps telah diperoleh. Prinsip-prinsip dan pola-pola konkret yang dihasilkan, serta aplikasi praktisnya untuk aliran nilai teknologi, disajikan dalam bab-bab yang tersisa dari buku ini.\n\n## Ringkasan\n\nRingkasan dari section \"PART I - Agile, Continuous Delivery, and the Three Ways\" adalah memperkenalkan konsep-konsep yang terkait dengan pengiriman nilai melalui teknologi value stream, termasuk pengukuran waktu pemrosesan dan pengiriman, serta prinsip-prinsip dasar DevOps yang dikenal sebagai Three Ways. Three Ways ini mencakup prinsip-prinsip Flow, Feedback, dan Experimentation yang menjadi dasar DevOps dan digunakan untuk menghasilkan pengiriman produk dan layanan secara cepat, berkualitas, dan terus menerus. Selain itu, disebutkan juga tentang praktik-praktik yang memungkinkan aliran kerja yang cepat, mengamplifikasi umpan balik untuk mencegah masalah yang sama terjadi lagi, dan menciptakan budaya yang mendukung pengambilan risiko dan percobaan yang inovatif.\n\n## Action Items\n\nBeberapa action item yang dapat diambil dari section \"PART I - Agile, Continuous Delivery, and the Three Ways\" adalah:\n\n- Identifikasi dan visualisasikan value stream organisasi Anda untuk memahami bagaimana pekerjaan dilakukan, siapa yang melakukannya, dan bagaimana nilai diciptakan.\n- Ukur lead time dan process time dalam value stream Anda untuk mengetahui bagaimana proses bekerja dan mengidentifikasi area yang dapat dioptimalkan.\n- Gunakan %C/A sebagai metrik untuk mengukur kualitas output dalam setiap tahap value stream dan mengidentifikasi area yang perlu ditingkatkan.\n- Terapkan prinsip-prinsip Three Ways untuk meningkatkan efektivitas dan efisiensi value stream organisasi Anda.\n- Fokus pada prinsip Flow untuk menciptakan aliran kerja yang cepat dan efektif dalam value stream Anda.\n- Implementasikan praktik-praktik seperti continuous build, integration, test, dan deployment processes, menciptakan lingkungan on-demand, dan membatasi work in process (WIP).\n- Fokus pada prinsip Feedback Loop untuk menciptakan sistem kerja yang lebih aman dan berkelanjutan, dan memaksimalkan kesempatan untuk belajar dan berkembang.\n- Membangun budaya organisasi yang mendukung eksperimen dan pengambilan risiko yang didasarkan pada pendekatan ilmiah dan disiplin, sehingga organisasi dapat belajar dan berkembang lebih cepat dari pesaing di pasar.\n\n\n## THE MANUFACTURING VALUE STREAM\n\nPada bagian ini, diperkenalkan konsep dasar dari Lean Manufacturing yaitu value stream. Konsep ini dijelaskan terlebih dahulu dalam konteks manufaktur dan kemudian diterapkan pada DevOps dan teknologi value stream. \n\nKaren Martin dan Mike Osterling mendefinisikan value stream dalam bukunya Value Stream Mapping: How to Visualize Work and Align Leadership for Organizational Transformation sebagai \"urutan aktivitas yang dilakukan oleh sebuah organisasi untuk memenuhi permintaan pelanggan,\" atau \"urutan aktivitas yang diperlukan untuk merancang, memproduksi, dan mengirimkan barang atau layanan kepada pelanggan, termasuk aliran ganda informasi dan bahan.\" \n\nPada operasi manufaktur, value stream seringkali mudah dilihat dan diamati: dimulai ketika pesanan pelanggan diterima dan bahan baku dirilis ke lantai pabrik. Untuk memungkinkan waktu pemrosesan yang cepat dan dapat diprediksi pada setiap value stream, biasanya terdapat fokus yang tak kenal lelah dalam menciptakan aliran kerja yang lancar dan merata, dengan menggunakan teknik seperti ukuran batch kecil, mengurangi work in process (WIP), mencegah rework untuk memastikan bahwa tidak ada cacat yang diteruskan ke work center downstream, dan terus mengoptimalkan sistem kita menuju tujuan global kita.\n\n## THE TECHNOLOGY VALUE STREAM\n\nSelanjutnya buku ini membahas mengenai value stream di dalam teknologi, di mana prinsip-prinsip yang sama yang memungkinkan aliran kerja yang cepat dalam proses fisik juga sama-sama berlaku untuk pekerjaan teknologi (dan, pada kenyataannya, untuk semua pekerjaan pengetahuan). Dalam DevOps, teknologi value stream didefinisikan sebagai proses yang diperlukan untuk mengubah hipotesis bisnis menjadi layanan yang diaktifkan oleh teknologi yang memberikan nilai kepada pelanggan.\n\nInput dari proses ini adalah formulasi tujuan bisnis, konsep, ide, atau hipotesis, dan dimulai ketika pekerjaan diterima di Pengembangan, ditambahkan ke backlog pekerjaan yang sudah dikommit. Dari sana, tim Pengembangan yang mengikuti proses Agile atau iteratif yang khas kemungkinan akan mentransformasikan ide itu menjadi cerita pengguna dan beberapa jenis spesifikasi fitur, yang kemudian diimplementasikan dalam kode ke aplikasi atau layanan yang sedang dibangun. Kode kemudian diperiksa di dalam repositori kontrol versi, di mana setiap perubahan diintegrasikan dan diuji dengan bagian lain dari sistem perangkat lunak.\n\nKarena nilai diciptakan hanya ketika layanan kami berjalan di production, kami harus memastikan bahwa kami tidak hanya memberikan aliran yang cepat, tetapi juga bahwa deployment kami dapat dilakukan tanpa menyebabkan kekacauan dan gangguan seperti outage layanan, impairments layanan, atau kegagalan keamanan atau kepatuhan.\n\n## FOCUS ON DEPLOYMENT LEAD TIME\n\nSelanjutnya buku ini fokus pada waktu deployment (deployment lead time), suatu subset dari nilai aliran yang telah dijelaskan sebelumnya. Nilai aliran ini dimulai ketika setiap insinyur dalam nilai aliran kita (yang mencakup Development, QA, IT Operations, dan Infosec) memeriksa perubahan ke dalam kontrol versi dan berakhir ketika perubahan itu berhasil berjalan di produksi, memberikan nilai kepada pelanggan dan menghasilkan umpan balik dan telemetri yang berguna.\n\nFase pertama dari pekerjaan yang mencakup Desain dan Pengembangan mirip dengan Lean Product Development dan sangat bervariasi dan sangat tidak pasti, seringkali memerlukan tingkat kreativitas yang tinggi dan pekerjaan yang mungkin tidak pernah dilakukan lagi, menghasilkan waktu proses yang sangat bervariasi. Sebaliknya, fase kedua dari pekerjaan, yang mencakup Pengujian dan Operasi, mirip dengan Lean Manufacturing. Ini membutuhkan kreativitas dan keahlian, dan berusaha untuk dapat diprediksi dan mekanistik, dengan tujuan mencapai hasil kerja dengan minimalkan variabilitas (misalnya, waktu deployment yang pendek dan dapat diprediksi, hampir tanpa cacat).\n\nAlih-alih memproses batch kerja besar secara berurutan melalui nilai aliran desain/pengembangan dan kemudian melalui nilai aliran pengujian/operasi (seperti ketika kita memiliki proses air terjun batch besar atau cabang fitur yang hidup lama), tujuan kita adalah untuk memiliki pengujian dan operasi berjalan secara simultan dengan desain/pengembangan, memungkinkan aliran yang cepat dan berkualitas tinggi. Metode ini berhasil ketika kita bekerja dalam batch kecil dan membangun kualitas ke setiap bagian dari nilai aliran kita.†††\n\n### Defining Lead Time vs. Processing Time\n\nDi komunitas Lean, lead time adalah salah satu dari dua ukuran yang umum digunakan untuk mengukur kinerja dalam value stream, dengan yang lain adalah processing time (kadang-kadang dikenal sebagai touch time atau task time).\n\nSementara jam lead time dimulai saat permintaan dibuat dan berakhir ketika permintaan terpenuhi, jam process time dimulai hanya ketika kami mulai bekerja pada permintaan pelanggan—secara khusus, menghilangkan waktu ketika pekerjaan berada di antrian, menunggu untuk diproses.\n\n![Lead time vs. process time of a deployment operation](assets/20230421130113.png)\n\nKarena lead time adalah yang dialami pelanggan, kami biasanya memfokuskan perhatian perbaikan proses kami di sana daripada pada process time. Namun, proporsi process time terhadap lead time menjadi ukuran efisiensi yang penting—mencapai aliran cepat dan lead time yang pendek hampir selalu memerlukan pengurangan waktu pekerjaan kami menunggu di antrian.\n\n### Skenario Umum: Waktu Pemakaian Yang Memerlukan Berbulan-Bulan\n\nDalam bisnis biasa, seringkali kita menemukan diri kita berada dalam situasi di mana waktu penyebaran kami memerlukan berbulan-bulan. Ini terutama umum terjadi dalam organisasi besar dan kompleks yang bekerja dengan aplikasi monolitik yang sangat terkait, seringkali dengan lingkungan uji integrasi yang langka, waktu pemimpin lingkungan uji dan produksi yang lama, ketergantungan tinggi pada pengujian manual, dan beberapa proses persetujuan yang diperlukan. Ketika ini terjadi, maka value stream kita mungkin terlihat seperti pada gambar:\n\n![A technology value stream with a deployment lead time of three months (Source: Damon Edwards, “DevOps Kaizen,” 2015.)](assets/20230421130420.png)\n\nKetika kita memiliki waktu penyebaran yang lama, heroisme diperlukan di hampir setiap tahap value stream. Kita mungkin menemukan bahwa tidak ada yang berfungsi pada akhir proyek ketika kita menggabungkan semua perubahan tim pengembangan, yang menghasilkan kode yang tidak lagi dibangun dengan benar atau lulus semua tes kami. Memperbaiki setiap masalah memerlukan hari atau minggu investigasi untuk menentukan siapa yang merusak kode dan bagaimana itu dapat diperbaiki, dan masih menghasilkan hasil pelanggan yang buruk.\n\n\n### Visi DevOps Kami: Deployment Lead Time dalam Hitungan Menit\n\nPada kondisi ideal DevOps, para developer menerima umpan balik cepat dan terus-menerus terhadap pekerjaan mereka, yang memungkinkan mereka untuk dengan cepat dan mandiri mengimplementasikan, mengintegrasikan, dan memvalidasi kode mereka, serta melakukan deployment kode tersebut ke dalam lingkungan produksi (baik dengan melakukan deployment sendiri atau oleh orang lain).\n\nKami mencapainya dengan terus memeriksa perubahan kode kecil ke dalam repositori kontrol versi kami, melakukan pengujian otomatis dan eksploratori terhadapnya, dan mendeploynya ke dalam produksi. Ini memungkinkan kami memiliki tingkat keyakinan yang tinggi bahwa perubahan kami akan berfungsi seperti yang direncanakan di produksi dan bahwa setiap masalah dapat dideteksi dan diperbaiki dengan cepat.\n\nHal ini paling mudah dicapai ketika kita memiliki arsitektur yang modular, terenkapsulasi dengan baik, dan longgar-terkait sehingga tim kecil mampu bekerja dengan tingkat otonomi yang tinggi, dengan kegagalan yang kecil dan terkandung, dan tanpa menyebabkan gangguan global.\n\nPada skenario ini, waktu deployment lead time kita diukur dalam hitungan menit, atau, dalam kasus terburuk, jam. Peta alir nilai hasil kami harus terlihat seperti gambar:\n\n![A technology value stream with a lead time of minutes](assets/20230421130853.png)\n\n### OBSERVING “%C/A” AS A MEASURE OF REWORK\n\nMetric ketiga dalam technology value stream, yaitu persentase selesai dan akurat (%C/A) yang mencerminkan kualitas output dari setiap langkah dalam value stream. %C/A dapat diukur dengan cara menanyakan kepada pelanggan downstream berapa persentase waktu mereka menerima pekerjaan yang \"dapat digunakan apa adanya\" yang berarti mereka dapat melakukan pekerjaan mereka tanpa harus memperbaiki informasi yang diberikan, menambahkan informasi yang hilang yang seharusnya disediakan, atau menjelaskan informasi yang seharusnya dan bisa lebih jelas. \n\nHal ini menjadi penting karena kualitas yang buruk akan menghasilkan pekerjaan yang tidak efektif dan efisien dalam penggunaan sumber daya.\n\nMisalnya, dalam sebuah perusahaan software, jika 80% dari kode yang dikerjakan oleh tim pengembang dalam sprint pertama dapat diserahkan ke tim testing tanpa perlu dilakukan perbaikan tambahan, maka %C/A untuk sprint tersebut adalah 80%. Artinya, dari semua pekerjaan yang diselesaikan dalam sprint pertama, 80% dari pekerjaan tersebut dapat digunakan tanpa perlu dikerjakan ulang atau memperbaiki lagi.\n\nJika persentase %C/A ini rendah, misalnya hanya 30%, artinya hanya 30% pekerjaan yang dapat diserahkan ke downstream tanpa perlu dilakukan perbaikan tambahan, sedangkan 70% sisanya memerlukan rework atau perbaikan lagi, yang berarti adanya masalah dalam proses pengembangan yang harus diperbaiki. Dalam hal ini, peningkatan %C/A menjadi tujuan yang harus dicapai untuk meningkatkan kualitas hasil kerja dan mengurangi rework.\n\n## THE THREE WAYS: THE PRINCIPLES UNDERPINNING DEVOPS\n\nKonsep ini terdiri dari tiga prinsip yang menjadi dasar bagi semua perilaku dan pola DevOps yang diamati. Prinsip pertama disebut The First Way, yang bertujuan untuk memungkinkan aliran kerja yang cepat dari Development ke Operations hingga ke pelanggan. \n\nUntuk memaksimalkan aliran kerja ini, perlu membuat pekerjaan terlihat, mengurangi ukuran batch dan interval pekerjaan, membangun kualitas dengan mencegah cacat agar tidak diteruskan ke pusat kerja hilir, dan terus mengoptimalkan tujuan global. Prinsip-prinsip lain dari The Three Ways akan dibahas pada bagian selanjutnya.\n\n![The Three Ways (Source: Gene Kim, “The Three Ways: The Principles Underpinning DevOps,” IT Revolution Press blog, accessed August 9, 2016, http://itrevolution.com/the-three-ways-principles-underpinning-devops/.)](assets/20230421131336.png)\n\nDengan mempercepat aliran melalui value stream teknologi, kita dapat mengurangi waktu yang diperlukan untuk memenuhi permintaan internal atau pelanggan, terutama waktu yang dibutuhkan untuk mendeploy kode ke lingkungan produksi. Dengan melakukan hal ini, kita meningkatkan kualitas pekerjaan dan throughput, serta meningkatkan kemampuan kita untuk melampaui kompetisi.\n\nPraktik yang dihasilkan meliputi proses continuous build, integration, test, dan deployment; menciptakan lingkungan sesuai permintaan; membatasi work in process (WIP); dan membangun sistem dan organisasi yang aman untuk diubah.\n\nPrinsip kedua (The Second Way) adalah memungkinkan aliran feedback yang cepat dan konstan dari kanan ke kiri di semua tahap value stream kita. Dalam prinsip ini, kita perlu memperkuat feedback untuk mencegah masalah terjadi lagi atau memungkinkan deteksi dan pemulihan yang lebih cepat. Dengan melakukan ini, kita menciptakan kualitas di sumbernya dan menghasilkan atau menyematkan pengetahuan di tempat yang dibutuhkan.\n\nDengan melihat masalah saat terjadi dan menanganinya hingga tindakan perbaikan yang efektif diterapkan, kita terus memperpendek dan memperkuat feedback loop, prinsip inti dari hampir semua metodologi perbaikan proses modern. Hal ini memaksimalkan peluang organisasi kita untuk belajar dan meningkatkan.\n\nPrinsip ketiga (The Third Way) adalah memungkinkan terciptanya budaya generatif yang tinggi kepercayaannya dan mendukung pendekatan yang dinamis, disiplin, dan ilmiah terhadap eksperimen dan pengambilan risiko. Prinsip ini memfasilitasi terciptanya pembelajaran organisasi dari keberhasilan dan kegagalan. Dengan memperpendek dan memperkuat terus-menerus feedback loop, kita menciptakan sistem kerja yang semakin aman dan mampu mengambil risiko serta melakukan eksperimen yang membantu kita belajar lebih cepat dari kompetitor dan menang di pasar.\n\nSebagai bagian dari The Third Way, kita juga merancang sistem kerja kita sehingga kita dapat memperbanyak efek pengetahuan baru, mengubah penemuan lokal menjadi perbaikan global. Terlepas dari di mana seseorang melakukan pekerjaan, mereka melakukannya dengan pengalaman kumulatif dan kolektif dari semua orang di organisasi.","n":0.022}}},{"i":84,"$":{"0":{"v":"The Compound Effect","n":0.577},"1":{"v":"\n#self-improvement\n#darren-hardy\n\nHal besar tidak terjadi dalam semalam, melainkan hal kecil yang dikumpulkan dan menjadi kebiasaan.\n\nhttps://go.darrenhardy.com/the-compound-effect-resources/\n\n## The Compound Effect in Action\n\nChapter pertama judulnya The Compound Effect in Action.\n\nCompound efek itu adalah pilihan-pilihan yang kecil yang baik, efektif dan dilakukan secara konsisten.\nDan dipilih secara sadar bukan autopilot.\n\n```\nSMALL, SMART CHOICES + CONSISTENCY + TIME = RADICAL DIFFERENCE\n```\n\n> Kalian pilih yang mana? dapet uang 3 juta dolar didepan atau 1 sen yang berlipat ganda selama 30 hari.\n\nJika kita pilih 3 juta didepan, ya sudah tidak akan ada penambahan lagi dihari hari berikutnya.\nTapi jika kita pilih 1 sen yang berlipat ganda kita akan mendapat total lebih dari 10juta di hari ke 30.\n\nJika pilihan yang kecil dibuat secara konsisten maka akan menghasilkan sesuatu yang besar.\n\nMisalnya seperti pada cerita kura-kura dan kelinci.\n\nTaukan yang akhirnya siapa? ya, yang menang adalah si kura kura yang lambat.\n\nKura-kura memang pelan, tapi dia konsisten selangkah demi selangkah berjalan hingga sampai tujuan.\nSedangkan kelinci yang cepat tapi tidak fokus sehingga tidak pernah sampai ke tujuan.\n\n### Action Step\n\n- Kita harus bertanggung jawab dengan diri kita sendiri.\n- Tuliskan 6 langkah positif yang bisa dilakukan secara konsisten setiap hari.\n- Tuliskan 6 langkah negatif yang ingin kita hentikan.\n- Identifikasikan area dimana dulu kita pernah sukses, tapi tidak melakukannya lagi karena sudah berpuas diri.\n\n## Choices\n\nChapter kedua judulnya Choices atau pilihan-pilihan.\n\nSemua dimulai dari sebuah pilihan.\n\nTidak mungkinkan, dalam semalam berat badan kita naik hingga 100kg.\nItu adalah hasil dari pilihan-pilihan buruk kita dimasa lalu.\n\nLalu bagaimana kita menjadi lebih baik dengan memilih pilihan yang tepat?\n\nJawabannya adalah berhenti hidup dengan autopilot dan mulai keputusan dengan sadar dan bertanggung jawab atas pilihan yang kita pilih.\n\nIngat keberuntungan adalah Preparation + Attitude + Opportunity + Action.\n\n> How? “You can’t manage what you can’t measure,” so choose to start tracking every action in the part of life that you’re focussing on.\n\nLalu, bagaimana kita bisa mengatur sesuatu yang kita gak bisa ukur?\nYa pilihannya kita bisa mulai melakukan \"tracing\" dari setiap aksi yang paling kita fokusin.\n\nContoh,\n\nMisalnya kita ingin menurunkan berat badan, caranya:\n\n- Track berat badan\n- Track ukuran badan\n- Track kalori\n- Track steps\n- Track waktu latihan setiap hari\n\n<!-- TODO: Bikin contoh cerita -->\n\n### Action Step\n\n- Identifikasi satu hal yang paling kalian perjuangkan lalu mulai buat journal yang kita syukuri.\n- Identifikasi satu hal kehidupan yang ingin kalian ubah dan kalian tidak bertanggung jawab 100%.\n- Start tracking setidaknya satu hal yang ingin diubah dan ditingkatkan.\n\n## Habits\n\nChapter ketiga judulnya habits atau kebiasaan.\n\nMembuat habit baru memang membutuhkan waktu, sabar dengan diri sendiri.  Jika kita gagal jangan menyalahkan diri sendiri atau siapapun. Mulai coba kembali.\n\nBagaimana kita mengambil tanggung jawab akan habit kita?\n\n- Kita harus mengetahui impact dari habit yang kita lakukan terhadap hidup kita.\n- Tetukan \"Why?\" yang memotivasi untuk mengubah perilaku.\n- Hilangkan kebiasaan buruk.\n- Buat kebiasaan baik yang akan mencapai tujuan kita.\n\n<!-- TODO: Bikin contoh cerita -->\n\n## Momentum\n\nChapter keempat judulnya momentum.\n\nDibuku ini ada yang namanya the big mo.\nKalau kita bisa menjaga perilaku baik dalam jangka waktu yang cukup lama, kemungkinan besar kita akan masuk kedalam ritme yang alami secara konsisten.\nSaat kita sudah mengikuti ritme ini, kita akan terus membuat keputusan yang lebih baik.\n\nKalau sudah mulai, jangan berhenti. Jika berhenti kita bukan saja kehilangan semua kerja keras sebelumnya, tapi kita juga kehilangan momentum.\n\nKonsistensi dan ketekunan adalah penghasil efek compound.\n\nDibuku ini daren mencontohkan,\n\nDipagi hari dia merefleksi diri dengan 3 hal yang disyukuri. lalu memvisualisasikan apa yang mau dicapai dihari itu.\nLalu buat 3 aksi nyata untuk mewujudkannya.\n\nLalu retrospeksi dimalam hari tentang apa yang dilakukannya hari ini. Refleksikan apa yang dipelajari dihari ini.\nApa yang bisa membuat hari esok jadi lebih baik.\n\n<!-- TODO: Bikin contoh cerita -->\n\n### Action Step\n\n- Bikin list dimalam hari dan morning routines.\n- List 3 hal dimana lo gak cukup konsisten.\n\n## Influences\n\nChapter kelima judulnya influences atau pengaruh\n\nSalah satu langkah penting dalam memperbaiki kebiasaan adalah pengaruh.\nKita harus pintar-pintar memilah informasi. Otak kita adalah mesin pemroses informasi. garbage in, garbage out.\n\nBagaimana caranya menjaga informasi yang masuk?\n\n1. Pilih media yang memberikan informasi mendekati tujuan kita dan hindari informasi berita berita tidak penting.\n2. Pilih asosiasi atau inner circle yang tepat, yang suportif dan menginpirasi.\n    - Evaluasi asosiasi saat ini. Apakah kita dikelilingi orang-orang yang cinta, mendukung dan menginspirasi?\n    - Visualisasi ideal asosiasi. Kalau boleh berangan angan kira kira teman seperti apa yang kita mau?\n    - Singkirkan yang terburuk sepenuhnya. Temukan cara untuk menjadu dari bad actor.\n    - Batasi pertemanan, kualitas lebih penting dari kuantitas.\n    - Perluas dan tiru yang baik.\n3. Pilih lingkungan yang tepat.\n\n### Action Step\n\n- Identifikasi pengaruh media dan informasi didalam hidup kita. Identifikasi cara untuk memproteksi dari informasi negatif.\n- evaluasi asosiasi saat ini. Mana yang harus dihentidan atau dibatasi? lalu bagai mana kita memperluas pertemanan yang baik.\n- identifikasi 3 hal yang paling kita fokusin untuk diimprove. cari mentor disetiap area tersebut. \n\n## Acceleration\n\nChapter keenam judulnya acceleration atau mempercepat.\n\nHadapilah rintangan bukan sebagai masalah, tetapi sebagai kesempatan.\nPerlu diingat pertumbuhan akan terlihat jika kita berhasil melewati rintangan-rintangan.\nDengan adanya rintangan kita dikasi kesempatan untuk belajar.\n\nSemua orang mungkin menghadapi masalah yang sama, tapi kebanyakan dari mereka menyerah begitu saja.\n\nBerdiri dan keluarlah, lakukan hal hal yang tidak terduga. carilah sebanyak mungkin peluang yang mengejutkan.\nAmbil aksi yang luar biasa. Manfaatkan compound efek dan kita akan menemukan cara untuk memulai pendapatan, kehidupan dan kesuksesan.\n\nMisalnya, Kalau kita sudah rutin berolah raga dipagi hari dan kita pikir kita hanya kuat push up sebanyak 50 kali.\nCoba paksakan diri kamu untuk menambahkan 20 kali lagi. Dengan cara seperti ini kita bisa menembuat ambang batas yang baru.\n\n\n### Action Step\n\n- Identifikasi waktu ketika kita mencapai moment of truth dan berkomitmen untuk sampai disana.\n- Temukan 3 hal didalam hidup kita dimana kita bisa melakukan \"extra\" dan membuat rencana untuk melakukan lebih.\n- Identifikasi 3 hal didalam hidup kita yang melewati ekspektasi lalu rencankan dan bahanya mana cara membuat \"wow\" moment.\n- Identifikasi 3 cara dimana kita bisa melakukan hal-hal yang tak terduga. Temukan perbedaan antara umum, normal dan expected.\n\n## Lesson Learn\n\nKita tidak bisa mengubah hidup kita hingga rutinitas kita berubah.\n\n1. Terima kekuatan compounding\n2. Buat dan track pilihan pilihan secara sadar\n3. Tumbuhkan kebiasaan positof dan membuang kebiasaan buruk.\n4. Set up rutin harian dan mingguan.\n5. Optimasi lingkungan\n6. Ambil aksi yang luar biasa.\n\nTerdengan sederhana tapi susah buat dikerjakan.\n\n","n":0.032}}},{"i":85,"$":{"0":{"v":"Team Topologies","n":0.707},"1":{"v":"\n## The Problem with Org Charts\n\n### Problem & Solution\n\nPada Chapter 1, buku ini membahas tentang masalah dalam pengembangan perangkat lunak yang sering terjadi di banyak organisasi, yaitu ketidakmampuan untuk mengoptimalkan aliran kerja dan feedback dari sistem yang dijalankan. Hal ini disebabkan oleh model organisasi tradisional yang terfokus pada spesialisasi fungsional, perencanaan proyek besar, dan minimnya perhatian terhadap dinamika sosioteknis dalam pengembangan perangkat lunak. Akibatnya, tim pengembang menjadi bottleneck dalam aliran kerja, memperlambat produksi, menurunkan kualitas, dan merusak motivasi anggota tim.\n\nSolusi yang ditawarkan oleh buku ini adalah pendekatan Team Topologies. Pendekatan ini mengusulkan desain organisasi yang lebih fleksibel dan adaptif dengan mengoptimalkan aliran perubahan dan umpan balik dari sistem yang dijalankan. Pendekatan ini mencakup perubahan dalam struktur, tujuan, dan interaksi tim, seperti pembatasan beban kognitif pada tim, perancangan interaksi tim secara eksplisit, dan pendekatan yang berorientasi pada tim. Dengan mengadopsi pendekatan Team Topologies, organisasi dapat mengoptimalkan aliran kerja dan meningkatkan adaptabilitas strategis mereka dalam jangka panjang.\n\n\n### Takeaways\n\n1. Struktur organisasi yang tepat sangat penting untuk pengembangan dan operasi perangkat lunak yang efektif. Pendekatan konvensional yang menganggap pengembangan perangkat lunak sebagai jenis manufaktur yang dilakukan oleh individu yang disusun ke dalam spesialisasi fungsional tidak lagi cocok untuk lingkungan bisnis yang cepat berubah dan penuh ketidakpastian.\n\n2. Untuk merespon kebutuhan pengembangan perangkat lunak yang cepat dan adaptif, organisasi harus mempertimbangkan desain tim yang memprioritaskan aliran pengiriman perangkat lunak dan adaptabilitas strategis. Desain organisasi yang terkait dengan desain arsitektur perangkat lunak, pembatasan beban kognitif, dan pendekatan yang memprioritaskan tim harus dipertimbangkan.\n\n3. Penting untuk mengurangi beban kognitif pada tim dengan mempertimbangkan ukuran tim, tugas, dan batasan dengan tim lain. Dalam lingkungan yang cepat berubah dan penuh ketidakpastian, tim perlu beradaptasi dan menemukan tempat dan waktu yang tepat untuk bekerja sama untuk hasil yang lebih baik.\n\n### Summary\n\nPoint inti dari buku \"Team Topologies\" adalah bahwa organisasi harus memikirkan kembali struktur tim, tujuan, dan interaksi mereka untuk membangun dan mengoperasikan perangkat lunak secara efektif dalam sistem yang terhubung dan kompleks. Buku ini menyarankan pendekatan yang berfokus pada tim untuk mempercepat aliran pengiriman perangkat lunak dan meningkatkan adaptabilitas strategis organisasi.\n\nBeberapa hal penting yang ditekankan oleh buku ini antara lain:\n\n1. Pentingnya memikirkan beban kognitif dan membatasinya agar tim dapat bekerja secara efektif.\n2. Perubahan dan umpan balik harus diintegrasikan dalam siklus pengembangan dan pengoperasian perangkat lunak secara terus-menerus.\n3. Struktur organisasi tradisional seringkali tidak memungkinkan organisasi untuk sepenuhnya memanfaatkan keuntungan dari Agile, Lean IT, dan DevOps. Oleh karena itu, perubahan budaya dan organisasi harus dihadapi secara serius.\n4. Conway's law dapat dimanfaatkan untuk mempercepat pengiriman perangkat lunak dengan merancang struktur organisasi yang tepat.\n5. Tim harus dirancang dengan tujuan yang jelas dan diorganisir sedemikian rupa sehingga memprioritaskan aliran pengiriman perangkat lunak dan adaptabilitas strategis.\n\nBuku ini memberikan pendekatan dan alat mental yang dapat membantu organisasi menyesuaikan dan menemukan tempat dan waktu yang tepat untuk kolaborasi, serta kapan yang terbaik untuk fokus pada eksekusi dan mengurangi biaya komunikasi.\n","n":0.046}}},{"i":86,"$":{"0":{"v":"The Problem with Org Charts","n":0.447},"1":{"v":"\n\n## Masalah dengan Struktur Organisasi\n\nOrganisasi seharusnya dipandang sebagai organisme yang kompleks dan adaptif daripada sistem mekanistik dan linear.\n\n—Naomi Stanford, Panduan Desain Organisasi\n\nPara pekerja teknologi berada dalam keadaan aksi yang konstan: menciptakan dan memperbarui sistem dengan kecepatan yang luar biasa, serta menggabungkan berbagai jenis teknologi untuk menciptakan pengalaman pengguna yang menarik. Aplikasi seluler; layanan berbasis cloud; aplikasi web; dan perangkat IoT terbenam, dikenakan atau industri semua perlu berinteraksi secara efektif untuk mencapai hasil bisnis yang diinginkan.\n\nHari ini, sistem-sistem ini mempengaruhi hampir setiap aspek kehidupan sehari-hari orang dengan cara yang semakin mendalam. Jika perangkat lunak dirancang dengan buruk - atau yang lebih penting, jika ada ketidakcocokan dalam interaksi perangkat lunak, penyedia, dan pelanggan - orang akan terpengaruh buruk. Mereka dapat terdampar jauh dari rumah jika aplikasi pemesanan taksi gagal. Mereka mungkin tidak dapat membayar sewa jika perangkat lunak atau proses untuk perbankan internet gagal. Mereka bahkan dapat melihat hidup mereka dalam bahaya jika perangkat medis gagal. Tidak pernah sebelumnya desain sosioteknis yang eksplisit begitu penting.\n\nMembangun dan menjalankan sistem perangkat lunak yang sangat kompleks dan saling terhubung ini adalah kegiatan tim, yang membutuhkan upaya gabungan dari orang-orang dengan keterampilan yang berbeda di berbagai platform. Selain itu, organisasi TI modern harus memberikan dan mengoperasikan sistem perangkat lunak dengan cepat dan aman, sambil tumbuh dan beradaptasi dengan perubahan dan tekanan di lingkungan bisnis atau regulasi. Bisnis tidak lagi dapat memilih antara mengoptimalkan stabilitas dan mengoptimalkan kecepatan.\n\nNamun, meskipun risiko dan tuntutan ini, banyak organisasi masih mengorganisir orang dan tim mereka dengan cara yang tidak produktif untuk pengembangan dan operasi perangkat lunak modern. Organisasi yang terlalu bergantung pada bagan organisasi dan matriks untuk membagi dan mengontrol pekerjaan sering gagal untuk menciptakan kondisi yang diperlukan untuk merangkul inovasi sambil tetap mengirim dengan cepat. Untuk berhasil dalam hal itu, organisasi membutuhkan tim yang stabil dan pola dan interaksi tim yang efektif. Mereka perlu berinvestasi dalam tim yang terampil dan diberdayakan sebagai dasar untuk kecepatan dan adaptabilitas. Untuk tetap hidup di pasar yang semakin kompetitif, organisasi membutuhkan tim dan orang yang mampu merasakan perubahan konteks dan berkembang sesuai.\n\nKabar baiknya adalah memungkinkan untuk menjadi cepat dan aman dengan pola pikir yang tepat dan dengan menggunakan alat yang menekankan pada adaptabilitas serta pengulangan, sambil menempatkan tim dan individu pada pusat perhatian. Seperti yang dikatakan oleh Mark Schwartz dan rekannya dalam makalah mereka yang berjudul \"Thinking Environments\" tahun 2016, \"struktur organisasi harus mengkoordinasikan tanggung jawab untuk mendukung tujuan pengiriman perangkat lunak berkualitas tinggi dan bermakna.\" Sebagai anggota tim teknologi yang mengelola antarmuka ini, kita harus mengubah pola pikir kita dari memperlakukan tim sebagai kumpulan individu yang dapat saling dipertukarkan yang akan berhasil selama mereka mengikuti proses \"benar\" dan menggunakan alat \"benar\", menjadi memperlakukan orang dan teknologi sebagai satu ekosistem sosioteknik manusia/komputer karbon/silikon. Pada saat yang sama, kita perlu memastikan bahwa tim memiliki motivasi intrinsik dan diberi kesempatan nyata untuk melakukan pekerjaan terbaik mereka dalam sistem tersebut.\n\nBab ini akan memperkenalkan Team Topologies sebagai model adaptif untuk desain organisasi teknologi yang memungkinkan bisnis untuk mencapai kecepatan dan stabilitas. Namun, pertama-tama, mari kita lihat bagaimana struktur komunikasi yang sebenarnya dalam sebagian besar organisasi seringkali berbeda jauh dari apa yang diberitahukan oleh struktur organisasi, dan apa implikasinya.\n\n### Struktur Komunikasi dalam Organisasi\n\nSebagian besar organisasi ingin atau diharuskan memiliki pandangan tunggal terhadap tim dan orang-orang mereka yang disebut \"org chart.\" Chart ini menggambarkan tim, departemen, unit, dan entitas organisasi lainnya, serta hubungan mereka satu sama lain. Biasanya, chart ini menunjukkan garis hierarki pelaporan, yang mengimplikasikan jalur komunikasi yang berjalan \"naik dan turun\" organisasi.\n\nOrg chart memang memiliki kegunaannya dalam konteks membangun sistem perangkat lunak, terutama seputar kepatuhan hukum dan peraturan. Namun, dalam konteks kolaborasi yang sangat tinggi dan penuh ketidakpastian atas hasil yang diinginkan, mengandalkan org chart sebagai mekanisme utama untuk membagi pekerjaan yang harus dilakukan mengarah pada harapan yang tidak realistis. Sebaliknya, kita perlu mengandalkan tim yang terpisah dan berumur panjang yang dapat bekerja sama secara efektif untuk menghadapi tantangan keseimbangan kecepatan dan keamanan.\n\nMasalahnya dengan menganggap org chart sebagai kebenaran adalah kita akhirnya mencoba membangun manusia seolah-olah mereka adalah perangkat lunak, dengan rapi mempertahankan komunikasi mereka hanya dalam garis-garis yang diterima. Namun, manusia tidak membatasi komunikasi mereka hanya pada garis-garis yang terhubung di chart tersebut. Kita mencapai siapa saja yang kita butuhkan untuk menyelesaikan pekerjaan. Kita melanggar aturan jika diperlukan untuk mencapai tujuan kita. Itulah mengapa garis komunikasi yang sebenarnya terlihat sangat berbeda dari org chart, seperti yang ditunjukkan dalam Gambar 1.1 (lihat halaman 6).\n\n![Figure 1.1: Org Chart with Actual Lines of Communication In practice, people communicate laterally or “horizontally” with people from other reporting lines in order to get work done. This creativity and problem solving needs to be nurtured for the benefit of the organization, not restricted to optimize for top-down/bottom-up communication and reporting.](assets/1683524489.png)\n\n## Berpikir Menggunakan Org Chart Adalah Masalah\n\nOrg chart tradisional tidak membantu kita memahami pola komunikasi aktual dalam organisasi kita, seperti yang diilustrasikan dalam Gambar 1.1. Sebagai gantinya, organisasi perlu mengembangkan gambaran yang lebih realistis tentang komunikasi yang diharapkan dan aktual yang terjadi antara individu dan tim. Kesenjangan akan membantu menginformasikan jenis sistem yang lebih cocok untuk organisasi.\n\nSelain itu, keputusan yang didasarkan pada struktur org-chart cenderung dioptimalkan hanya untuk sebagian organisasi, mengabaikan efek hulu dan hilir. Optimisasi lokal membantu tim yang terlibat langsung, tetapi tidak selalu membantu meningkatkan pengiriman nilai secara keseluruhan kepada pelanggan. Dampak mereka mungkin diabaikan jika ada bottleneck yang lebih besar dalam aliran kerja. Misalnya, memiliki tim yang mengadopsi cloud dan infrastruktur-as-code dapat mengurangi waktu untuk menyediakan infrastruktur baru dari minggu atau bulan menjadi menit atau jam. Tetapi jika setiap perubahan membutuhkan persetujuan deployment (ke produksi) dari dewan yang bertemu sekali seminggu, maka kecepatan pengiriman akan tetap mingguan.\n\nSistem thinking berfokus pada mengoptimalkan keseluruhan, melihat aliran kerja secara keseluruhan, mengidentifikasi bottleneck terbesar hari ini, dan mengeliminasi. Kemudian ulangi. Team Topologies berfokus pada cara menyiapkan struktur tim dan mode interaksi dinamis yang dapat membantu tim beradaptasi dengan cepat dengan kondisi baru dan mencapai pengiriman perangkat lunak yang cepat dan aman. Mungkin bukan bottleneck terbesar Anda saat ini, tetapi suatu saat nanti, Anda akan menghadapi masalah struktur tim yang kaku dengan komunikasi yang buruk dan/atau proses yang tidak memadai, yang memperlambat pengiriman.\n\nMenganggap org chart sebagai representasi setia tentang bagaimana pekerjaan dilakukan dan bagaimana tim berinteraksi satu sama lain mengarah pada keputusan yang tidak efektif seputar alokasi pekerjaan dan tanggung jawab. Sama seperti dokumen arsitektur perangkat lunak menjadi usang segera setelah pengembangan perangkat lunak sebenarnya dimulai, org chart selalu tidak sinkron dengan realitas.\n\nTentu saja, kami bukanlah orang pertama yang mengakui ketidakseimbangan antara struktur organisasi formal dan cara kerja sebenarnya. Buku Geary Rummler dan Alan Brache Improving Performance: How to Manage the White Space on the Organization Chart menetapkan panggung untuk perbaikan dan manajemen proses bisnis yang berkelanjutan. Fokus terbaru (setidaknya dalam TI) pada produk dan sentralitas tim, seperti yang diilustrasikan oleh buku Mik Kersten tentang beralih dari Proyek ke Produk, adalah tonggak besar lainnya. Kami suka berpikir bahwa Team Topologies adalah bagian lain dari teka-teki ini—terutama, memiliki struktur tim yang jelas dan fluid, tanggung jawab, dan mode interaksi.\n\n## Melampaui Diagram Organisasi\n\nJika diagram organisasi tidak mewakili struktur organisasi dengan akurat, lalu apa yang mewakilinya? Niels Pflaeging, penulis buku Organize for Complexity, mengidentifikasi tidak satu, melainkan tiga struktur organisasi yang berbeda dalam setiap organisasi:2\n\n1. Struktur formal (diagram organisasi) - memfasilitasi kepatuhan\n2. Struktur informal - \"wilayah pengaruh\" antara individu\n3. Struktur penciptaan nilai - bagaimana pekerjaan sebenarnya dilakukan berdasarkan reputasi interpersonal dan antar tim\n\nPflaeging menyarankan bahwa kunci keberhasilan organisasi pekerjaan berbasis pengetahuan terletak pada interaksi antara struktur informal dan struktur penciptaan nilai (yaitu, interaksi antara orang dan tim).3 Penulis lain telah mengusulkan karakterisasi yang serupa, seperti Frédéric Laloux dalam Reinventing Organizations atau pendekatan Holacracy dari Brian Robertson.4\n\nPendekatan Team Topologies mengakui pentingnya struktur informal dan struktur penciptaan nilai seperti yang ditentukan oleh Pflaeging. Dengan memberdayakan tim dan memperlakukan mereka sebagai blok bangunan fundamental, individu dalam tim tersebut menjadi lebih dekat untuk bertindak sebagai tim daripada sekadar sekelompok orang. Di sisi lain, dengan secara eksplisit menyetujui mode interaksi dengan tim lain, harapan perilaku menjadi lebih jelas dan kepercayaan antar tim meningkat.\n\nSelama beberapa dekade terakhir, banyak pendekatan baru dalam mengorganisir bisnis, tetapi biasanya desain baru tetap menjadi pandangan statis dari organisasi yang tidak mempertimbangkan perilaku dan struktur nyata yang muncul setelah restrukturisasi. Misalnya, pendekatan \"manajemen matriks\" yang dimulai pada tahun 1990-an - dan menjadi cukup populer selama beberapa dekade berikutnya - mencoba mengatasi kompleksitas inheren pekerjaan yang sangat tidak pasti dan sangat terampil dengan meminta individu melaporkan kepada manajer bisnis dan fungsional. Meskipun fokus yang lebih jelas pada nilai bisnis dibandingkan dengan organisasi fungsional murni dari tim, ini masih menjadi pandangan dunia yang statis yang menjadi usang karena bisnis dan teknologi domain dengan cepat berkembang.\n\nBagi pekerja, restrukturisasi seperti pengenalan manajemen matriks dapat membawa banyak ketakutan dan kekhawatiran. Seringkali, hal ini dianggap sebagai pemborosan waktu dan upaya yang lebih mungkin membuat bisnis mundur daripada maju. Dan setelah revolusi teknologi atau metodologi berikutnya terjadi, bisnis melakukan restrukturisasi lagi, merusak bentuk komunikasi yang telah mapan dan memecah tim yang baru saja mulai bekerja dengan baik.\n\nPendekatan Team Topologies menambahkan aspek dinamis dan sensorik yang dibutuhkan untuk organisasi teknologi yang hilang dari desain organisasi tradisional.\nSudah semakin jelas bahwa mengandalkan struktur organisasi tunggal dan statis, seperti org chart atau manajemen matriks, tidak dapat dipertahankan untuk hasil yang efektif dengan sistem perangkat lunak modern. Alih-alih struktur tunggal, yang dibutuhkan adalah model yang dapat beradaptasi dengan situasi saat ini - yang mempertimbangkan bagaimana tim tumbuh dan berinteraksi satu sama lain. Team Topologies menyediakan pendekatan (r) evolusioner yang diperlukan untuk menjaga tim, proses, dan teknologi selaras untuk semua jenis organisasi.\n\nDalam bukunya yang luar biasa pada tahun 2015, Guide to Organisation Design: Creating High-Performing and Adaptable Enterprises, Naomi Stanford mencantumkan lima aturan praktis untuk merancang organisasi:5\n\n1. Desain saat ada alasan yang kuat.\n2. Kembangkan opsi untuk memutuskan desain.\n3. Pilih waktu yang tepat untuk merancang.\n4. Cari petunjuk bahwa hal-hal tidak sejalan.\n5. Tetap waspada terhadap masa depan.\n\nKetika kami terus melalui buku ini, kami akan menjelajahi cara mengatasi lima heuristik untuk desain organisasi ini.\n\n## Tim Topologi: Cara Baru Memikirkan Tentang Tim\n\nPendekatan Tim Topologi membawa pemikiran baru seputar struktur tim yang efektif untuk pengiriman perangkat lunak perusahaan. Ini menyediakan panduan yang konsisten dan dapat dilaksanakan untuk mengembangkan desain tim secara terus-menerus agar bisa menyesuaikan dengan perubahan teknologi, orang, dan bisnis, mencakup ukuran, bentuk, penempatan, tanggung jawab, batas, dan interaksi tim dalam membangun dan menjalankan sistem perangkat lunak modern.\n\nTim Topologi menyediakan empat jenis tim fundamental - yang sejalan dengan aliran kerja, platform, memungkinkan, dan sub-sistem yang rumit - dan tiga mode interaksi tim inti - kolaborasi, X-as-a-Service, dan memfasilitasi. Bersama-sama dengan kesadaran atas hukum Conway, beban kognitif tim, dan cara menjadi organisasi pencium, Tim Topologi menghasilkan pendekatan yang efektif dan humanistik untuk membangun dan menjalankan sistem perangkat lunak.\n\nKhususnya, pendekatan ini melihat cara di mana berbagai topologi tim dapat berkembang dengan kedewasaan teknologi dan organisasi. Periode penemuan teknis dan produk biasanya memerlukan lingkungan yang sangat kolaboratif (dengan batas tim yang tumpang tindih) untuk berhasil. Namun, tetap mempertahankan struktur yang sama ketika penemuan sudah selesai (teknologi dan produk yang sudah mapan) bisa menyebabkan usaha yang sia-sia dan salah paham.\n\nDengan menekankan model adaptif untuk desain organisasi dan secara aktif memprioritaskan interaksi tim, pendekatan Tim Topologi menyediakan mekanisme kunci yang tidak terikat teknologi bagi perusahaan-perusahaan yang bergantung pada perangkat lunak modern untuk menyadari kapan perubahan strategi diperlukan (baik dari sudut pandang bisnis atau teknologi). Tujuannya adalah untuk membantu tim memproduksi perangkat lunak yang sejalan dengan kebutuhan pelanggan dan lebih mudah untuk dibangun, dijalankan, dan dimiliki.\n\nTim Topologi juga menekankan pendekatan humanistik dalam merancang dan membangun sistem perangkat lunak. Ia melihat tim sebagai elemen yang tidak terpisahkan dalam pengiriman perangkat lunak dan mengakui bahwa tim memiliki kapasitas kognitif yang terbatas yang perlu dihormati. Bersama dengan desain tim yang dinamis yang kuat berdasarkan hukum Conway, Tim Topologi menjadi alat strategis untuk menemukan solusi.\n\n### Kebangkitan Hukum Conway\n\nKita telah menyebutkan pentingnya Hukum Conway sebagai pendorong untuk desain dan evolusi tim. Tetapi apa sebenarnya hukum ini?\n\nPada tahun 1968, peneliti sistem komputer Mel Conway menerbitkan makalah di Datamation yang berjudul \"How Do Committees Invent?\" di mana dia menjelajahi hubungan antara struktur organisasi dan desain sistem yang dihasilkan. Artikel ini penuh dengan wawasan yang cemerlang, beberapa di antaranya akan kita bahas nanti dalam bab ini, tetapi inilah frasa yang dikenal sebagai hukum Conway: \"Organisasi yang merancang sistem ... terikat untuk menghasilkan desain yang merupakan salinan dari struktur komunikasi organisasi tersebut.\"\n\nConway berdasarkan pengamatannya pada organisasi yang membangun sistem komputer elektronik awal. Menurutnya, \"hukum\" ini menunjukkan korelasi kuat antara jalur komunikasi sebenarnya suatu organisasi (struktur penciptaan nilai yang disebut Pflaeging) dan arsitektur perangkat lunak yang dihasilkan, atau apa yang disebut penulis Allan Kelly sebagai \"kekuatan homomorfik\". Kekuatan homomorfik ini cenderung membuat bentuk yang sama antara arsitektur perangkat lunak dan struktur tim. Dengan kata lain, membangun perangkat lunak membutuhkan pemahaman tentang komunikasi antar tim untuk dapat secara realistis mempertimbangkan jenis arsitektur perangkat lunak yang memungkinkan. Jika arsitektur sistem teoretis yang diinginkan tidak cocok dengan model organisasi, maka salah satu dari keduanya harus berubah.\n\nEric Raymond menyatakan hal ini dengan cara yang lucu dalam bukunya The New Hacker's Dictionary: \"Jika Anda memiliki empat kelompok yang bekerja pada kompilator, Anda akan mendapatkan kompilator 4 kali.\"\n\nSejak tahun 1968, semakin jelas bahwa hukum Conway terus berlaku untuk semua perangkat lunak yang dibangun. Mereka di antara kita yang telah membangun sistem perangkat lunak yang harus mematuhi \"blueprint\" arsitektur pasti ingat memiliki waktu ketika terasa seperti kita melawan arsitektur daripada membantu mengarahkan pekerjaan kita ke arah yang tepat. Nah, itu adalah hukum Conway dalam tindakan.\n\nStruktur tim harus sesuai dengan arsitektur perangkat lunak yang dibutuhkan atau berisiko menghasilkan desain yang tidak diinginkan.\n\nSejenis \"kebangkitan\" hukum Conway terjadi sekitar tahun 2015, ketika arsitektur mikro layanan meningkat. Khususnya, James Lewis, Direktur Teknis di Thoughtworks, dan yang lainnya mengembangkan ide untuk menerapkan \"manuver Conway terbalik\" (atau manuver Conway terbalik), di mana suatu organisasi berfokus pada mengorganisir struktur tim untuk cocok dengan arsitektur yang mereka inginkan sistem untuk memamerkan daripada mengharapkan tim untuk mengikuti desain arsitektur yang diperintahkan.\n\n### Beban Kognitif dan Bottlenecks\n\nKetika kita berbicara tentang beban kognitif, mudah dipahami bahwa setiap orang memiliki batas pada berapa banyak informasi yang dapat mereka ingat dalam pikiran mereka pada setiap saat. Hal yang sama terjadi pada setiap tim dengan cara hanya menambahkan kapasitas kognitif semua anggota tim.\n\nNamun, kami hampir tidak pernah membahas beban kognitif ketika menugaskan tanggung jawab atau bagian perangkat lunak tertentu ke suatu tim. Mungkin karena sulit untuk mengkuantifikasi kapasitas yang tersedia dan apa yang akan menjadi beban kognitifnya. Atau mungkin karena tim diharapkan untuk menyesuaikan diri dengan apa yang diminta tanpa banyak bertanya.\n\nKetika beban kognitif tidak dipertimbangkan, tim tersebar tipis mencoba menangani jumlah tanggung jawab dan domain yang berlebihan. Tim seperti ini kekurangan kapasitas untuk mengejar penguasaan di bidangnya dan mengalami kesulitan dalam beralih konteks.\n\nMiguel Antunes, R&D Principle Software Engineer di OutSystems, sebuah vendor platform low-code, memberikan contoh tantangan ini. Tim Produktivitas Rekayasa mereka di OutSystems berusia lima tahun. Misi tim adalah membantu tim produk menjalankan build mereka dengan efisien, memelihara infrastruktur, dan meningkatkan eksekusi pengujian. Tim terus bertumbuh dan mengambil tanggung jawab tambahan seputar integrasi berkelanjutan (CI), pengiriman berkelanjutan (CD), dan otomatisasi infrastruktur.\n\nKorban keberhasilan mereka sendiri, perencanaan sprint untuk tim yang kini terdiri dari delapan orang ini adalah campuran permintaan di seluruh tanggung jawab mereka. Prioritisasi menjadi sulit, dan sering beralih konteks bahkan dalam satu sprint mengakibatkan penurunan motivasi orang-orang. Hal ini tidak mengherankan jika kita mempertimbangkan tiga elemen motivasi intrinsik menurut Dan Pink: otonomi (terhambat oleh jongkok konstan permintaan dan prioritas dari beberapa tim), penguasaan (\"jack of all trades, master of none\"), dan tujuan (terlalu banyak domain tanggung jawab).11\n\nSementara tim dalam contoh industri ini menyediakan layanan internal untuk tim pengembangan, efeknya sama untuk tim yang bekerja pada perangkat lunak untuk pelanggan eksternal. Jumlah layanan dan komponen yang menjadi tanggung jawab tim produk (dalam kata lain, permintaan pada tim) biasanya terus bertambah dari waktu ke waktu. Namun, pengembangan layanan baru sering direncanakan seolah-olah tim memiliki ketersediaan penuh dan beban kognitif nol untuk memulainya. Pengabaian ini problematis karena tim tetap diharuskan untuk memperbaiki dan meningkatkan layanan yang ada. Akhirnya, tim menjadi bottleneck pengiriman, karena kapasitas kognitif mereka telah jauh melebihi batas, menyebabkan keterlambatan, masalah kualitas, dan seringkali, penurunan motivasi anggota tim.\n\nKita perlu memprioritaskan tim terlebih dahulu, menganjurkan untuk membatasi beban kognitif mereka. Berpikir secara eksplisit tentang beban kognitif bisa menjadi alat yang ampuh untuk memutuskan ukuran tim, menugaskan tanggung jawab, dan menetapkan batas dengan tim lain. (Kami akan membahas ini secara detail di Bab 3.)\n\nSecara keseluruhan, pendekatan Topologi Tim menganjurkan desain organisasi yang dioptimalkan untuk aliran perubahan dan umpan balik dari sistem yang berjalan. Ini memerlukan pembatasan beban kognitif pada tim dan merancang komunikasi antartim secara eksplisit untuk membantu menghasilkan arsitektur sistem perangkat lunak yang kita butuhkan (berdasarkan hukum Conway).\n\n### Ringkasan: Rethink Struktur Tim, Tujuan, dan Interaksi\n\nMengembangkan dan mengoperasikan perangkat lunak secara efektif untuk sistem dan layanan yang saling terhubung memerlukan organisasi untuk mempertimbangkan banyak dimensi yang berbeda. Secara historis, kebanyakan organisasi telah melihat pengembangan perangkat lunak sebagai jenis manufaktur yang harus diselesaikan oleh individu yang terpisah yang diatur ke dalam spesialisasi fungsional, dengan proyek-proyek besar yang direncanakan dari awal dan dengan sedikit pertimbangan untuk dinamika sosioteknis. Hal ini menyebabkan masalah yang umum terjadi seperti yang digambarkan pada Gambar 1.2 di halaman 12.\n\n![Obstacles to Fast Flow](assets/1683525609.png)\n\nGerakan Agile, Lean IT, dan DevOps membantu menunjukkan nilai besar dari tim yang lebih kecil dan lebih otonom yang sejalan dengan aliran bisnis, mengembangkan dan melepaskan dalam siklus kecil dan iteratif, serta melakukan perbaikan berdasarkan umpan balik dari pengguna. Lean IT dan DevOps juga mendorong kemajuan besar dalam alat telemetri dan metrik untuk sistem dan tim, membantu orang-orang yang membangun dan menjalankan perangkat lunak untuk membuat keputusan proaktif dan lebih dini berdasarkan tren masa lalu, daripada hanya merespons insiden dan masalah saat muncul.\n\nNamun, organisasi tradisional sering terbatas dalam kemampuan mereka untuk sepenuhnya memanfaatkan manfaat dari Agile, Lean IT, dan DevOps karena model organisasi mereka. Tidaklah mengherankan bahwa fokus kuat pada adopsi otomatisasi dan alat, sementara perubahan budaya dan organisasi secara tidak teratur diatasi. Perubahan terakhir jauh lebih sulit untuk divisualisasikan, apalagi untuk mengukur efektivitasnya. Namun, memiliki struktur tim, pendekatan, dan interaksi yang tepat, serta memahami kebutuhan mereka untuk berevolusi dari waktu ke waktu adalah kunci yang berbeda untuk kesuksesan dalam jangka panjang.\n\nKhususnya, diagram organisasi tradisional tidak sinkron dengan realitas baru dari pengaturan (ulang) tim untuk pengetahuan kolaboratif dalam lingkungan yang penuh dengan ketidakpastian dan kebaruan. Sebaliknya, kita perlu memanfaatkan hukum Conway (desain organisasi mendominasi desain arsitektur perangkat lunak), pembatasan beban kognitif, dan pendekatan tim-first untuk merancang tim dengan tujuan yang jelas dan mempromosikan interaksi tim yang memprioritaskan aliran pengiriman perangkat lunak dan adaptabilitas strategis.\n\nTujuan dari Team Topologies adalah memberi Anda pendekatan dan alat mental untuk memungkinkan organisasi Anda beradaptasi dan menemukan tempat dan waktu secara dinamis ketika kolaborasi diperlukan, serta kapan yang terbaik untuk fokus pada eksekusi dan mengurangi overhead komunikasi.\n\n## Catatan\n\nKetika melakukan riset untuk buku ini, kami menemukan contoh interaksi strategis dan kolaboratif yang menarik di bidang yang sangat berbeda. Ternyata, ikan grouper dan belut moray, spesies yang tidak terkait satu sama lain (seperti silo pada umumnya), secara eksplisit bekerja sama (melalui sinyal) untuk berburu ikan kecil yang bersembunyi di celah-celah. Belut masuk ke celah dan menakuti ikan kecil, yang kemudian terpaksa keluar dan menjadi mangsa yang mudah bagi ikan grouper. Lanjutkan membaca untuk mengetahui bagaimana cara memungkinkan grouper dan belut di organisasi Anda untuk bergabung demi aliran dan hasil bisnis yang lebih baik!","n":0.018}}},{"i":87,"$":{"0":{"v":"Self Driving","n":0.707},"1":{"v":"\n#self-improvement\n#rhenald-kasali\n\nBuku ini ditulis oleh Bapak Rhenald Kasali, Ph,D., Beliau adalah seorang guru besar FEUI, Praktisi Management dan Penulis Buku.\n\nDunia usaha menghendaki manusia-manusia berkarakter driver yang berkompetensi, namun juga cekatan, gesit, berinisiatif dan kreatif.\nMasalahnya tanpa disadari kampus-kampus saat ini malah membentuk manusia-manusia menjadi passenger. \nKaum mudanya cenderung pandai namun outputnya adalah manusia-manusia penumpang. \nYang dimana fokus mereka hanyalah text book atau memindahkan pengetahuan dari buku ke kertas ujian. \nJadi pintar itu adalah pintar kertas dan sarjananya sangat mungkin menjadi sarjana kertas.\n\nBerbeda dengan para TKI diluar negri (Hongkong, Jepang, Taiwan), mereke mungkin tidak bersekolah tinggi, \ntapi mereka dipaksa lingkungan untuk berpikir kritis menghadapi dunia baru yang sangat menuntut. \nMereka melatih kegesitan, belajar dari kehidupan.\n\nDengan tuntuntan dan tantangan seperti itu akan mengasilkan manusia-manusia driver,tak ada waktu bagi mereka untuk diam.\nSeperti ucapan Syekh Mohammand Al-Mahtum yang membuat dasar-dasar perubahan di Dubai, dia berkata.\n\n> Kita ini seperti rusa di padang sabana yang dikelilingi harimau yang siap memangsa. \n> Kalau tidak bisa lari lebih kencang, maka kita akan menjadi mangsa mereka.\n\nIntinya adalah tentang mengubah mentalitas dan ini bukan lah perubahan yang mudah.\n\nPertanyaannya,\n\n- Bagaimana cara melatihnya?\n- Sudah tepatkan cara-cara yang dilakukan oleh pusat pelatihan? (sekolah, universitas)\n- Apakah dengan memberikan ilmu berupa pengatahuan manajerial mereka otomatis akan mendapatkan kompetensi?\n\n> Orang jujur itu mujur. Tetapi jujur dan disiplin seperti sekeping koin dengan dua sisi, saling melengkapi.\n> Karena kejujuran harus menjadi komitmen dan komitment dibentuk oleh Self Discipline.\n> Inilah modeal dasar Self Driver\n> - Iwan Setiawan, CEO PT Rintis Sejahtera\n\n## 01: Ini Soal Mandataris Kehidupan\n\nKita semua adalah pemeang mandat kehidupan. Sewaktu dilahirkan, Tuhan hanya bersabda, \"Inilah hidupmu\" setelah itu jelajahi sendiri.\nKarena suratnya dipegang orangtua lebih dulu, mereka ditugasi untuk memelihara dengan penuh kesungguhan.\nSetelah itu, suratnya pun dikembalikan dan pemegangnya bisa memilih untuk menjelajahi kehidupan itu engan penuh tantangan atau diam saja sebagai penumpang.\n\nMenjelajahi kehidupan berarti bertarung menghadapi tantangan dan perubahan, seperti seorang pengendara yang tak bebas dari resiko.\nKadang ia tergores, berbenturan dengan kendaraan lain. Dan kalau kecelakaan dialah yang diadili, bukan penumpangnya.\nSebaliknya, untuk menjadi penumpang, Lo boleh mengantuk, tertidur, terdiam, tak perlu tahu arah jalan, bahkan tak perlu merawat kendaan sama sekali.\n\nAda yang menggunakan surat mandat itu untuk tumbuh dan berkarya ada juga yang cuma menyimpan surat itu didalam sakunya sebagai dokumen pribadi.\nKedua duanya sama-sama mempunyai mandat, tapi keberadaannya berbeda. Dan tentu saja hidupnya berbeda.\nSebagian orang bilang nasib dan yang lain bilang ini adalah pergulatan hidup yang diawali dengan ada atau tidaknya kesadaran mandataris itu sendiri.\n\nSesuatu yang ada pada diri lo, ya itulah kendaraan lo. Ia menjelma menjadi kekuatan mencipta, berkarya, berprestasi dan berkreasi.\nKita menyebutnya sebagai gabungan antara kompetensi (apa yang lo bisa), kecekatan dan perilaku.\n\nKalo lo kuliah atau sertifikasi dan merasa dengan label-label itu akan membuat lo sukses, lo salah.\nJangan jual label-label itu, tapi jualah apa yang lo bisa lakuin. Tahu bukan berarti bisa.\n\nJadilah driver, Driver adalah sebuah sikap hidup yang membedakan dirinya dari passenger.\nLo tinggal memilih, ingin duduk manis, menjadi penumpang dibelakang atau mengambl resiko sebagai driver di depan?\n\nAda tiga hal yang harus dilakukan yaitu,\n\n- Men-drive diri sendiri\n- Men-drive orang lain\n- Men-drive bangsa\n\nKalau lo tidak bisa men-drive diri lo sendiri, bagaimana lo bisa men-drive orang lain? dan berarti gak ada kepemimpinan dari diri lo.\n\nSeorang driver bisa hidup dimana pun mereka berada dan selalu menumbuhkan harapan.\nMereka selalu mengajak orang untuk terus berkembang selalu melakukan pembaharuan.\nMereka berinisiatif memulai perubahan tanpa ada yang memerintahkan, namun tetap rendah hati dan kaya empati.\nSeorang driver harus seimbang antara logic (rasionalitas, hitung-hitungan, analisis dan targetnya) dengan hatinya (empati).\nMereka adalah orang tau arah dan resiko yang akan dihadapi.\nSedangkan passanger adalah orang orang yang terbelenggu dengan fix mindset.\n\nKesadaran yang dibentuk oleh pengalaman dan pendidikan itulah maksud dari driver mentality.\nPendidikan diperlukan untuk memperbaiki cara berpikir dan cara menjalani hidup yang menantang.\nBelajar artinya berpikir. Kalo lo ambil pendidikan cuma buat menghapal, ya lo rugi sih. \nIPK lo gak akan ada artinya kalo lo gak bisa berpikir dan cuma manfaatin hapalan aja.\n\nBerpikir juga gak ada batas waktunya, gak pernah berhenti cuma karena lo udah dapet ijasah.\nBagaimana lo bisa berpikir kalo lo gak berani ambil resiko? \nMenjadi driver sama dengan mengekspos diri lo terhadap resiko. \nTapi resiko itu hanya akan jadi masalah kalo lo ugal-ugalan.\n\nKetika lo udah takut buat melakukan \"kesalahan\" kecil, lo akan masuk kedalam mentalitas penumpang.\nOrang-orang yang gak pernah melakukan kesalahan sesungguhnya adalah orang yang gak berbuat apa-apa.\n\nTapi bisa gak sih, orang yang gak berpendidikan tinggi, punya mental driver?\nTentu bisa, tapi seorang driver tidak cukup hanya bermodalkan tekad dan semangat, lo butuh referensi dari pengetahuan akademis dan belajar dari orang lain.\nIntinya cara berpikir yang tepat adalah modal penting.\n\nPersoalan perubahan yang dihadapi manusia bukanlah mengadopsi hal-hal baru, melainkan sulitnya membuang kebiasaan lama. - Albert Einstein.\n\n## 02: Manusia Berpikir\n\nMengambil kutipan dari George Bernarr Shaw,\n\n> Hanya 2 persen dari orang orang berpikir, 2 persen berpikir kalo dia berpikir dan 95 persen memilih mati dari pada berpikir.\n\nApa yang terjadi dengan 95 persen itu? \nMereka terperangkapdalam mentalitas penumpang yang memilih menunggu ketimbang berinisiatif, \ngak merasa perlu mengeksplorasi jalan-jalan baru sehingga hanya tau jalan yang itu-itu saja,\ngak merasa perlu merawat kendaraan hidupnya, sehinga boleh mengantuk bahkan tertidur selama perjalanan karirnya yang mudah itu. \nMaksudnya autopilot.\n\nDari sejumlah orang yang menekuni profesi tertentu. Hanya kurang dari 2% yang benar-benar serius dan mengembangkan dirinya.\nYang lain terperangkap dalam mentalitas penumpang yang memilih untuk menunggu.\n\nSetiap manusia memiliki kendaraannya sediri. Pandangilah diri lo di cermin. \nJangan lihat sepotong-sepotong namun lihatlah seluruh tubuh lo dari ujung rambut hingga ujung jari.\nYa, itulah kendaraan lo. Dialah teman setia yang menemani diri lo kemanapun lo pergi. Dialah yang mengantarkan mimpi-mimpi lo sampai ketujuan.\n\nSetiap orang memiliki kendaraan yang kita sebut dengan diri. Dan dalam diri itu terdapat mentalitas atau jowa pembawa diri itu. \nMaka itulah kita bisa membedaka kedalamdua kategori mental: mentalitas penumpang dan mentalitas pengemudi.\n\nMenjadi pengemudi bukanlah sekedar menyetir dan memiliki surat izin. \nBanyak manajer memegang legalitas untuk memimpin tetapi tak banyak berbuat dalam posisinya itu.\nJabatan tinggi tapi belum tentu bisa disebut sebagai driver.\n\nAkibat yang terjadi jika bermental penumpang.\n\n1. Kurang kemandirian, cepat menyerah\n2. Dikendalikan oleh kehidupan \"rutin\" menjadi autopilot\n3. Mudah mengeluh dan bersungut-sungut sepanjang hidup\n4. Tidak tahu alternatif jalan keluar\n5. Mudah frustasi ketika suatu keadaan berubah tiba-tiba\n6. Kurang berhasil dalam karir dan usaha\n7. Menjadi boros meski tujuannya berhemat.\n\nPrinsip seorang diver adalah inisiatif, melayani, navigasi dan tanggung jawab.\nIa harus tau arah jalan dan cara memperbaiki serta merawat kendaraan.\nSadar bahwa sesuatu hanya akan menjadi lebih baik bila lo sendiri yang mengubahnya.\nLo adalah penentu masa depan, baik masa depan diri sendiri, keluarga maupun perusahaan tempat lo berada.\nDan lo juga penentu nasib bangsa. \n\nKuncinya adalah berpikir, keluar dari sangkar emas.\n\nMentalitas penumpang ditandai dengan:\n\n- Sudah puas dengan keadaan sekarang\n- Tidak menyukai tantangan baru\n- Menyerahkan masalah kepada atasa atau orang lain\n- Takut menghadapi masalah\n- Menunggu perintah dan menjawab dengan kata \"siap\"\n- Sangat mencintai jawaban atau kekuasannya\n- Dikendalikan oleh autopilot\n- Terlalu membanggangkan apa yang telah dicapai\n- Menyandera organisasi sebagai alat untuk \"menumpang hidup\"\n\nMentalitas driver ditandai dengan:\n\n- Sangat tidak puas dengan keadaan sekarang\n- Menyukai tantangan-tantangan baru, mengeksplorasi peluang-peluang baru\n- Memecahkan masalah bersama, menginspirasi orang lain.\n- Berkerja dengan hati, mencintai semama, menjaga hubungan baik, memiliki kepedulian.\n- Memimpin dengan pertanyaan, memperbaiki cara berpikir penumpang-penumpangnya.\n- Memberikan arah jalan yang jelas, merangkul orang-orang yang berbeda paham dengannya\n- Berani melakukan kesalahan-kesalahan kecil dan mengambil resiko terukur.\n- Sangat mencintai perubahan, namun rendah hati dan penuh empati\n- Dikendalikan oleh creative thinking\n- Selalu belajar tentang hal-hal baru\n- Membebaskan para sandera dari penumpang yang membajak organisasi\n\nUntuk menjadi seorang driver, maka diri lo sendiri yang menentukannya.\nLo sendiri yang mentukan mau terperangkap sebagai penumpang atau keluar sebagai pemimpin\n\nSeorang driver melakukan investasi diri seperti layaknya seorang pengusaha.\n\n- Dispilin diri\n- Menghadapi resiko\n- Bermain untuk menang\n- Kekuatan berpikir simple\n- 2C critical & creative thinking\n- Mindset yang tumbuh\n\nSeorang driver tidak akan tumbuh hanya dengan kekuatan dari dirinya sendiri, tapi juga tumbuh dengan kekuatan orang lain.\nBantulah orang lain agar mereka juga berhasil.\n\nSeorang driver bertugas membawa penumpang ke tempat tujuannya agar mampu meneruskan perjalanan berikutnya.\nSedangkan seorang passanger tidak memperdulikan orang orang disekitarnya.\n\nSeorang driver mengambangkan orang lain dengan berbagai pendekatan:\n\n- Goal setting dan mengambil keputusan\n- Memimpin dengan hatinya\n- Kekuatan memberi\n- Leadership 360 ke atas keawah dan kesamping\n\nKalo lo udah berhasi drive diri lo, drive orang lain, maka yang ketiga adalah drive organisasi lo.\nSeorang driver tidak membarkan organisasinya tidak tumbuh. Lo perlu memperbarui organisasi atau perusahaan lo menjadi perushaan yang tumbuh.\n\nUntuk men-drive orgnisasi, seorang driver memerlukan.\n\n- Berpikir strategis\n- Berbagai teori klasik, konsep-konsep dasar dan pandangan baru.\n- Pemahaman tentang competitiveness dan klaster yang didukung oleh pentingnya complementarity.\n- Berpkir perubahan dan adaptif\n- Berkerja dengan tata nilai dan etika\n- Agility\n\n## 03: Mengapa Kaum Muda Memilih Universitas\n\nSebagian orang menganggap perkembangan data orang yang masuk universitas makin banyak adalah sesuatu yang mengembirakan.\nBenarkah ini kabar gembira? Belum tentu, kenapa? karena banyak sekali sarjana pengangguran yang tidak siap dengan dunia kerja.\nPara orang tua mengirim anaknya ke universitas agar menjadi sarjana dan mereka berpikir dengan menjadi sarjana anak-anak itu otomatis telah berpikir.\nPada kenyataannya mereka hanya mendapat selembar ijasah dan tetap sulit berkerja.\n\nMengapa para sarjana sulit memperoleh pekerjaan?\nKarena semasa menjalani pendidikan mereka tidak berpikir, hanya menghafal. \nPadahal yang dibutuhkan adalah keterampilan dalam memindahkan pikiran kedalam tindakan nyata.\nTindakan hanya bisa didapat melalui latihan yang nantinya tersimpan di mucle memory (myelin).\nSedangkan pengetahuan disimpan di brain memory, brain memory baru bisa berkembang jika manusia melatihnya.\nDan celakanya, mereka tidak mendapatkan ini dibangu kuliah.\n\nApakah ada perusahaan tanpa driver? Bisa saja ada, dan gejalanya seperti ini:\n\nPertama, Mereka tidak berani mengambil keputusan. \nSelalu ragu ragu dalam bertindak dan menunggu approval orang lain. \nPadalah orang itu sudah berada dipuncak jabatan.\n\nKedua, Mereka selalu membutuhkan data.\nData diambil berulang ulang, \ntapi tidak ada rasa percaya diri sehingga organisasi lo berkerja mengumpulkan data terus menerus.\n\nKetiga, Waktu berkerja dihabiskan oleh meeting. \nWaktunya gak jelas. \nDan ketika selesai rapat tidak ada keputusan atau masih bingung.\n\nKeempat, Keputusan justru diambil oleh bawahan menjelang akhir, \ndan bawahan menjadi kurang bersemangat \nbahkan ragu ragu karena atasannya tidak memberi gambaran strategis \ndan menyatukan tindakan para bawahan yang bergerak sendiri sendiri\n\nKelima, Perusahaan tidak mengalami kemajuan.\nTetapi atasan berada di dalam jabatannya dalam tempowaktu yang panjang.\nJabatan aman, tapi satu persatu lampu di tempat lo berkerja mulai redup dan tidak ada gantinya.\n\nKeenam, Banyak masalah tapi tidak ada terobosan.\nSemua mencara aman.\nProgam sudah dibuat, tapi kegiatannya hanya rutin.\nKarena semuanya bersifat formalitas sehingga tidak ada terobosan.\n\nKondisi seperti ini membutuhkan \"tentara pembebasan\". Siapa dia? dialah yang disebut driver.\nDia adalah seorang yang berpikir, membuat langkah kreatif juga kritis terhadap informasi dan fakta.\n\nBagaimana cara menjadi driver yang menyenangkan dan penumpangnya bisa enjoy.\nLengkapi dan latih mereka agar menjadi jadi driver selanjutnya.\n\n\n## 04: Dua Jenis Penumpang: Bad And Good Passangers\n\nAda dua jenis penumpang, penumpang yang baik dan penumpang yang buruk.\n\nPenulis melakukan action research bersama sejumlah psikolog yang biasa menangani karyawan bermasalah.\nOrang-orang bermasalah ini biasanya menyakitkan bagi orang-orang disekitarnya, termasuk bagi atasan-atasannya.\nKepimimpinannya buruk, prestasi rendah, kurang disukai rekan-rekan kerja, tetapi gak mau mengundurkan diri.\nDitambah lagi, perusahaa tempat mereka berkerja enggan mengambil tindakan apa-apa.\n\nIni adalah gejala-gejala dari penumpang yang buruk.\n\n- gemar menyalahkan orang lain\n- menjadi sangat agresif\n- mudah jengkel\n- cepat dan sering mengeluh\n- hidup tak terarah\n- terlalu cepat menyerah\n- pesimistis\n- mudah menghasut orang lain untuk menjegal orang-orang baik\n- punya kecenderungan membalas dendam\n- menarik diri\n- hidup penuh kebencian\n- tak ada passion\n\nPerusahaan atau organisasi yang sehat perlu dukungan dari pegawai-pegawainya. \nNamum, kalau pasukan yang dipimpinnya sudah berubah menjadi kumpulan orang-orang yang \"sakit hati\" dan punya banyak kepentingan dan luka batin \nmaka bisa jadi bukan perubahan positif yang didapat, melainkan bumerang.\n\nBagaimana mengubah dari penumpang yang buruk menjadi penumpang baik? Ya, segera berubah.\n\nBerubah artinya selalu dimulai dengan menerima realitas, berdamai dengan diri sendiri, menerima suma dengan lapang dada, introspeksi diri.\nMasalahnya hanya satu, Lo mau apa engga untuk berubah? Mustahil kita mendapatkan hasil yang berbeda dari tindakan yang sama berulang-ulang.\n\n## 05: Dua Jenis Pengemudi: Bad And Good Drivers\n\nDua jenis pengemudi: yang baik dan yang buruk.\n\nJika mengambil perumpanaan sopir, Bad driver sama seperti sopir ugal-ugalan. \nIngatlah, the first class car membutuhkan the first class driver. \nPada setiap diri yang memiliki inteligensi yang tinggi, dibutuhkan pengemudi berkualitas tinggi pula.\nOrang-orang yang terlatih akan tahu menempatkan diri, kapan harus berbicara dan kapan harus mendengarkan.\nIa harus tahu pakan harus bergera maju dan kapan harus mundur.\n\nMungkin lo banyak menemukan orang-orang hebat yang tidak berada ditempat yang tepat. \nIa adalah good driver, tetapi ia dikelilingi oleh teman-teman yang buruk, yang asal bicara, asal bertindak.\nMereka bergerak cepat, berinisiatif tinggi, tetapi selalu menumbulkan masalah.\nKata-katanya tidak dipikirkan sebelum diucapkan, niatnya belum tentu tulus.\n\nOrang-orang yang kita sebut sebagai bad drivers akan lebih banyak mengambil energi kita,\nMengaak kita menngunakan tenaga untuk melakukan keributan-keributan ketimbang langkah langkah yang tepat.\nAkibatnya, reputasi kita perlahan0lahan tergerus, semakin terpuruk, semakin tidak dipercaya.\n\nBad drivers adalah kumpulan orang-orang yang sakit hati, agresif, mudah tersulut kebencian, \ntak menentukan arah tindakannya, lebih mencari pembenaran ketimbang kebenaran \ndan senang membuat alasan-alasan untuk menutupi kekalahan atau kesalah-kesalahannya.\n\nSopir ugal-ugalan ini akan membuat penumpang-penumpang baik belajar cara mengemudi kehidupan yang buruk.\nMereka akan menjadi orang yang mencari pembenaran dan senang memancing keributan.\nMereka hanya dapat dilibatkan kembali setelah lulus dari proses terapi diri,sebuah proses yang harus dimulai kembali.\nAtau melakukan self healing yang datang dari dalam diri sendiri.\n\nLalu siapakah yang bisa disebut dengan good drivers?\n\nGood diver adalah seorang inisiator, tokoh perubahan dan mampu menjadi role model bagi banyak orang. \n\nLalu bagaimana cara menjadi good driver?\nBisa dengan latihan assertiveness /seni bertutur kata, menampilkan gerak-isyarat yang menunjukan ketegasan namun tetap bersahabat.\nLo dilatih untuk berbicara secara terbuka, menyampaikan unek-unek dan hak lo.\nNamun dengan seni yang tinggi lo bisa sampaikan tanpa merendahkan diri lo atau orang lain.\nMalah mereka dapat menerima dengan hormat karena lo menegurnya dengan cara halus, santun dan tidak menyakiti perasaannya.\n\nIni bukan sekedar bahasa melaikan perasaan dan kedewasaan, kepercayaan diri, dan gesture. Melalui latihan itu lo dibangkitkan kesadaran diri (self awarenes).\nKemampuan bernegosiasi, mencaca isyarat, mengurangi agresivitas memperbaiki tone dan komunikasi.\n\nLatihan selanjutnya adalah berfikir dalam kotak baru. \n\nBefikir out of the box adalah latihan awal seorang passenger untuk menjadi seorang driver.\nIa harus memiliki kemampuan mencoba jalan jalan baru, keluar dari jalur-jalur utama, mengambil resiko tersesat tanpa harus melanggar hukum.\nMaka, ia pun mengenal peta besar, biasa melihat dari luar maupun dari dalam.\n\nLalu apa itu berfikir dalam kotak baru?\n\nKonsep ini diperkenalkan loleh Luc De Brabandere dan alan Iny pada tahun 2013.\nIni disebabkan oleh banyak hal yang telah ditemukan oleh manusia, sehingga ruang bagi lo untuk menemukan sesuatu yang bener-benar baru sangat terbatas.\nJadi yang dibutuhkan adalah cara baru dalam memandang segala hal yang sudah exist itu. \nMisalnya, Coba lo membayangkan seakan-akan perusahaan atau pemerintahan yang lo pimpim telah benar-benar lenyap. Mulailah dari awal.\n\nBerpikir dengan cara-cara baru itu akan memudahkan seseorang berubah dari passanger menjadi driver. \nPandanglah dengan segala potensinya dengan cara-carabaru.\n\n> Saya kasihan melihat anak-anak kita yang sesungguhnya bisa menjadi lebih hebat,\n> tetapi kirang dipercaya orangtua.\n> Berikan kepercayaan, tantangan dan dukungan, maka mereka dapat menjadi lebih hebat lagi.\n> Jangan kekang, hambat atau jadikan mereka passanger.\n> Trihatma Kusuma Haliman - Fouunder Podomoro University\n\n\n## 06: Self Dicipline\n## 07: Ambilah Resiko\n## 08: Play to Win\n## 09: The Power Of Simplicity\n## 10: Creative Thinking\n## 11: Critical Thinking\n## 12: Growth Mindset\n## 13: Epilog\n\nPembentukan mental dan karakter semasa muda itu sangat menentukan.\nPembentukan mental itu mencangkup ketrampilan-keterampilan hidup dasar yang membentuk fondasi kepemimpinan seseorang,\nsekaligus fondasi ekonomi satu bangsa.\nMentalitas passenger pada dasarnya terbentuk karena kurang terlatihnya lif skills seseorang sehingga individu itummenjadi tidak cekatan dan terbelenggy.\nExecutive function dan self regulationnya tidak jalan. \nTerdapat indikasi kuat anak-anak muda sangat tidakfokus dalam berkerja.\nPikirannya bercabang-cabang, lambat laun mereka akan sangat mengandalkan corporate branding sehingga inisiatif mereka untuk mendatangi dan melaynikurang kuat.\nUmumnya punya ilmu, tetapi maaf \"malas\" menggunakan ilmu-ilmu yang mereka miliki untuk berpikir, menalisis, mencari penyebab dan memecahkan masalah-masalah yang dihadapi.\n\nKalau tidak kita bentuk, maka mereka akan lebih banyak mengeluh karena semakin hari semakin terlihat tidak berkarya, lalu terancam berbagai sanksi.\nMulailah mereka merasa diperlakukan kurang adil karena gaji teman-temannya yang lebih muda naik lebih cepat, posisi para driver melonjak tinggi sementara mereka tetap dibawah.\nMenjadi compainer dan terlihat kumuh, kurang mampu membeli kesejahteraan dan kebahagiaan.\n\nSetiap passenger bisa memlih, menjadi bad atau good atau sekalian menjadi bad driver.\nDan perusahaan ayau institusi pun punya piliham\"\nmemasukan mereka ke dalam lemari es atau melakukan transformasi.\n\nKaum muda perlu dilatih tiga hal:\n\n- working memory (kemampuan menata informasi)\n- inhibitory control (tahu dan tidak melakukan apa yang tidak boleh diucapkan /dilakukan) /pengendalian diri\n- cognitive flexiibility (kemampuan beradaptasi)\n\nKetiga hal itulah yang akan membentuk generasi emas yang bertanggung jawab dan produktif.\nMereka sedari dini perlu dibentuk untuk berkerja secara efektif, fokus, tahu dan berkerja dengan aturan, sikap positif terhadap oranglain, mengatasi ketidaknyamanan dan permintaan yang beragam, serta cara mengelola infirmasi yang datang bertubi tubi.\n\nMemberikan tantangan pada kamumuda atau pegawai  itu penting. Bahkan, lebih pending dari sekadar pujian.\nTantangan yang dibasakan akan melatih working memory, fokus, dan cognitive flexibilitu seseorang. \nDan ini sangat menentukan kualias seseorang untuk menjadi driver atau passenger.\n\nHidup yang indah adalah hidup yang bermanfaat, bermatabat dan tumbuh.\n\n> Jika anda ingin menaklukan rasa takut, jangan berpangku tangan didalam rumah dan diam didepannya.\n> Pergilah keluar, temui banyak orang dan buatlah diri anda sibuk.\n> - Dale carnegie\n","n":0.019}}},{"i":88,"$":{"0":{"v":"Measure What Matters","n":0.577},"1":{"v":"\nPernah gak lo bekerja di perusahaan atau organisasi yang gak jelas, gak tau arahnya mau kemana tapi semuanya mau dicapai dan semuanya menjadi paling prioritas. \n\nMungkin beberapa dari kalian pernah mengalami.\n\nTenang, banyak kok yang kaya gini. Bingung mau ngapain karena semuanya mau dikerjain.\n\nPerusahaan atau organisasi yang memiliki terlalu banyak tujuan, bisa katakan gak memiliki tujuan sama sekali.\n\nKok Bisa?\n\nya, karena setiap perusahaan atau organisasi memiliki resource yang terbatas dan kemampuan orang orang yang didalamnya pun terbatas. Kalau terlalu banyak tujuan, apalagi dalam waktu yang sebentar ini membuat kekuatan dari perusahaan terbagi bagi, seperti gak memiliki arah. Apalagi kalau tujuan setiap tim saling bersinggungan, saling tunggu tungguan, membuat hal yang sama, tau tau, gak kerasa satu quarter lewat tapi ternyata jalan ditempat.\n\nLo udah berusaha mati matian, kerja dan meeting sampe malem, resource sudah banyak yang kepakai, tapi gak efektif sama sekali cuma gara gara tujuannya gak jelas. Sayang banget kan?\n\nJadi harus gimana? Ya tentukan ide yang briliant lalu eksekusi ide tersebut dengan sangat baik. Lalu review secara berkala. Dan karena itu OKRs adalah jawabannha.\n\nOKRs artinya Objective dan Key Result. Teknik ini membantu kita untuk mendefinisi tujuan dan memecah tujuan tersebut menjadi sesuatu yang bisa dilakukan dan penting. Lalu bagaimana caranya untuk bisa tetap stransparan untuk mencapai tujuan yang sudah di atur.\n\nJadi harapan dari penulis Bapak John Doer, setiap orang didalam perusahaan bisa bekerja secara tim untuk mencapai tujuan sehingga perusahaan memiliki arah yang lebih clear.\n\nMau penjelasan lebih detail? Stay tune terus, gw akan membahas 6 poin penting yang bisa kita jadikan inspirasi ketika lo mau menerapkam OKRs","n":0.063}}},{"i":89,"$":{"0":{"v":"Madilog","n":1},"1":{"v":"\nMadilog itu buku yang sering banget dibahas orang. Banyak yang bilang ini buku penting buat belajar berpikir kritis. Tapi jujur aja, gue berkali-kali coba baca, selalu mentok. Gaya bahasanya ribet, cara bertuturnya juga gak gampang dipahami. \n\nSekarang, gara-gara tiba-tiba punya banyak waktu luang (thanks to layoff wkwkwk), gue akhirnya mutusin buat baca dan nyelesain buku ini. Tapi kenapa? Kenapa gue harus baca buku beginian di tahun 2025?\n\nCoba lo pikir, beberapa tahun terakhir, lo pasti liat:\n\n- Pesulap Merah vs dukun, orang masih percaya hal mistis di era internet.\n- Ferry Irwandi nantangin dukun, dan gak ada yang bisa nyatet dia wkwkwk.\n- Orang gampang percaya hoax, gak kritis sama kebijakan pemerintah, dan gak paham gimana sistem ekonomi ngerugiin mereka sendiri.\n- Banyak yang males mikir, asal ikut-ikutan, ujung-ujungnya rungkad: kejebak pinjol, judol, atau sekadar jadi korban clickbait.\n\nBuku ini ngajarin lo buat berpikir lebih tajam, lebih kritis, dan gak gampang ditipu—baik oleh dukun, pemerintah, maupun sistem yang ada. Gak cuma soal sejarah, tapi soal gimana cara kita mikir di zaman sekarang. Nah, ini catatan gue selama baca Madilog. Moga-moga lo bisa dapet sesuatu juga dari sini (kalo sempet mending baca sendiri aja wkwkwk). \n\n## IKLIM\n\nSaat membaca bagian **IKLIM**, gue merasa kondisi tahun 1942, ketika Tan Malaka menulis buku ini, tidak jauh berbeda dengan kondisi intelektual orang Indonesia saat ini.\n\n> *\"Saya pikir otak proletar mesin Indonesia tak bisa mencernakan paham yang berurat dan tumbuh pada masyarakat Indonesia dalam hal iklim, sejarah, keadaan jiwa dan idamannya.\"*\n\nGue merasa pada masa itu, kaum intelektual terlalu banyak mengadopsi teori Barat tanpa benar-benar memahami kondisi rakyatnya sendiri. Mereka belajar Marxisme, liberalisme, atau nasionalisme dari buku-buku Eropa, tapi belum tentu bisa mengaitkannya dengan realitas petani dan buruh Indonesia yang masih miskin, minim pendidikan, dan hidup di bawah sistem feodal. Saat itu, mereka memperjuangkan kemerdekaan dari Belanda dan Jepang.\n\nHal yang sama terjadi sekarang. Pemerintah saat ini justru mencoba meniru sistem Nordic dengan menaikkan pajak tanpa terlebih dahulu mengadaptasi atau menyediakan fasilitas yang layak bagi rakyatnya. Ini terasa aneh sekali. Jadi, kebijakan ini gak lebih dari \"asal ikut-ikutan\" tanpa memikirkan kesejahteraan rakyatnya uangnya mau tapi kasih fasilitas ala kadarnya. Setelah marah dengan tagar [#TolakPPN12Persen](https://x.com/search?q=%23TolakPPN12Persen&src=typed_query) ramai diperbincangkan, barulah pemerintah membatalkan kebijakan tersebut.\n\nDi sub-bab **Pendahuluan Perpustakaan**, banyak hal menarik sekaligus mengejutkan. Bayangin lo baru umur 20-an, tapi udah dianggap sebagai \"musuh negara\" cuma gara-gara tulisan lo cuy. Tan Malaka diburu karena dia mengkritik kolonialisme dan ngajarin rakyat cara berpikir kritis. Belanda, Inggris, sampai Jepang nganggep dia ancaman karena pemikirannya bisa bikin rakyat sadar dan berontak. \n\nKalau ini terjadi di zaman sekarang, mungkin dia bakal kena UU ITE atau dianggap \"radikal\" cuma karena ngajak orang buat mikir. Bedanya, di tahun 1940-an, yang ngejar dia bukan cuma polisi, tapi juga agen intelijen dari berbagai negara. Gue tuh pas baca sempet gak percaya, masa sih ada pemuda 20an tahun diburu gara-gara nulis, gue coba search ada dong yang bahas wkwkwkwk.\n\n- [Tan Malaka di Time](https://world.time.com/2013/06/15/exiled-in-hong-kong-famous-company-for-edward-snowden/slide/tan-malaka/)  \n- [Parallel Case of Tan Malaka - Cambridge](https://www.cambridge.org/core/books/abs/ho-chi-minh-in-hong-kong/parallel-case-of-tan-malaka/33478E6EDE9DB65C89FD049EB18C235A)  \n- [Asia-Pacific Journal](https://apjjf.org/2022/12/gunn)  \n\nSampai di titik ini, gue semakin kagum dengan cara pandang dan gaya hidupnya. Selain itu, ada beberapa paragraf menarik yang gue tangkap dari buku ini.\n\n> *\"Seorang pengarang atau ahli pidato, perlu akan catatan dari buku musuh, kawan ataupun guru.\"*\n\nGue nangkep maksud Tan Malaka di sini gini: kalau lo mau menang debat atau nyebarin ide, lo harus baca buku dari banyak perspektif. Banyak orang sekarang cuma baca informasi dari sisi yang mereka setujuin aja (filter bubble). Kalau lo liberal, lo cuma baca media pro-liberal. Kalau lo konservatif, lo cuma baca media pro-konservatif. Kalo lo suka mulyono lo akan baca berita pro mulyono, berita yang sebaliknya akan dikatain buzzer. Begutu juga dengan kubu anak abah dan politikus lainnya wkwkwkw\n\nIni strategi yang cerdas sih. Tan Malaka ngajarin cara main yang beda. Dia bilang: \"Kalau lo mau menang debat atau bikin argumen kuat, lo harus paham cara pikir lawan juga.\"\n\nDi era sekarang? Lo jangan cuma baca media yang lo suka, coba juga liat sudut pandang lawan biar bisa nangkep di mana titik lemahnya argumen mereka.\n\n> *\"Selain dari pada buat dipakai sebagai barang bahan ini, buku-buku yang berarti tentulah besar faedahnya buat pengetahuan dalam arti umumnya.\"*\n\nYang gue tangkep dari kalimat ini, buku itu bukan cuma buat bahan debat, tapi juga buat memperluas wawasan secara umum. Pendidikan dan pemikiran kritis itu penting, bukan cuma buat revolusi atau perlawanan, tapi juga buat ngebangun masyarakat yang lebih baik.\n\nIni juga masih relevan banget. Di era sekarang, orang lebih sering baca tweet pendek, nonton video TikTok 15 detik, atau percaya headline tanpa cek isi artikelnya. Masalahnya? Kalau lo cuma baca yang serba pendek dan gak dalem, lo gampang banget ketipu clickbait dan manipulasi informasi. Tan Malaka paham bahwa kalau lo mau punya pemikiran yang tajam, lo harus banyak baca dan bukan cuma baca yang pendek-pendek, tapi yang beneran ngasih lo konteks dan pemahaman mendalam.\n\nMungkin itu aja yang bisa gue tulis di sub-bab ini. Sisanya, kayak cara dia belajar pakai teknik \"jembatan keledai\", udah banyak yang ngebahas sih, jadi gue skip aja.\n\nOh iya, ada satu hal yang masih bikin gue penasaran—gimana caranya dia bisa nyampe Singapura tapi pakai paspor dari China? Wkwkwk.\n\n## Peringatan\n\nGue lanjut ke bagian **Pendahuluan - Peringatan**. Dari yang gue tangkep, Tan Malaka mau ngejelasin kalau logika itu penting, tapi jangan sampai terlalu terpukau sampai lupa batasannya. Materialisme, dialektika, dan logika harus dipakai bareng-bareng buat memahami realitas. Gue salfok sama kalimat ini:\n\n> *\"Pemikir borjuis dan pemikir feodal bergantung pada dialektika mistika itu seperti seekor semut hanyut bergantung pada sepotong rumput yang diayun-ayunkan gelombang.\"*\n\nKalau dipikir-pikir, *pemikir borjuis dan feodal* ini masih eksis sampai sekarang. Gue sering lihat orang-orang yang pakai dialektika mistik buat kepentingan sendiri. Ada yang beneran gak paham realitas dan cuma ikut arus, tapi ada juga yang sebenernya ngerti. Mereka tahu cara ini works buat ngejaga kekuasaan dan ngambil lebih banyak, makanya mereka sengaja pakai trik ini buat nge-bego-begoin rakyat. Misalnya\n\n- Politisi yang bilang \"kita harus bersabar, semua akan membaik dengan sendirinya,\" padahal sistemnya tetap korup dan gak ada yang diubah.\n- Orang kaya yang nyuruh rakyat miskin bersyukur dan rajin ibadah biar rezeki lancar, tapi mereka sendiri hidup enak karena ngehisap tenaga buruh.\n- Orang-orang yang percaya hidup harus \"nrimo\" dan gak boleh banyak tanya, padahal mereka sebenernya dimanfaatin sistem.\n\nIntinya? Dialektika mistika ini cara halus buat bikin orang tunduk, nerima keadaan, dan gak kritis sama realitas yang ada.\n\nDi sub-bab ini juga, gue mulai dikenalin sama istilah *Materialisme, Dialektika dan Logika (MADILOG)*. Gue coba memahami maksudnya biar bisa lebih gampang ngecerna isi buku ini. Intinya, **MADILOG** itu cara berpikir yang realistis, pragmatis, dan fleksibel. Kalau cuma pakai salah satu, belum tentu hasilnya tepat. Mungkin bakal lebih jelas kalau pakai contoh.  \n\n### [**Logika**](https://id.wikipedia.org/wiki/Logika)  \n\nLogika itu cara berpikir yang sistematis dan terstruktur. Kalau premisnya bener, maka kesimpulannya juga harus bener. Sederhananya, logika bikin kita bisa nyusun argumen yang masuk akal.  \n\nMisalnya:  \n\n- Kalau hujan, jalanan jadi basah.  \n- Sekarang hujan.  \n- Berarti, jalanan pasti basah.  \n\nKelihatannya simpel, kan? Tapi masalahnya, gak semua kenyataan bisa diteorikan sesederhana itu. Kalau cuma ngandelin logika doang tanpa lihat realitas, kita bisa aja kejebak di kesimpulan yang keliru.  \n\nContohnya, **\"Semua orang sukses karena kerja keras. Jadi kalau gue kerja keras, gue pasti sukses.\"**  \nKedengeran masuk akal, tapi kenyataannya gak sesederhana itu. Ada faktor lain yang ikut main—keberuntungan, networking, kesempatan, bahkan privilege. Jadi, logika itu penting, tapi kalau dipakai sendirian tanpa mempertimbangkan realitas, bisa-bisa kita percaya sesuatu yang kelihatannya bener, tapi sebenernya gak selalu sesuai sama dunia nyata.\n\n### [Dialektika](https://id.wikipedia.org/wiki/Dialektik) : Cara Berpikir yang Melihat Perubahan\n\nGue mulai ngerti kalau *Dialektika* itu bukan sekadar konsep perubahan biasa, tapi cara berpikir yang ngejelasin kenapa perubahan itu terjadi. Segala sesuatu di dunia ini gak statis, semuanya berkembang dan berevolusi karena adanya kontradiksi di dalamnya. Lo gak bisa cuma nerima keadaan tanpa mempertanyakan *kenapa* sesuatu terjadi dan *gimana* prosesnya bisa berubah. Justru, dengan mempertanyakan dan melihat kontradiksi, kita bisa dapet pemahaman yang lebih dalam.  \n\n**Dialektika bukan sekadar perubahan yang terjadi begitu aja. Dialektika itu soal memahami KONTRADIKSI yang menyebabkan perubahan.** Kalau lo cuma duduk diam dan berharap perubahan datang sendiri, itu bukan dialektika—itu [fatalisme](https://id.wikipedia.org/wiki/Fatalisme)! Sebaliknya, dialektika ngajarin kita buat ngelihat konflik dalam sistem yang ada dan nyari cara buat mendorong perubahan yang lebih baik. Biar lebih gampang, ada tiga hukum utama dialektika yang bisa bantu kita memahami kenapa dunia ini gak pernah benar-benar diam.\n\n#### **[Tiga Hukum Dialektika](https://www.historicalmaterialism.org/a-review-of-friedrich-engels-and-the-dialectics-of-nature-by-kaan-kangal/#:~:text='%20Engels%20listed%20three%20'laws%20of,168): Kenapa Perubahan Terjadi?**  \n\n\n1. **Perubahan Kuantitatif jadi Kualitatif**  \n   Hal kecil yang terus bertambah bisa menyebabkan perubahan besar. Contoh: \n   \n    - Sosial → Protes kecil di satu kota kalau terus meluas bisa berubah jadi revolusi. Contoh nyatanya [Arab Spring](https://en.wikipedia.org/wiki/Arab_Spring) atau [demonstrasi reformasi 1998](https://id.wikipedia.org/wiki/Era_Reformasi) di Indonesia.\n    - Sains → Air yang dipanaskan perlahan dari 25°C ke 99°C gak akan berubah bentuk. Tapi pas sampai 100°C? BOOM! Dia berubah jadi uap\n\n2. **Pertentangan dalam Segala Hal**  \n   Segala sesuatu berkembang lewat konflik. Contoh: \n\n    - Ekonomi → Buruh vs kapitalis, kelas pekerja pengen upah tinggi, pemilik modal pengen biaya produksi rendah. Konflik ini yang bikin sistem ekonomi terus berkembang.\n    - Teknologi → Dulu, orang males pake smartphone karena layar sentuhnya jelek. Lalu muncul iPhone, touchscreen makin canggih, sekarang malah gak ada tombol sama sekali.\n\n3. **Negasi atas Negasi**  \n   Sistem lama digantikan oleh sistem baru, lalu berevolusi ke bentuk lain. Contoh: \n\n    - Ekonomi → Dulu manusia pake barter → uang logam → uang kertas → sekarang digital currency & crypto.\n    - Politik → Feodalisme runtuh, muncul monarki konstitusional → lalu berkembang jadi demokrasi modern.\n    - Teknologi → Dulu orang pakai Kaset (yang kalo mau rewind lo puter pake pulpen wkwkwk), terus pindah ke MP3, sekarang streaming langsung di Youtube Music atau Spotify.\n    - Transportasi → Dulu naik kuda, terus ada kereta uap, sekarang ada mobil listrik.\n\n**Dialektika bukan asal membantah tanpa dasar.** Konsep ini ngelihat bahwa setiap ide berkembang lewat kontradiksi. Makanya, kalau kita mau benar-benar paham sesuatu, kita harus ngerti gimana pertentangan itu bekerja.  \n\n**Kalau lo ngerti dialektika, lo bakal sadar kalau perubahan itu bukan sekadar \"hukum alam\". Ada cara buat memahami dan bahkan mengarahkannya!**\n\n### [**Materialisme**](https://id.wikipedia.org/wiki/Materialisme)  \n\nOke, sekarang gue coba untuk memahami materialisme, materialisme ini adalah cara berpikir yang fokus ke fakta dan realitas yang kongkrit. Segala sesuatu yang ada di muka bumi ini pasti punya penyebab materiil, gak ada tuh yang kebetulan dan ditentukan oleh takdir. Kalau ada kejadian atau fenomena tertentu, pasti ada faktor lain yang bisa dijelasin. Materialisme ngajarin kita buat liat bukti nyata dan pengalaman asli dalam memahami sesuatu. Misalnya:\n\n- Orang miskin bukan karena \"sial\" atau \"karma,\" tapi karena faktor ekonomi, akses ke pendidikan, dan ketimpangan sosial.\n- Teknologi bukan \"keajaiban,\" tapi hasil dari riset, investasi, dan pengembangan bertahun-tahun.\n- Harga bahan pokok naik bukan karena \"kutukan,\" tapi karena rantai pasokan, inflasi, dan kebijakan ekonomi.\n\nBerangkat dari pengetahuan materialisme, lo udah bisa melihat realitas dan fakta. Tapi supaya lo bisa menganalisis sesuatu secara lebih mendalam, kita perlu menggabungkan materialisme dengan logika dan dialektika. Lo pake logika materialisme kalau lo mau memahami sesuatu yang sifatnya tetap dan konkret, misalnya:\n\nLogika Materialisme → Dipakai buat memahami sesuatu yang tetap dan konkret. Contoh:\n\n- Gimana cara kerja mesin?\n- Kenapa algoritma Youtube bisa ngarahin kita ke video tertentu?\n- Kenapa harga barang bisa naik dan turun?\n\nTapi kalau lo mau memahami sesuatu yang terus berubah dan berkembang, Misalnya:\n\n- Kenapa politik selalu berubah?\n- Kenapa sistem ekonomi berkembang dari feodalisme ke kapitalisme?\n- Kenapa budaya atau tren sosial terus bergeser?\n\nLo mesti mempertanyakan dan melihat sesuatu sebagai proses yang terus berubah. Ini yang disebut dialektika materialisme—cara memahami perubahan dengan melihat kontradiksi yang ada di dalamnya.\n\nKalau lo cuma pake logika materialisme doang, lo bakal ngerti realitas, tapi gak paham perubahan. Kalau lo cuma pake dialektika materialisme doang, lo bakal ngerti perubahan, tapi bisa kehilangan pijakan fakta konkret. Kalau lo gabungin semuanya, lo bakal bisa mikir secara sistematis, berbasis fakta, dan paham bagaimana perubahan terjadi.\n\nMaterialisme ngajarin kita buat melihat dunia berdasarkan fakta konkret, bukan mistik atau mitos. Logika materialisme bikin kita bisa memahami realitas yang ada, tapi kalau kita mau ngerti kenapa sesuatu berubah, kita butuh dialektika materialisme. Dengan gabungan ketiganya, kita bisa punya cara berpikir yang lebih tajam dan gak gampang dimanipulasi.\n\n## Melihat ke Muka\n\nOh ya, pas gue mulai masuk ke sub-bab terakhir dari pendahuluan, yaitu **Melihat ke Muka**. Ada satu kalimat yang menurut gue lucu:  \n\n> *\"Salah satu sifat rakyat Belanda yang terlihat pada saya adalah sifat demogogisch, ialah sifat berkilah, sifat suka mempertentangkan perkara kecil-kecil dengan melupakan pokok yang besar.\"*  \n\nKenapa ini lucu? Wkwkwkwk. Soalnya kalau kita lihat zaman sekarang, terus liat keributan di **X.com**, kayaknya apa aja bisa jadi bahan ribut. Hal-hal sepele dibesar-besarkan, sedangkan masalah yang lebih penting malah kelewat.  \n\nJadi gue kepikiran, ini sifat manusia pada umumnya? Atau jangan-jangan ini warisan dari Belanda yang *ditularkan* ke manusia Indonesia zaman sekarang? Wkwkwk.\n\nThanks yak, udah kelar bab pendahuluan! Sisanya bakal gue lanjut di artikel selanjutnya biar gak kepanjangan.","n":0.022}}},{"i":90,"$":{"0":{"v":"Filosofi Teras","n":0.707},"1":{"v":"\n#self-improvement\n\n## Kata Pengantar\n\nDitulis oleh A. Setyo Wibowo.\n\n### Filsuf dimedan perang\n\nAda yang pernah menonton film gladiator?\n\nAda makna yang bisa diambil dalam film gladiator. Dimana sang kaisar menang dalam peperangan tapi alih alih ikut berpesta, dia malah merenung. \n\nDia merenung seperti ini,\n\nApakah tindakanku tepat, apakah perang dengan korban begitu banyak memang diperlukan?\n\nKaisar selalu mencatat perenungan-perenungan pribadinya. Karena tulisan tulisannya bagus, maka sempat dibukukan dengan judul meditations.\n\nLewat latihan dan menuliskan setiap hari refleksi atas pengalamannya, Marcus Aurelius sang kaisar membangun jiwanya seperti benteng yang kokoh. Dia selalu berlatih memilah \"Apa yang tergantung padaku dan apa yang tidak tergantung padaku\" supaya terhindar dari penyakit jiwa yaitu emosi negatif.\n\nSelain itu Marcus Aurelius mempraktekan kategori yang paling sulit dalam filsafat stoa, yaitu kathekonta, kewajiban yang tidak wajib tapi layak dilakukan.\n\n### Filsafat stoa masih relevan?\n\nMasih, filsafat stoa adalah jalan hidup. Loh, bukannya ada agama? Ya, apa salahnya sih beragama sambil belajar filsafat? Supaya cara beragama kita makin mantap.\n\nKisah james stockdale, seorang tawanan perang yang disiksa sangat parah sekali, tapi dia bisa bertahan hingga akhirnya bisa bebas. Stockdale mengamalkan / mengingat pemikiran epiktos yang isinya.\n\nA. Pembedaan apa yang tergantung pada kita dan apa yang tidak tergantung pada kita\nB. Soal baik atau buruk itu tergantung cara jiwa menyelesaikannya.\nC. Segala situasi buruk yang menimpa kita bersifat indifferent atau netral saja.\n\nPada tahun 1990an berkembang sebuah metode psikokogi poluler bernama \"terapi kognitif\" katanya ini terinspirasi dari buddha dan epiktos yang intinya:\n\nTerapi kognitif meyatakan bahwa segala emosi yang mengganggu kita sebenarnya berasal dari cara penilaian yang salah. \nCara berpikir yang salah menyebabkan munculnya simtom-simtom yang   menggangu. \nCara pandang kita yang keliru dalam hidup menyebabkan kita stress, gelisah, depresi atau marah marah dengan alasan yang tidak jelas.\n\n## Bab 1\n\n### Survey Khawatir Nasional\n\nDi bab ini penulis membuat survey kekhawatiran yang diisi oleh 3000an responden. Dan hasilnya semua merasa khawatir. Tidak ada yang tidak khawatir.\n\nMaka kalo gitu kenapa kita harus khawatir tentang khawatir sih?\n\nKhawatir itu ada biayanya loh\n\n1. Menghabiskan energi dan pikiran.\n2. Menghabiskan waktu dan juga uang\n3. Menggangu kesehatan tubuh\n\nMasih banyak orang yang memisahkan kesehatan pikiran dan tubuh, seolah olah yang ada dipikiran tidak mempengaruhi kesehatan tubuh kita.\n\nDi bab ini ada wawancara dengan dokter Andri SpKj FAPM seorang spesialis kesehatan jiwa, yang akan membahas topik ini.\n\n#### Jadi, bagaimana sih stres bisa merusak kesehatan tubuh kita?\n\nAda kutipan kalimat dari hans seyle\n\n\"Bukan stres yang membunuh kita, tapi reaksi kita terhadapnya\" - hans seyle.\n\nPersepsi kita lah yang membuatnya, misalnya stres karena macet atau karena hutang. Khawatir seperti ini dalam jangka panjang akan menyebabkan tubuh mengeluarkan zat kortisol. Zat ini bersifat oksidatif, merusak apapun didalam tubuh kita. Jika dia menempel di pankreas, dia akan meningkatkan insulin. Yang menyebabkan kita, bawaannya ingin makan terus. Badan memanggil manggil karena badan kita merasa kalau dia sedang membutuhkan banyak energi.\n\nDokter Andri selalu berpesan kepada pasiennya, jangan stres lama lama karena jika sudah akut lo gak akan bisa membedakan lagi kondisi stress dan tidak, karena sudah terbiasa hidup dalam stres.  Badan akan merespon hal yang lo tidak tau kalau lo sedang stres. Contohnya penyakit dispesia atau gangguan lambung. Dalam jangka panjang bisa kena penyakit jantung, diabetes dan hipertensi.\n\n#### Apa bedanya takut, khawatir/cemas dan stres?\n\nKalau takut, lo tau apa yang lo takuti. \nMisal, takut setan atau takut berkelahi.\n\nKalau cemas, gak jelas penyebabnya. Orang menjadi cemas karena tidak bisa mengendalikan hidup disituasi ketidak pastian.\n\nKalau stres, artinya tekanan atau sesuatu yabg menggangu keseimbangan hidup kita. Ada stres fisik dan psikis.\n\nKalau fisik itu contohnya habis olah raga, kecapean. Kalau mental, lo merasa kelelahan diperkerjaan atau lingkungan. Dan ini ada sumbernya.\n\nKalau stresnya terus meningkat dan sudah tidak tau stressnya dari mana. Itu artinya lo sudah masuk fase cemas. Kalau dibiarkan akan menjadi depresi.\n\nAda dua gejala penting depresi,\nPertama mood yang sedih dan yang kedua putus asa, tidak ada harapan, merasa hidupnya kok gini gini aja.\n\nMakannya, kalo ada temen lo yang suka merasa \"hidup gw kok gini gini aja ya\" bisa jadi dia udah mengalami gejala awal depresi. Karena apa yang terucap bisa jadi memang refleksi dari hidup dia.\n\n#### Apa pesan untuk pembaca?\n\nCoba kenali sumber stressnya. Kalau kita bisa mengenali sumbernya, maka kita bisa melawannya.\n\nCatat hal hal dalam hidup yang bisa atau membuat lo bahagia. Lalu lakukan aktivitas yang membahagiakan itu.\n\n## Bab 2\n\n### The problem with positive thinking\n\nPerkembangan terakhir ilmu psikologi justru menemukan adanya masalah dengan anjiran berfikir positif. Artikel \"The problem with positive thinkkng\" menyebutkan bahwa justru sering menghambat kita.\n\nPositive Thinking menipu pikiran kita, bahwa seolah olah kita sudah mencapai apa yabg kita inginkan, sehingga melemahkan keuletan kita untuk mencapainya. Tapi, nyuruh orang buat berpikir relaistis aja juga gak membantu sih.\n\nPenulis artikel tersebut mengusulkan istilah \"mental contasing\" yaitu menggabungkan positive thiking atau membayangkan hasil yang diharapkan telah dicapai dengan memikirkan hambatan apa saja yang akan mereka temui.\n\n### Filosofi Teras\n\nKenapa namanya filosofi teras, karena dijaman itu para filsuf mengajarkan filosofi di teras atau stoa bahasa yunaninya. Dijaman itu disebutnya stoisism tapi karena banyak orang indonesia sulit menyebutnya maka diterjmahkan menjadi filosofi teras.\n\nDi bab ini juga penulis sedikit bercerita dampak dari filosofi teras. Setelag dia pelajari dan amalkan, hidupnya mebjadi lebih tenang. Tidak lagi terganggu hal hal negatif, kesialan, tekanan pekerjaan sampai orang orang toxic disekitar kita. \n\nPenulis juga merasa filosofi teras bisa kompatible dan sebagai tambahan dengan berbagai kepercayaan atau agama.\n\n#### Apa tujuan utama dari filosofi teras\n\n1. Hidup bebas dari emosi negatif, mendapatkan hidup tentram. Ketentraman ini hanya bisa diperoleh dengan memfokuskan diri pada hal hal yang bisa kita kendalikan.\n2. Hidup mengasah kebajikan. Ada empat kebajikan:\n    a. Kebijaksanaan: kemampuan mengambil keputusan terbaik dalam situasi apapun.\n    b. Keadilan: memperlakukan orang lain dengan adil dan jujur\n    c. Keberanian: keneranian berbuat yang benar, berani berpegang prinsip kepada yang benar.\n    d. Menahan Diri: disiplin, kesederhanaan, kepantasan dan kontrol diri.\n\n#### Kenapa stoisisme bisa tetap relevan\n\nKare Andreson menyebutkan dalam bukunya \"Why stoicism matter today\"\n\n1. Ditulis untuk menghadapi masa sulit\n2. Dibuat untuk globalisasi\n3. Filsafat kepemimpinan\n\n## Bab 3\n### Hidup selaras dengan alam\n\nSalah satu prinsip utama stoisme adalah kita harus hidup berselaras dengan alam. Maksudnya alam atau nature disini adalah kemampuan alami manusia yang memiliki nalar, akal sehat rasio dan kemampuan untuk hidup berkebajikan.\n\nManusia yang hidup berselaras dengan alam adalah manusia yang hidup sesuai desainnya, yaitu manusia yang bernalar.\n\nKetika kita tidak menggunakan nalar, kita menjadi rentan merasa tidak bahagia. Karena kita tidak selaras dengan alam, bayangkan singa yang seharusnya dipadang savana tapi kini ia harus ada diruangan kecil dikebun binatang.\n\nContoh ketika kita kehilangan nalar,\n\nKita baca postingan di media sosial yang bernada provokatif dan langsung emosi. Marah marah dibagian komen, memfoward tanpa mencari tau sebenarnya.\n\nKalau lo pernah ada diposisi itu, coba pikir lagi deh. Apakah semua tindakan tadi membawa hasil positif?\n\nSebisa mungkin disetiap situasi hidup kita tidak kehilangam nalar kita dan berlaku seperti binatang dan akhirnya berujung pada ketidak bahagiaan.\n\n## Bab 4\n### Dikotomi Kendali\n\nAda hal-hal yang dibawah kendali kita dan ada juga yang tidak.\n\nContoh yang tidak dibawah kendali kita.\n\n1. Opini orang lain\n2. Reputasi\n3. Kesehatan\n4. Kekayaan\n5. Kondisi saat lahir\n\nKalo yang ada dibawah kendali kita itu, contohnya\n\n1. Pertimbangan, opini pribadi atau persepsi kita\n2. Keinginan kita\n3. Tujuan kita\n4. Pikiran dan tindakan kita sendiri\n\nHal-hal dibawah kendali kita itu bersifat merdeka, tidak terikat, tidak terhambat. Sebaliknya yang tidak dalam kendali kita bersifat lemah, terikat dan milik orang lain.\n\nYa lo siap siap kecewa aja kalo lo terobsesi dengan apa yang tidak ada dibawah kendali lo.\nlogak perlu ambil pusing dan khawatir dari perbuatan atau opini orang lain, apa lagi sampai lo menyesali dilahirkan oleh orang tua lo.\n\nStoa mengajarkan, kebahagiaan sejati cuma bisa datang dari apa yang bisa lo kendalikan. Lo gak bisa tuh menggantukan kebahagiaan lo dari orang lain atau yang tidak bisa lo kendalikan.\n\nKalau gitu apa stoisme mengajarkan untuk pasrah pada keadaan?\n\nSama sekali tidak, Di semua situasi bahkan pada saat kita tidak ada dalam kendali pun, selalu ada bagian dalam dari diri kita yang tetap merdeka, yaitu pikiran dan persepsi.\n\nLo bisa aja dalam kondisi terburuk seperti kisah james stockdale yang menjadi tawanan selama lebih dari tujuh tahun, dimana teman temanya sudah menyerah dan akhirnya mati. james memilih cara lain untuk tetap bertahan hidup hingga akhirnya dia bisa diselamatkan.\n\nManusia tidak memiliki kuasa untuk memiliki apapun, tapi dia memiliki kuasa untuk tidak mengingini apa yang dia belum miliki dan dengan gembira memaksimalkan apa yang dia terima.\n\n## Bab 5\n### Mengendalikan Interpretasi dan Persepsi\n","n":0.027}}},{"i":91,"$":{"0":{"v":"Dare to Lead","n":0.577},"1":{"v":"\n#self-improvement\n#brené-brown\n\nBrave work, Tough conversations, Whole heart.\n\nJadi buku ini dibuat dari riset-riset yang dilakukan oleh penulis, \nyang ditujukan kepada pembaca agar menjadi bacaan yang dapat dilakukan untuk menjadi pemimpin yang berani.\n\nDari banyaknya interview dengan para pemimpin, penulis selalu bertanya kepada mereka, \n\nApa yang dilakukan pemimpin untuk berhasil dalam lingkungannya yang kompleks dan berubah dengan cepat?\n\nJawabannya beragam, tapi yang paling sering muncul adalah jawaban\n\n`Kita membutuhkan pemimpin yang lebih berani dan budaya (culture) yang lebih berani.`\n\nYang dimaksud pemimpin menurut penulis itu adalah,\n\nPemimpin adalah siapapun yang mengambil tanggung jawab untuk menemukan potensi didalam seseorang atau proses,\ndan berani untuk membangun potensi itu.\n\nLalu penulis bertanya lagi, bisakah kalian merinci keterampilan khusus yang anda yakini dapat mendukung kepemimpinan yang berani? hmm, ini tuh sesuatu yang kita miliki dan tidak kita miliki.\n\nLebih dari 80% pemimpin percaya kalau keberanian itu adalah perilaku bukan kemampuan.\n\nMereka lebih bersemangat berbicara tentang beberapa masalah, seperti behavioral problem dan cultural problem yang merusak kepercayaan dan keberanian.\n\nMisalnya, menghindari percakapan yang sulit, seperti memberikan `feedback` yang jujur dan produktif.\n\nPenyebabnya bisa jadi karena, kurangnya keberanian, kurangnya keterampilan, sisanya masalah norma \"merasa gak enakan, merasa gak sopan\" yang sering digunakan sebagai alasan untuk menghindari percapakan yang sulit seperti itu.\n\nAkbatnya, ada ketidakjelasan yang akan mengurangi kepercayaan dan keterlibatan serta mendorong perilaku [pasif-agresif](https://www.verywellmind.com/what-is-passive-aggressive-behavior-2795481) alias ngomongin dibelakang.\n\nMeskipun ini sepertinya masalah organisasi ditempat kerja, tapi sebenarnya masalah ini berasal dari manusia.\n\nAda beberapa contoh lagi dibukunya, kalo penasaran silahkan dibaca.\n\nOya, dibuku ini ada hasil pembelajaran dari penulis. Judulnya\n\n### The Heart of Daring Leadership\n\nAda tiga point,\n\n1. Kita tidak bisa mendapatkan keberanian tanpa bregemuruh dengan kerentanan, rangkulah kelemahan kita.\n\n  Yang dimaksud dengan gemuruh adalah diskusi, percakapan atau pertemuan yang didasari oleh kerentanan. Mengidentifikasi masalahnya, hadapi dan mencoba lagi tanpa rasa takut dan belajar dari kesalahan.\n\n2. Kesadaran diri dan cinta diri itu penting. Siapa kita adalah bagaimana kita memimpin.\n\n3. Keberanian itu menular.\n\n  Untuk meningkatkan kepemimpinan dan membangun keberanian didalam tim dan ognasisasi. Kita harus menumbuhkan budaya kerja yang berani, tough conversation dan sepenuh hati dan armor (jabatan) tidak diperdulikan.\n\nPemimpin yang berani harus peduli dan terhubung dengan orang-orang yang dipimpinnya.\n\n## Rumbling with vulnerability\n\nApa itu vulnerability / kerentanan? Menurut penulis kerentanan bukanlah hal  menang atau kalah, tetapi lebih ke perasaan kita. \n\nMisalnya, memulai sesuatu yang baru, misal mulai bisnis baru atau ketika kita baru saja diberhentikan dari perkerjaan, atau sesimple meminta maaf kepada teman, mendapatkan feedback. Itu semua membuat kita merasa cemas, takut dan bimbang.\n\nIntinya kita pasti akan ada momen momen ketika kita merasa rentan waktu kita berada diketidak-pastian, resiko dan paparan emosi.\n\nKerentanan adalah emosi manusia yang wajar dan dirasakan oleh semua orang. \nKerentanan membutuhkan keberanian,dan bukan suatu kelemahan.\n\nTanpa kerentanan tidak akan ada invovasi dan kreativitas. Tidak ada inovasi tidak akan ada jika tidak belajar dari kesalahan.\n\nComedian [Amy Poehler](https://www.goodreads.com/quotes/960017-it-s-very-hard-to-have-ideas-it-s-very-hard-to), bilang, `Sangat sulit untuk memiliki ide. Sangat sulit untuk menempatkan diri diluar sana, Sangat sulit untuk menjadi rentan, Tetapi pemimpi, pemikir dan creator orang orang ajaib yang berani melakukannya.`\n\nJadi, kemampuan kita untuk berubah, melakukan percakapan yang sulit, memberikan feedback yang produktif, dan jujur yang merupakan keterampilan kepemimpinan yang berani, semuanya lahir dari kerentanan.\n\n## Hidup didalam value kita\n\nPerjelas apa yang jadi value kita dan bertindak sesuai dengan value yang kita percayai.\n\nYang dimaksud value apa? gimana kita mau hidup didalam value kalo kita gak tau?\n\nContoh value bisa dilihat [disini](https://daretolead.brenebrown.com/wp-content/uploads/2019/02/Values.pdf). \n\nTanya pada diri kita:\n\n- Value apa yang mendefinisikan saya?\n- Apakah ini yang tebaik untuk saya?\n- Apakah value ini menjadi filter yang bisa saya gunakan untuk membuat keputusan yang sulit?\n\nPilih satu atau dua value yang akan kita yakini. \n\nLalu bawa value tersebut dari sekedar bullshit menjadi behavior. \n\nCoba lihat workbook [ini](https://daretolead.brenebrown.com/wp-content/uploads/2018/10/DTL-Read-Along-Workbook-v1.pdf)\n\nIsi pertanyaan yang ada dihalaman 31. \n\nSelanjutnya, Berempati dan welas asih adalah hal terpenting.\n\nLalu belajar cara memberi feedback dan menerima feedback.\n\nDibuku ini ada petunjuk untuk memberikan feedback.\n\n1. Saya tau, saya siap memberikan feedback ketika saya siap untuk duduk disebelah anda daripada disebrang anda.\n\n2. Saya tau, saya siap memberikan feedback ketika saya bersedia meletakan masalah didepan kita daripada diantara kita (atau diarahkan kepada anda)   \n\n3. Saya tau, saya siap memberikan feedback ketika saya siap untuk mendengarkan, mengajukan pertanyaan dan menerima kalau saya mungkin tidak sepenuhnya memahami masalah ini.\n\n4. Saya tau, saya siap memberikan feedback ketika saya siap untuk mengakui apa yang anda lakukan dengan baik, bukan hanya mencari cari kesalan anda.\n\n5. Saya tau, saya siap memberikan feedback ketika saya mengenali kekuatan anda dan bagaimana anda dapat menggunkannya untuk mengatasi tantangan anda.\n\n6. Saya tau, saya siap memberikan feedback ketika saya dapat meminta pertanggung jawaban anda tanpa mempermalukan atau menyalahkan\n\n7. Saya tau, saya siap memberikan feedback ketika saya terbuka untuk memili bagian saya.\n\n8. Saya tau, saya siap memberikan feedback ketika saya benar benar dapat berterima kasih kepada seseorang atas upaya mereka daripada hanya mengkritik mereka karena kegagalan mereka.\n\n9. Saya tau, saya siap memberikan feedback ketika saya dapat berbicara tentang bagaimana menyelesaikan tantangan ini yang akan mengarah kepada pertumbuhan dan kesempatan.\n\n10. Saya tau, saya siap memberikan feedback ketika saya dapat mencontoh kerentanan dan ketebukaan yang diharapkan dari ana.\n\nItu dalah sepulu petunjuk yang akan menjadi panduan ketika kita akan memberikan feeback.\n\nLalu bagaimana sikap yang baik ketika menerima feedback?\n\n1. Saya berani mendengarkan dan menerima\n2. Ambil sesuatu yang berharga, ambil yang baiknya buang sisanya.\n3. Percaya setiap feedback yang diterima adalah jalan menjadi lebih baik.\n\n## Kepercayaan adalah hal yang penting\n\nSeberapa jauh kita bisa dipercaya dan berapa banyak orang yang betul betul kita percayai.\n\nPenulis telah membuat tujuh peroilaku yang mendorong kepecayaan. dan disingkan BRAVING.\n\nB adalah Boundaries (batas) artinya kita harung menghormati batasan orang lain.\n\nR adalah reliability (dapat diandalkan) apa yang kita katakan itu yang kita lakukan. Kita harus menyadari kemampuan dan keterbatasan kita, sehingga kita tidak berlebihan dan akibatnya tidak bisa memenu komitment yang telah kita katakan.\n\nA adalah accountability, kita bertanggungjwab atas kesalahan kita, benari meminta maaf dan mencoba dan mencari jalan terbaik untuk menebus kesalahan.\n\nV adalah vault (lemari besi), anggap lah kita seperti lemari besi informasi.Kita harus jaga informasi penting yang bukan milik kita.\n\nI adalah integrity (integritas). lakukan apa yang benar daripada cari jalan pintas cari yang mudah, menyenangkan, tapi mengorbankan kebenaran.\n\nN adalah non-juggement (tidak menghakimi), dengan tidak menghakimi orang akan memberitahu apa yang sebenarnya mereka rasakan dan meminta bantuan tanpa mengharapkan kita menghakimi mereka.\n\nG adalah generosity (kemurahan hati) orang akan lebih mempercayai kita kalau mereka tau kita selelu melihat yang terbaik dari orang lain bukan yang terburuk.\n\nTerapkan perilaku ini untuk menjadi pemimpin yang sukses dan bisa dipercaya.\n\n\n## Belajar dari kegagalan membantu menjadi lebih berani\n\nPelajaran bagi pemimpin? kalau kita ingin lebih berani, maka yang terbaik adalah dengan mempersiapkan diri untuk jalan yang tidak mulus.\n\nKita bisa ambil pelajaran dari skydivers, calon skydivers akan dizinkan untuk terbang diatas langit ketika mereka susah menghabiskan banyak sesi pelatihan untuk belajar bagaimana cara mendarat dengan aman, mulai dari ketinggian yang rendah misal lompat dari tangga.\n\nPara pemimpin dan pelatih kepemimpinan menyadari perlunya pelatihan ketahanan ini. Tapi bisanya mereka lakukan setelah mengalami kegagalan atau pas krisis terjadi. \n\nCoba bayangkan jika skydivers yang seperti itu, terjun bebas tanpa pernah mencoba berlatih dan belajar gagal mendarat dari ketinggian yang rendah.\n\nAda cara lebih baik, yaitu mencoba belajar sejak dini, dengan belajar sedari awal, akan menimbulkan perilaku lebih berani. Kenapa? karena setelah pelatihan kita akan yakin dengan kemampuan untuk bangkit kembali jika perilaku berani kita tidak membuahkan hasil yang baik.\n\nNamun, beberapa organissari khawatir kalau mengajari cara gagal sejak awal akan mendorong performa yang rendah.\n\nPadahal, yang terjadi malah sebaliknya.\n\nMisalnya, di perusahaan penulis sendiri, dia menjadikan prioritas untuk mengajarkan keterampilan untuk gagal dan ketahan sebagai bagian dari proses orientasi untuk para karyawan baru.\n\nIni adalah cara perusahaan memberitahu karyawan baru, kalau keberanian mereka sangat diharapkan tapi kegagalan juga tetap diekspektasikan sesekali.\n\npernahkan dengar slogan \"Fall forward\" and \"fail fast\" kalau tanpa program keterampilan ketahanan akan membuat banyak kerusahakan dari pada kebaikan.\n\nKenapa?\n\nKarena para pemimpin yang gagal tanpa keterampilan ketahanan akan dengan cepat merasakan sedang berhadapan dengan rasa malu dua kali lipat lebih dari orang yang belajar keterampilan ketahanan.\n\n## Perfeksionisme menggagalkan kita dari peningkatan diri dan keberanian\n\nSalah satu jenis perlindungan diri yang paling luas adalah perfeksionisme. Untuk menjadi pemimpin yang berani, kita harus membersihkan diri dari perfeksionisme.\n\nKita harus mendobrak dari mitos mitos perfeksionisme ini.\n\nmitos yang paling merusak adalah kalau perfeksionisme adalah tentang perbaikan diri dan berjuang untuk keunggulan.\n\nPadahal kenyataannya, perfeksionisme sebenarnya tentang upaya untuk memenangkan penerimaan, ingin mendapat pujian dari lingkungan, butuh pengakuan dan selalu bertanya \"Apa pendapat orang lain tentang gw?\"\n\nSebaliknya, orang orang dengan dorongan yang sehat untuk sukses, jauh lebih fokus pada diri sendiri dan terinspirasi dengan bertanya pada diri sendiri bagaimana cara mereka bisa bertumbuh.\n\nOrang orang perfeksionis sering berasumsi kalau cara berpikir ini akan membawa mereka sukses, \n\nSebenernya sih gak salah juga dengan perfksionis, tapi ada yang mengganggu dari penelitian yang dilakukan penulis. kalau perfeksionisme dikaitkan dengan kecanduan, depresi dan kecemasan. lebih jauh lagi perfeksionis lebih cenderung kehilang peluang dan mengalami kelumpuhan mental yang membuat mereka gak sepenuhnya terlibat dalam kehidupan.\n\nKenapa?\n\nKarena ketakutan ketika dikritik atau gak memenuhi harapah orang lain.\n\nUntuk menjadi pemimpin yang berani, lepaskan tameng perfeksionis ini dan masuklah ke kehidupan yang nyata. Kita mungkin membuat kesalahan dalam proses, tetapi kita akan mendaptkan sesuati yang berharga sebagai gantinya. Keberanian untuk berhasil dan memimpin.\n\n## Yang gw dipelajari\n\nKetika kita jujur dan menerima kerentanan, artinya kita telah membuka diri terhadap keberanian dan kreativitas.\n\nKetika kita melepaskan sikap perfeksionis dan ketakutan akan kegagalan, artinya kita menemukan keberanian untuk memperbaiki diri kita.\n\nKita perlu semua emosi, untuk mengikuti kita jika ingin menjadi pemimpin yang berani.\n\n```\ncatatan:\n\nbanyak banget yang bisa diambil dari buku ini dan sepertinya ringkasannya akan diperbaharui.\n```","n":0.026}}},{"i":92,"$":{"0":{"v":"Continuous Integration (CI) and Continuous Delivery (CD) a Practical Guide to Designing and Developing Pipelines","n":0.258}}},{"i":93,"$":{"0":{"v":"7. Implementing Pipelines","n":0.577},"1":{"v":"\nSuatu hari, tim kita akhirnya siap merilis sebuah aplikasi baru ke environment production. Saat momen penting ini tiba, berbagai persiapan pun dimulai. Dimulai dari memasang sertifikat SSL, menata seluruh kredensial dan secret agar aman, hingga memastikan monitoring aplikasi terkonfigurasi dengan benar. Tak semuanya bisa diotomatisasi; sebagian tugas masih memerlukan sentuhan manual. Di sisi lain, pengelolaan aplikasi pun perlu direncanakan dengan rapi. Tim harus tahu persis apa yang harus dilakukan jika aplikasi tiba-tiba gagal atau berperilaku di luar dugaan, dan prosedur untuk menangani perubahan, insiden, maupun masalah operasional harus tersedia agar ketersediaan service tetap aman.\n\nHal serupa juga berlaku untuk pipeline. Environment tempat pipeline dijalankan harus dipersiapkan dan terus ditingkatkan. Platform pipeline mungkin terhubung ke service eksternal yang perlu diamankan, dan infrastrukturnya—termasuk integrasi dan pipeline itu sendiri—wajib diawasi dengan cermat. Bila pipeline gagal atau tidak berfungsi seperti yang diharapkan, tim perlu segera tanggap untuk memperbaikinya. Barulah setelah semua persiapan tersebut matang, pipeline siap dijalankan. Tidak jarang pekerjaan tambahan diperlukan, jauh lebih banyak daripada yang sering terlihat di permukaan.\n\n\n## Implementasi Pipeline\n\nKetika membahas implementasi pipeline, konsepnya sedikit unik. Jika kita membandingkan implementasi pipeline dengan implementasi aplikasi, keduanya sama-sama memerlukan konfigurasi dan penerapan di environment target. Namun, pertanyaannya adalah: apa sebenarnya “environment target” untuk sebuah pipeline? Lalu, bisakah kita benar-benar berbicara tentang “implementasi pipeline” layaknya implementasi aplikasi biasa? Dalam diskusi mengenai “pipeline dari pipeline,” kesimpulannya menyiratkan bahwa menerapkan pipeline ke production tak lebih dari sekadar mendorong kode pipeline ke repositori jarak jauh dan menggabungkannya ke jalur utama. Gambar 7-1 memperlihatkan bagaimana proses ini berlangsung.\n\n![Gambar 7-1 Implementasi Pipeline](assets/2023-07-07-14-15-08.png)\n\nSaat melihat Gambar 7-1, kita menemukan bahwa kode pipeline yang baru maupun yang telah diperbarui dapat berada di branch terpisah dalam repositori yang sama dengan aplikasi, atau mungkin di repositori terpisah yang merupakan hasil kloning. Semua itu bergantung pada bagaimana pipeline dikembangkan. Setelah ditulis, kode pipeline tersebut akan ditesting di environment khusus untuk pengtestingan pipeline. Di sana, pipeline otomatis membangun dan menjalankan aplikasi di environment testing pertama, yang disebut “testing Jalankan-1.” Begitu proses penggabungan kode pipeline ke jalur utama selesai, pipeline resmi dianggap “diimplementasikan” dan siap digunakan di seluruh environment tujuan (testing Jalankan-1, testing Jalankan-2, maupun Produksi Jalankan).\n\n## Dampak Organisasi\n\nSebuah pipeline yang dirancang dengan cermat mengikuti beragam persyaratan dan pedoman organisasi. Sebelum siap digunakan oleh tim DevOps, pipeline itu harus melewati serangkaian testing ketat: mulai dari memastikan perilaku fungsional yang sesuai spesifikasi, mengtesting performa agar memenuhi standar tertentu, menerapkan langkah-langkah keamanan, hingga memeriksa compliance terhadap kebijakan internal. Begitu semua aspek terverifikasi, barulah seluruh anggota tim yakin pipeline tersebut dapat diandalkan. Apabila diperlukan, mereka pun menyiapkan dokumentasi tentang cara penggunaan, penyesuaian teknis, dan pemeliharaan. Semua itu tidak wajib, namun sering kali memudahkan seluruh tim untuk memulai. Pada akhirnya, tim akan bermusyawarah, menilai kesiapan pipeline, dan memberi lampu hijau saat semuanya dianggap layak.\n\nSetiap kali pipeline diperbarui, tim perlu mengenali batasannya dan mendokumentasikan masalah yang telah diketahui. Jika terdapat persyaratan yang belum terwujud, catat tindakan mitigasinya, seperti pemeriksaan manual, agar potensi risiko tetap terkendali. Tim dan pemangku kepentingan dari sisi bisnis kemudian bersama-sama mengevaluasi berbagai celah yang mungkin muncul, lalu merancang perbaikan-perbaikan berikutnya. Semua masukan tersebut disatukan dalam backlog dan diprioritaskan sesuai kebutuhan. Bisnis umumnya akan berfokus pada strategi rilis dan kebijakan organisasi: apakah setiap fitur baru harus langsung diterapkan ke produksi dalam waktu 15 menit, atau cukup menunggu hingga terkumpul dan dirilis seminggu sekali? Keputusan seperti ini akan memengaruhi alur kerja tim, bahkan mungkin menuntut perubahan desain pipeline. Di sinilah struktur pengawasan berperan, memastikan evaluasi yang berkelanjutan. Tim pun perlu meluangkan waktu untuk meninjau dan terus menyempurnakan pipeline, sama seperti mereka melakukan perbaikan berkelanjutan pada pengembangan aplikasi.\n\nApabila pipeline belum ditetapkan sistem notifikasinya, penting untuk menentukan siapa saja yang berhak mendapatkan informasi serta jenis pembaruan apa yang perlu diberitahukan. Saat tahap pengembangan, mungkin seluruh anggota tim mendapat email serupa setiap kali pipeline berjalan atau ketika dibutuhkan persetujuan penerapan. Namun, menjelang penerapan ke produksi, konfigurasi penerima notifikasi perlu disesuaikan agar setiap orang hanya menerima informasi yang benar-benar relevan. Tujuannya adalah mencegah informasi berlebihan dan sekaligus memaksimalkan efektivitas pipeline. Selain itu, dashboard dapat dimanfaatkan untuk menampilkan data penting secara visual, sehingga tim bisa memantau kondisi pipeline secara real-time dan segera mengambil tindakan bila terjadi masalah.\n\n### Disiplin Tim\n\nAda kalanya tim sangat antusias mengadopsi otomatisasi dan pipeline. Mereka telah merencanakan segalanya dengan matang, mempelajari berbagai tools, dan berharap proses pengembangan menjadi lebih lancar. Namun, seiring berjalannya waktu, tim mulai menyadari bahwa ada beberapa hal yang kerap terabaikan, dan disiplin kerja diperlukan untuk mengatasinya. Berikut adalah beberapa masalah yang terus-menerus muncul:\n\n- Breaking Builds: Salah satu prinsip integrasi berkelanjutan menyatakan bahwa build yang rusak harus segera diperbaiki. Idealnya, setiap developer langsung menghentikan pekerjaan lain dan fokus memperbaiki pipeline. Namun pada praktiknya, developer sering kali menunda. Jika tidak menimbulkan keterlambatan rilis, mereka menganggapnya biasa saja. Padahal, membiarkan pipeline rusak berlarut-larut—satu hingga dua hari—bukanlah kebiasaan yang baik. Udah gitu, kerusakan pipeline tidak selalu disebabkan oleh kode yang salah. Lingkungan eksternal pun bisa berubah: sistem eksternal down, SSL kedaluwarsa, bahkan platform ALM/integrasi mengalami gangguan. Jika diabaikan, penanganannya semakin hari semakin sulit.\n\n- Disabled Quality Gates: Idealnya, jika analisis kode mendeteksi vulnerabelity serius, pipeline harus “gagal” agar tim segera menyelesaikan masalah tersebut. Akan tetapi, ada situasi di mana quality gates dimatikan—entah secara tidak sengaja atau disengaja—sehingga vulnerabelity dibiarkan. Sering kali hal ini terjadi karena tim tidak ingin mengatasi temuan analisis kode yang menumpuk.\n\n-  Menindak lajuti code yang busuk dan cacat: Sebagian tim rajin membersihkan vulnerabelity penting yang terdeteksi. Mereka memprioritaskan quality gates, sehingga pipeline hanya “hijau” bila kualitas kodenya benar-benar aman. Namun, ada juga yang justru mengabaikan temuan analisis kode hingga menonaktifkan quality gates. Akibatnya, utang teknis menumpuk dan makin sulit dilunasi di kemudian hari.\n\n- Unit Testing Coverage: Prinsip yang sama berlaku untuk unit testing coverage. Beberapa tim menjadikannya target penting agar senantiasa berada di ambang tertentu. Jika di bawah batas, pipeline akan “gagal.” Namun, ada pula tim yang tidak memprioritaskan hal ini. Dampaknya, coverage testing rendah dan kualitas kode mudah terganggu oleh bug yang tak terdeteksi.\n\n- Automated testing yang ditunda tunda: Tidak jarang backlog untuk automated test terus menumpuk. Ini terjadi jika jumlah orang yang mengerjakan otomatisasi terbatas, misalnya hanya tim QA dengan anggota sedikit. Jalan keluar yang sering terbukti efektif adalah melibatkan seluruh tim—termasuk developer—dalam menulis dan memelihara tes otomatis, sehingga beban kerja pengujian tersebar lebih merata.\n\nDi samping itu, tim yang belum sepenuhnya beradaptasi kadang mencari “jalan pintas”: menghindari pipeline resmi dan menerapkan aplikasi ke produksi dengan cara lain, atau melakukan integrasi berkelanjutan dari cabang pengembangan saja, sementara rilis dilakukan dari branch main secara manual di local. Bahkan, ada kalanya pull request disetujui tanpa code review mendalam ketika ada push dari tim product. Semua ini merupakan bagian dari proses pembelajaran. Namun, demi kebaikan jangka panjang, masalah-masalah tersebut harus diatasi agar pipeline benar-benar bermanfaat bagi kualitas, kecepatan, dan stabilitas pengembangan.\n\n### Platform Integrasi\n\nAda Tim DevOps yang akan membangun dan menjalankan pipeline di sebuah organisasi. Mereka menyadari bahwa pipeline tidak hanya sekadar menulis skrip dan menekan tombol “jalankan,” tetapi juga mencakup infrastruktur di belakangnya. Tiba-tiba tim dihadapkan pada pertanyaan besar: **di mana dan bagaimana pipeline ini akan berjalan?** Mereka pun mulai berdiskusi dan menimbang berbagai model operasional—mulai dari SaaS, IaaS, hingga mengelola infrastruktur sendiri (self-hosting).\n\n#### Model SaaS\nPertama, tim mempertimbangkan **model SaaS**, di mana mereka menggunakan platform integrasi yang sudah tersedia sebagai layanan. Bayangkan kemudahan yang dirasakan oleh tim DevOps: mereka tinggal fokus pada pembuatan pipeline, sementara penyedia SaaS bertanggung jawab atas pengelolaan infrastruktur dan semua pembaruan software. Solusi seperti Azure DevOps atau CircleCI Cloud masuk dalam kategori ini. Berbagai kekhawatiran teknis seolah-olah hilang, karena penyedia layanan menangani keamanan, kapasitas server, dan pemeliharaan rutin. Tim DevOps pun dapat mencurahkan waktu untuk meningkatkan kualitas pipeline tanpa terjebak masalah infrastruktur.\n\n#### Model IaaS\nNamun, tim menemukan alasan untuk tidak langsung menutup opsi lain. Mereka juga menimbang **model IaaS**, di mana infrastruktur disediakan oleh platform cloud—misalnya AWS atau Azure—tetapi pengelolaan platform integrasi seperti Jenkins, SonarQube, dan alat-alat penerapan lainnya tetap berada di tangan tim IT4IT atau tim DevOps sendiri. Di sini, tanggung jawab mereka lebih luas: mulai dari memastikan kluster Kubernetes dalam kondisi prima, meng-upgrade kontainer secara rutin, hingga memeriksa apakah kapasitas server masih mencukupi. \n\nCerita pun berlanjut ketika pipeline baru semakin banyak dan beban kerja melonjak. Ternyata, infrastruktur yang disiapkan di awal tak lagi mampu menampung tingginya lalu lintas build dan pengujian. Mau tak mau, tim harus meninjau ulang kebutuhan kapasitas. Mungkin memindahkan sebagian tahap build dan testing ke node atau agen lain adalah solusi yang tepat, sehingga beban kerja lebih merata. Dalam model IaaS ini, fleksibilitas cukup tinggi, tetapi tim juga harus siap mengurus hal-hal teknis lebih dalam.\n\n### Model Self-Hosting\nSelanjutnya, organisasi mungkin mengambil langkah paling menantang: **self-hosting**. Mereka memutuskan untuk memegang kendali penuh atas seluruh tumpukan integrasi, termasuk perangkat keras maupun perangkat lunaknya. Tentu ada sederet tanggung jawab ekstra:\n\n1. **Menyediakan infrastruktur** tempat seluruh platform integrasi berjalan.  \n2. **Mengatur logging, pemantauan, dan notifikasi** di tingkat infrastruktur. Tim harus menentukan metrik apa yang akan diawasi, misalnya tingkat pemakaian CPU di atas 90 persen atau ruang disk yang menipis di atas 80 persen.  \n3. **Memastikan infrastruktur memenuhi standar nonfungsional**, seperti yang diatur dalam ISO 25010. Ini mencakup keamanan, ketersediaan, serta berbagai aspek kualitas lain. Tim juga harus menilai keamanan infrastruktur menggunakan kerangka acuan seperti NIST, terutama untuk infrastruktur yang dianggap kritis.\n\nPilihan ini membuat tim DevOps lebih leluasa menyesuaikan setiap aspek infrastruktur dengan kebutuhan unik di organisasi. Namun, konsekuensinya, beban kerja mereka dalam hal perawatan dan pemeliharaan ikut melonjak.\n\n### Keamanan Infrastruktur\nDalam cerita ini, keamanan menjadi tema yang selalu mendominasi pikiran tim, apa pun model operasional yang dipilih. Mereka tak mau kecolongan. Berbagai hal diperhatikan:\n\n- **Penguatan server dan manajemen kerentanan:** Server harus dijaga, rutin diperbarui, dan divalidasi keamanannya.  \n- **Koneksi yang aman:** Komunikasi antara platform ALM, sistem SCM, alat analisis kode, hingga environment produksi perlu terlindungi, misalnya dengan HTTPS atau mTLS.  \n- **Pengaturan hak akses:** Tim memastikan bahwa yang memicu penerapan tidak bisa sekaligus menyetujui penerapan itu tanpa mekanisme kontrol.  \n- **Kebijakan cabang:** Pipeline tidak boleh digabungkan ke jalur utama jika sedang gagal. Aturan ini harus dikonfigurasi dengan tepat agar tak ada kode bermasalah yang lolos ke production.  \n- **Penggunaan vault:** Token, kunci, dan kredensial disimpan secara aman di vault. Ini membantu mencegah kebocoran data kritis.  \n- **Proteksi artefak rilis:** Kode aplikasi, pipeline, pengujian, maupun item kerja yang membentuk artefak rilis produksi harus diamankan agar tidak bisa dihapus sembarangan.  \n- **Pemindai kepatuhan pipeline:** Mengawasi apakah pipeline telah sesuai dengan kebijakan organisasi, misalnya terkait audit, keamanan, atau standar internal lainnya.\n\nPada akhirnya, kisah ini memperlihatkan bahwa membangun dan menjalankan pipeline tidak sekadar soal menulis skrip otomatisasi. Tim DevOps perlu mempertimbangkan di mana pipeline tersebut akan hidup, bagaimana mengelola infrastruktur di belakangnya, serta bagaimana menjaga keamanan dan kepatuhan. **Keputusan dan disiplin** dalam hal infrastruktur, entah SaaS, IaaS, ataupun self-hosting, menjadi fondasi agar pipeline berfungsi andal, aman, dan efisien—persis seperti yang diharapkan oleh seluruh pemangku kepentingan.\n\n### Persiapan environment Target\n\nJika tim telah mengadopsi pengembangan pipeline yang diperluas (atau canggih), sebagian besar pengembangan dan pengtestingan pipeline dilakukan menggunakan environment pengembangan/testingan pipeline. Jika pipeline siap untuk diimplementasikan dan digunakan, pipeline tersebut dipromosikan sehingga dapat membangun dan menerapkan aplikasi ke berbagai environment target. Ini mungkin meliputi environment testing tambahan dan environment produksi. Konfigurasikan environment target ini agar dapat diakses oleh pipeline dan lakukan penerapan melalui koneksi yang aman.\n\nAplikasi yang diimplementasikan kemungkinan juga memerlukan kredensial (basis data), sertifikat, atau data statis. Hal ini harus diminta atau dihasilkan dan diterapkan ke environment target sehingga aplikasi dapat menggunakannya. Lebih baik jika ini adalah proses otomatis; gunakan pipeline operasional untuk mengatur hal ini. Bab berikutnyaakan membahas pipeline operasional dengan lebih detail.\n\nDalam kasus environment testing aplikasi, perlu diatur data testing. Entah menghasilkan data sintetis atau menggunakan salinan dari produksi, tetapi pastikan data tersebut dianonimkan.\n\n#### Playbook\n\nApa dampak bisnis jika terjadi insiden atau masalah dengan pipeline? Kegagalan pipeline dapat menyebabkan kerusakan. Misalnya, perbaikan mendesak pada aplikasi harus dibuat dan perlu diterapkan. Namun, pipeline tidak berfungsi karena kegagalan infrastruktur dari platform integrasi. Ini dapat merusak kelangsungan proses bisnis jika pipeline tidak tersedia dalam waktu yang lama. Proses ITIL juga berlaku untuk pipeline. Playbook dapat berperan penting dalam proses manajemen insiden dan masalah.\n\nPlaybook berisi metode investigasi yang didokumentasikan untuk mendeteksi dan menyelesaikan masalah. Playbook ini berguna untuk menyelidiki insiden atau kegagalan. Playbook juga dapat digunakan untuk pipeline. Penyusunan playbook pipeline dapat dimulai selama pengtestingan pipeline. Kegagalan pipeline umum dan solusinya ditambahkan ke playbook. Tentu saja, playbook tidak pernah lengkap, dan setelah implementasi dan penggunaan pipeline, akan muncul lebih banyak kasus. Kasus-kasus ini juga ditambahkan ke playbook.\n\n### Implementasi Aplikasi\n\nSulit untuk membicarakan implementasi pipeline tanpa menyebutkan implementasi aplikasi. Implementasi aplikasi, pada dasarnya, adalah tujuan penggunaan pipeline. Menambahkan fitur-fitur tertentu ke dalam pipeline dapat berkontribusi pada pengalaman implementasi aplikasi yang solid. Pertimbangkan untuk menggunakan atau mengimplementasikan fitur-fitur berikut.\n\n#### Runbook\n\n\"Sebuah runbook adalah sekumpulan proses dan prosedur yang Anda eksekusi secara berulang untuk mendukung berbagai tugas perusahaan.\"\n\nReferensi [33]\n\nMengapa Anda membutuhkan runbook jika Anda menggunakan pipeline otomatis? Itu pertanyaan yang bagus. Sebuah pipeline sudah mengatur pelaksanaan aplikasi, bukan? Tetapi tim masih menggunakan runbook meskipun mereka juga menggunakan pipeline. Ada beberapa alasan mengapa penggunaan runbook masih valid.\nMasih ada tugas atau aktivitas satu kali yang tidak termasuk dalam CI/CD. Awal CI adalah saat melakukan commit ke repositori. Akhir CD adalah saat penerapan artefak ke environment produksi. Banyak tugas termasuk dalam proses sebelum dan sesudah CI/CD. Pikirkan tentang meminta langganan Azure, mengonfigurasi peran IAM, dan mengalokasikan anggota tim. Selain itu, pemeliharaan atau migrasi rutin melibatkan aktivitas yang juga tidak termasuk dalam pipeline CI/CD. Terkadang aktivitas-aktivitas ini kompleks dan memerlukan runbook yang detail.\n\nAlasan lain menggunakan runbook adalah implementasi pertama dari sistem lengkap. Anda tidak memiliki CI/CD yang disiapkan sejak hari pertama. Implementasi sistem baru dalam produksi mungkin memerlukan eksekusi beberapa pipeline dalam urutan tertentu; bahkan dalam arsitektur mikro layanan, beberapa pipeline harus berjalan dalam urutan tertentu. Pikirkan tentang menyiapkan komponen infrastruktur dasar yang digunakan oleh semua mikro layanan.\n\nSegala sesuatu dapat diotomatiskan, termasuk runbook. Jika sebuah spreadsheet sederhana tidak cukup, gunakan salah satu dari beberapa alat runbook otomatis. Dan karena Anda sudah mengembangkan pipeline, mengatur pipeline orkestrasi untuk mengimplementasikan runbook juga menjadi pilihan. Namun, pertanyaannya adalah apakah manfaatnya sebanding dengan usaha dan biaya yang dikeluarkan. Itu adalah pertanyaan yang hanya dapat dijawab oleh tim.\n\n### Release Note\n\nSebuah release note adalah catatan perubahan, yang menggambarkan pembaruan software. Ini juga dapat mencakup bukti bahwa semua fitur baru telah ditesting dan diterima. Jadi, release note terkait dengan artefak dan berisi informasi tentang fitur-fitur yang disampaikan dan (opsional) laporan pengtestingan. Karena buku ini membahas desain CI/CD, pembuatan release note seharusnya tidak dilakukan secara manual tetapi dibuat secara otomatis. Namun, ada satu hal yang perlu dipertimbangkan. Antara dua rilis produksi, kemungkinan ada beberapa kandidat rilis, termasuk fitur-fitur dan perubahan baru. Kandidat rilis terakhir ditandai sebagai \"rilis\" dan diterapkan ke produksi. Potensial, beberapa catatan rilis dibuat di antara mereka, masing-masing terkait dengan kandidat rilis. Hanya artefak terakhir yang diterapkan ke produksi yang berisi semua fitur baru sejak rilis produksi sebelumnya. Kemungkinan besar catatan rilis terakhir sangat ringkas, hanya menggambarkan perbaikan bug. Hal ini sedikit disayangkan. Catatan rilis dari artefak produksi seharusnya idealnya terdiri dari semua perubahan antara rilis produksi sebelumnya dan rilis produksi saat ini. Selain itu, catatan rilis juga harus berisi semua hasil pengtestingan yang dilakukan pada rilis yang diterapkan ke produksi.\n\nUntuk memecahkan masalah ini, sistem harus melacak semua perubahan antara rilis produksi terbaru dan rilis produksi berikutnya dan mengumpulkan semua metadata perantara untuk membentuk catatan rilis yang teragregasi. Setelah setiap penerapan produksi, status metadata direset, dan proses pengumpulan dimulai kembali. Lihat Gambar 7-2.\n\n![Gambar 7-2 Pengumpulan data catatan rilis](assets/2023-07-07-14-46-39.png)\n\nKarena catatan rilis berpotensi berisi semua fitur artefak dan hasil pengtestingan yang terkait, pembuatannya biasanya dilakukan setelah semua pengtestingan selesai. Metadata yang terdiri dari semua fitur dihasilkan pada tahap Publish artefak, di mana semua data perubahan dan fitur artefak dikumpulkan. Tahap Perform test menghasilkan semua hasil pengtestingan. Sepertinya masuk akal bahwa pembuatan catatan rilis dilakukan sebagai bagian dari tahap Notify actors.\n\nPertimbangkan kasus berikut:\n\n> Tim ingin mengotomatisasi pembuatan catatan rilis. Mereka menggunakan sistem pelacak masalah terpisah untuk mendaftar item kerja. Kode disimpan di Git, dan artefak disimpan di repositori artefak.\n\n> Tim diberi informasi tentang setiap penerapan produksi menggunakan email (baik penerapan yang berhasil maupun yang gagal).\n\n> Catatan rilis dipublikasikan di halaman wiki. Tim ingin memiliki catatan rilis teragregasi, yang berisi semua fitur sejak rilis terakhir diterapkan ke produksi, termasuk hasil pengtestingan dari rilis terakhir.\n\nModel BPMN khas dapat terlihat seperti pada Gambar 7-3.\n\n![Gambar 7-3 BPMN, membuat catatan rilis](assets/2023-07-07-14-47-16.png)\n\nKetika tahap Publish artefak dieksekusi, artefak disimpan di repositori artefak, setelah itu tugas khusus mengumpulkan semua data yang terkait dengan artefak. Ini berarti pesan komit kode diambil dan item kerja yang terkait dengan artefak rilis diambil (tidak ditampilkan dalam diagram untuk alasan kejelasan). Informasi ini disimpan di database sehingga dapat digunakan nanti.\n\nPada akhir tahap Perform test, hasil pengtesting akan terbaca. Data hasil pengtestingan dikumpulkan dan juga disimpan dalam database yang sama.\n\nPada suatu waktu dalam proses CI/CD, artefak tersebut (berhasil) diimplementasikan ke environment produksi. Hasil dari penerapan tersebut diteruskan ke tahap Notify actors, dan tugas Publish release note mengambil metadata dari database, mengumpulkan data tersebut, memformatnya menjadi catatan rilis, dan mempublikasikannya ke halaman wiki. Setelah ini selesai, metadata dalam database direset ke situasi awal yang baru.\n\n#### Promosi Artefak\n\nHasil dari tahap build, package, dan publish adalah sebuah artefak yang disimpan dalam repositori biner. Artefak ini adalah kandidat rilis, artinya secara potensial dapat diimplementasikan ke produksi. Namun, pertama-tama artefak harus melalui berbagai siklus pengtestingan, sehingga segalanya dapat terjadi sepanjang perjalanan. Selama proses pengtestingan, artefak bergerak mendekati produksi, tetapi hanya artefak yang telah ditesting dengan sukses yang diizinkan untuk diimplementasikan ke produksi. Kandidat rilis yang terhenti di tengah proses pengtestingan harus diberi tanda karena ada potensi risiko bahwa rilis yang salah diimplementasikan ke produksi. Masalahnya adalah semua kandidat rilis, baik yang gagal dalam pengtestingan maupun yang berhasil, disimpan dalam repositori biner yang sama. Harus ada cara untuk membedakan kandidat rilis yang gagal dengan rilis yang berhasil. Untuk memastikan bahwa kandidat rilis yang gagal selama pengtestingan dicegah dari diimplementasikan ke produksi, dapat ditambahkan quality gate; ini adalah pemeriksaan tambahan untuk menentukan bahwa artefak valid. Pemeriksaan ini dapat diimplementasikan dalam tahap Validate exit criteria.\n\nTapi berdasarkan informasi apa quality gate ini bekerja? Ada beberapa opsi untuk mencegah rilis yang salah diimplementasikan.\n\n- Artefak dipromosikan dari tahap ke tahap. Salah satu jenis implementasi adalah artefak berpindah antara repositori biner yang berbeda. Jadi setelah pengtestingan integrasi, pengtestingan penerimaan, dan pengtestingan kinerja, artefak dipindahkan dari satu repositori ke repositori berikutnya. Repositori terakhir berisi rilis yang siap untuk produksi, jadi itu adalah repositori yang digunakan dalam tahap Deploy artefak ke produksi. Kondisi/quality gate tambahan bahkan tidak diperlukan karena repositori yang tepat sudah digunakan. Kelemahan besar dari solusi ini adalah bahwa multiple repositori diperlukan dan artefak dipindahkan beberapa kali.\n\n- Opsi lainnya adalah mempromosikan artefak secara manual. Fitur ini ditawarkan oleh beberapa platform ALM. Masalah dengan opsi ini adalah bahwa itu adalah tindakan manual. Pengguna harus secara aktif mengubah status artefak dari pra-rilis menjadi rilis, misalnya. Tahap kontrol ganda sudah merupakan tindakan manual, jadi apa gunanya menambah lebih banyak tindakan manual? Jujur saja, promosi artefak manual adalah sesuatu yang harus dihindari.\n\n- Alih-alih menarik artefak yang sama ke repositori biner yang berbeda, ada juga opsi untuk menyimpan semua artefak dalam repositori yang sama dan menyediakan metadata. Setelah tahap-tahap dan tugas-tugas tertentu selesai dan pengtestingan berhasil, metadata artefak diperbarui (menggunakan curl atau Maven, misalnya). Berdasarkan metadata-nya, status artefak menjadi jelas.\n\nGambar 7-4 menggambarkan artefak kerangka pengtestingan unit dengan metadata tambahan dalam format file XML. File metadata (unittest-1.0-metadata.xml) berisi informasi tambahan tentang status tugas pengtestingan.\n\n![Gambar 7-4 Menyimpan metadata tambahan](assets/2023-07-07-14-50-03.png)\n\nSebelum artefak diunduh dari repositori biner dan diimplementasikan ke produksi, metadata-nya dibaca dan diinterpretasikan (menggunakan tugas quality gate dalam tahap Validate exit criteria). Karena pengtestingan penerimaan dalam metadata di sebelah kiri Gambar 7-5 menunjukkan bahwa pengtestingan penerimaan gagal, pipeline berakhir di sini, dan implementasi ke produksi tidak dilakukan. Pada contoh kedua, di sebelah kanan, metadata menunjukkan bahwa semua pengtestingan berhasil. Quality gate terlewati, dan implementasi dapat dimulai.\n\n![Gambar 7-5 Menyimpan metadata dengan hasil pengtestingan](assets/2023-07-07-14-50-34.png)\n\nCatatan: Ini menjadi masalah yang lebih kecil jika bagian CI dan CD diimplementasikan sebagai satu pipeline fisik. Pipeline tersebut sudah gagal sebelum tahap Validate exit criteria dicapai. Namun, ini menjadi risiko jika implementasinya terdiri dari pipeline-pipeline terpisah. Salah satu contoh di mana ini menjadi masalah adalah dalam kasus strategi pembangunan multiteam, di mana ada satu pipeline CD terpisah, memproses artefak dari beberapa pipeline CI.\n","n":0.017}}},{"i":94,"$":{"0":{"v":"Building a Second Brain","n":0.5},"1":{"v":"\n## Bab 1: Where It All Started\n\nDi bab pertama banyak membahas soal latar belakang second brain, tidak begitu banyak yang bisa gue ambil. Tapi ada foot note yang menarik, dalam upaya melawan sakitnya dia terbantu dengan komunitas Quantified Self yang mana ini adalah suatu project self tracking dan gak sendirian disana ada sekelompok orang yang berbagi pengalaman dan cerita bagaimana mereka melakukan tracking kesehatan, produktivitas, mood dan perilaku mereka. Intinya belajar tentang diri mereka sendiri. Lebih jelasnya bisa baca disinis [[til.managing-team.quantified-self]].\n\n ## Bab 2: What Is a Second Brain?\n\ngue baru ngeh ada istilah [commonplace book](https://en.wikipedia.org/wiki/Commonplace_book). Sebelumnya yang gue tau kaya journaling, catetan atau coret coretan. Ini bukan istilah baru, dari jaman dulu sudah ada praktek ini, itulah kenapa jadi banyak sekali buku atau essay dari para cedikiawan. \n\n## Bab 3: How a Second Brain Works\n\nDi bab ketiga ini mulai membahas tentang second brain, ada empat kekuatan second brain. Pertama dengan second braind lo bisa membuat ide ide menjadi lebih jelas. Kenapa bisa gitu? karena dengan lo menulis dan mencatat ide ide lo, lo bisa baca ulang lo amati, lo susun ulang , lo edit atau bisa juga lo gabungin ide lama lo dengan ide baru. Yang kedua dengan second brain lo bisa tarik benang merah dari ide ide lo, bisa jadi ada hubungan antara ide satu dengan ide yang lainnya. Ketiga jadi tabungan ide, pasti lo pernah tiba tiba kepikiran sesuatu yang menarik tapi karena gak lo tulis yaudah itu ide ilang gitu aja. Dengan lo tulis ide lo di second brain lo bisa cari lagi tuh ide sebelumnya. Dan yang keempat dengan second brain lo bisa mempertajam perspektif lo sendiri. Pasti lo pernah punya ide, tapi lo gak kepikiran apa selanjutnya. Misalnya ide lo tahun lalu ini menarik, tapi lo gak tau gimana bikinnya, karena lo catet ini di second brain lo bisa balik lagi dan tambahin perspektif baru dari ide lo tadi hingga bisa selesai.","n":0.056}}},{"i":95,"$":{"0":{"v":"14 Habits of Highly Productive Developers","n":0.408},"1":{"v":"\n#self-improvement\n#zeno-rocha\n\nBuku ini ditulis oleh Zeno Rocha pada tahun 2020, dia juga menginterview atau bertanya ke beberapa software engineer yang berkerja di perusahaan-perusahaan besar seperti Google, Microsoft, Spotify, Amazon dan lain lain.\n\n## Part One: Principles\n- Apa sih keunikan dari  orang-orang yang berkeja di perusahaan besar?\n- Apa yang spesial dari seseorang yang aplikasinya digunakan oleh banyak orang?\n- Bagaimana beberapa programmer bisa sangat produktif ditempat kerja dan juga diluar kerjaan mereka?\n\nPertanyaan diatas yang sedang dicari jawabannya oleh penulis, buku ini bukanlah tentang jalur kesuksesan yang pasti, akan tetapi buku ini adalah pencarian atau penyelidikan kepada programmer yang produktif diluar sana.\n\n### Why [[Habits]]?\n\nSemuanya mengenai kebiasaan, seperti yang dikatakan oleh James Clear, yang ditulis pada bukunya *atomic habits*.\n\nKebiasaan adalah *compound interest* dari perkembangan diri. Sama seperti uang yang bunga berbunga, efek dari kebiasaan akan terasa berlipatganda jika kita terus mengulanginya. \n\nDaripada kita bertanya apa bahasa pemrograman yang harus kita pelajari lebih baik tanyakan pertanyaan seperti ini:\n\n> Apa kebiasaan yang perlu saya kembangkan agar efektif dalam bahasa pemrograman apapun?\n\n## Part Two: Learning Habits\n\n### Habit 1: Look for the signals\n\nDaripada FOMO (Fear of missing out) mendingan JOMO (Joy of missing out). Senangi sesuatu yang sudah lo tau atau sudah ada. Ambil pelajarannya dan cari alternatifnya. \n\nAkan banyak orang yang terus jualan, apapun yang menurut mereka itu yang terbaik. Perlu diingat apa yang terbaik buat mereka bisa jadi gak cocok buat lo.\n\nPilihlah informasi yang sesuai dengan kebutuhan lo. Ya gak perlu se extreme, menghapus semua sosial media atau unsubsrcribe semua newsletter, ribet. digital detox seperti itu cuma membantu sementara dan bukan solusi untuk jangka panjang. Lo harus bisa membentuk kebiasaan memilih informasi yang relevan buat karir lo.\n\nTerima aja kalo lo gak bisa belajar semuanya.  Keinginan mah gak ada batasnya, kebutuhan itu terbatas. Terima aja kalo sesuatu yang baru gak selalu lebih bagus.\n\n#### Yang harus dilakukan\n\nBuatlah list dari semua teknologi dan tools yang ingin lo pelajari. Lalu labelin dengan prioritas berbeda, \"Minggu ini\", \"Bulan depan\", \"Tahun depan\". Kapanpun lo merasa ketinggalan sesuatu dari sesuatu yang lagi trend, coba check lagi list ini dan atur ulang prioritasnya.\n\n#### Pertanyaan & Jawaban\n\nQ: Bagaimana lo memutuskan teknologi yang mau dipelajari dan menginvestasikan waktu lo untuk mempelajarinya?\n\n- [Daniel Buchner](https://twitter.com/csuwildcat) (Microsoft):\n\n\tDia fokus ke beberapa pertanyaan dibawah ini\n\n\t1. Apasih kebutuhan teknikal yang sedang gw kerjakan saat ini?\n\t2. Seberapa mudah untuk orang lain dapat ikut merngerjakan apa yang gw buat? dan seperti apa mereka mengintegrasikan kedalam proyek yang sedang mereka kerjakan?\n\t3. Apakah yang saya lakukan sudah selaran dengan standar dan spesifikasi yang saya yakini akan bertahan lama?\n\n- [Addy Osmani](https://twitter.com/addyosmani) (Google)\n\t\n\tTerima aja lo gak bisa belajar semuanya, tapi lo bisa belajar untuk menjadi efektif. Saya menginvestasikan waktu disore hari. Dan selalu bertanya-tanya:\n\t\t- Apakah hal ini mengimprove produktifitas saya?\n\t\t- Apakah hal ini mengimprove user experience dari project yang biasa saya buat?\n\tKalau jawabannya iya semua, pertimbangin buat meluangkan waktu untuk belajar lebih dalam.\n\t\n\tKarena waktu itu terbatas dan banyak banget teknologi yang mesti saya coba. Lebih bagus lagi kalo kita bisa menemukan keseimbangan dari apa yang kita pilih agar tetap efektif.\n\t\n- [Loiane Groner](https://twitter.com/loiane) (Citibank)\n\n\tDia selalu bertanya beberapa pertanyan kepada dirinya sendiri.\n\t- Masalah apa yang dipecahkan oleh teknologi?\n\t\t kita sebagai developers dibawa buat menyelesaikan masalah bukan cuma nulis ocde. \n\t- Jadi masalah apa yang ingin dipecahkan sama teknologi atau framework baru ini?\n\t- Apa yang membedakan dari yang sudah ada?\n\t- Apakah saya butuh belajar sesuatu yang baru?\n\t- Bisa kah saya mengambil manfaat dari kemamupan dan pengetahuan yang sudah ada?\n\t- Bagaimana infrastructurenya? apakah ada cloud provider yang sudah support teknologi baru ini? atau infrastructure saya saat ini sudah mendukung?\n\n\tDiluar dari pertanyaan diatas, lo juga harus belajar overview dari teknologinya, mungkin coba dikantor lo atau personal project buat lo latihan menggunakan teknologi baru ini.\n\t\n\tLalu coba lihat seberapa banyak perusahaan yang menggunakan teknologi yang mau lo pelajari itu. Bikin POC, belajar semua skenario apa yang diperlukan untuk maintain project.\n\t\n### Habit 2: Focus on the fundamentals\n\nMengtip dari Michael Jordan:\n\n> You can practice shooting eight hours a day, but if your technique is wrong, then all you become is very good at shooting the wrong way. Get the fundamentals down and the level of everything you do will rise.\n\nMemahami fundamental atau inti  dari konsep itu penting. Seperti algoritma, logic, network, accessbility, security and user experience. Memang betul, kita tidak membutuhkan semuanya ketika membuat aplikasi pertama kita, tapi mengetahui fundamental ini akan membantu kita untuk membuat aplikasi yang lebih kompleks dimasa depan.\n\n#### Yang harus dilakukan\n\nLuangkan waktu untuk research fundamental konsep dari apa yang kita kerjain sekarang. Ambil kertas dan bagi mendjadi 2 kolom. Kolom sebela kiri, tuliskan apa pengetahuan yang sudah kita pahami. Dan kolom sebelah kanan isi dengan list pengetahuan yang ingin kita pahami. Rencanakan dan dedikasikan waktu untuk mempelajari konsepnya.\n\n#### Pertanyaan & Jawaban\n\nQ: Bagaimana pendekatan anda dalam mempelajari bahasa pemrograman baru hari ini?\n\n- [Lais Andrade](https://uk.linkedin.com/in/lais-andrade-55981930) (Google):\n\nPendekatan saya untuk belajar bahasa pemrograman baru sama seperti pendekatan belajar framework baru. Saya coba untuk mendapatkan perngertian dasar dari konsep dan mencari example dari hal lain yang menyelesaikan problem yang sama.\n\nDan yang paling penting adalah saya coba mengerti apa pun yang saya tulis. Baca dokumentasi dan mengerti teori dibelakangnya. Saya butuh percaya diri tentang kenapa ini adalah pilihan terbaik.\n\n- [Fabio Costa](https://twitter.com/fabiomiranda) (GoDaddy, Ex-Facebook):\n\t\n\tSaya belajar bahasa pemrograman baru dengan mengambil salah satu dari pet project saya yang sudah ada lalu tulis ulang menggunakan bahasa pemgrograman baru itu. Opini saya ini adalah cara paling efisien untuk belajar bahasa pemrograman baru, karena saya bisa fokus 100% hanya untuk belajar bahasa pemrograman.\n\t\n- [Michael Lancaster](https://twitter.com/weblancaster) (BlackBerry):\n\n\tSaya gak punya pendidikan komputer. semua berawal dari ABC (always be coding). Saya biasanya ambil tutoral dari youtube yang membuat project dan saya pilih youtuber yang membahas lebih dalam ke fundamental. Selain itu dokumentasi resmi, project unit test dan opensource project menjadi referensi saya juga.\n\t\n### Habit 3: [[Teaching]] equals [[learning]]\n\nPenulis sudah melakukan persentasi mulai dari tahun 2011, sudah 100 acara dia menjadi pembicara. Dia juga sudah pergi ke 16 negara dan 71 kota untuk presentasi. Menurut kalian ini tidak membuat saya takut ketika berbicara didepan orang banyak? hmm, seujurnya setiap saya masuk ke panggung saya tetap masih merasa takut.\n\n> Kalo lo mau belajar sesuatu, lu harus ngajajarin.\n\nDengan lu coba menjelaskan ke orang lain, lo bisa mengambil sesuatu yang paling penting untuk dibagikan kepada orang lain. Menuliskan apa yang sedang lo pelajarin itu membuat lo lebih dapat mengingat.\n\nAda banyak cara untuk mengajari orang lain, bisa posting disosial media, tulis blog dan merekam screen cast. Kalo favoritnya penulis adalah dengan mejadi pembicara.\n\n#### Yang harus dilakukan\n\nTemukan acara online dan submit presentasi. Rekam pembelajaran lo dan bagikan. Bikin blog dan bagikan artikel. Pilih topik yang mau lu pelajari dan coba untuk mengajari.\n\n#### Pertanyaan & Jawaban\n\nQ: Apakah kalian pernah mengajar didepan umum? Bagaimana itu mempengaruhi hidup kalian?\n\n- [Fernando Tadashi](https://br.linkedin.com/in/ftadashi) (Adobe):\n\n\t Saya tidak ada habit dalam memberikan pelajaran untuk audience yang besar, tapi saya berkerja di area konsulting. Audience saya selalu membutuhkan saya mengetahui maximum dari pengetahuan teknikal saya.\n\t \n- [Loiane Groner](https://twitter.com/loiane) (Citibank)\n\t\n\tSaya menjadi pembicara, menulis beberapa buku, membuat beberapa video di youtube dan selalu diundang untuk mengajar dikelas tambahan dikampus.\n\t\n\tUntuk mengetahui konsep atau teknologi dengan cara membuat  praktical project. Cara efektif lainnya adalah dengan menjelaskan ke orang lain. Dengan kata lain mengajar adalah cara yang hebat untuk belajar tentang spesifik topik.\n\t\n- [Addy Osmani](https://twitter.com/addyosmani) (Google)\n\t\n\tBenar! Mengajari orang lain mengubah lo untuk menjadi lebih baik. Memaksa lo buat kritis dan selalu bertanya.\n\t- Apakah gw benar benar paham dengan topic ini?\n\t- Bisa gak gw menjelaskan ke pemula dalam hitungan menit?\n\n\tTerkadang ketika lo perlu menjelaskan sesuatu kepada orang lain, itu menantang lo buat menyederhanakan ke ide paling utama. Ini akan memaksa lo untuk terus improve pengetahuan.\n\t\n\tMengajari orang lain membantu lo buat bertanya apakah lo beneran paham apa engga. Lo mungkin tau secara umum tapi lo tau gak lebih dalam dari topik yang paling lo minati? Apakah masuk akal buat belajar lebih jauh lagi?\n\t\n## Part Three: Daily Habits\n\n### Habit 4: Be Boring\n\nSebenarnya programmer yang bagus itu kaya gimana sih?\n\nNan untuk menjwab itu, kita perlu tau ada istilah permainan terbatas dan permainan tidak terbatas.\n\nPermainan terbatas itu seperti sepak bola ada waktu dan tujuannya. \nSesangkan permainan terbatas itu seperti pernikahan tidak ada yang akan menang atau kalah yang ada adalah bagaimana mempertahankannya.\n\n#### Yang harus dilakukan\n\nApakah kamu bermain dipermainan terbatas atau tidak terbatas?\nBerapa banyak lo meluangkan waktu untuk mengejar keuntungan jangka pendek vs menginvestasikan waktu untuk hasil yang panjang.\n\n#### Pertanyaan & Jawaban\n\nQ: Coba deh pikirin tentang programmer terbaik yang pernah kerja bareng lo. Apa yang mereka lakukan terus menerus yang membuat dia bisa bagus?\n\n- Luciano Sousa (Shopify):\n\t\n\tSaya pikir saya belajar banyak dari orang orang yang selalu memiliki jadwal/agenda yang baik dalam hidup mereka. Mereka selalu tepat waktu, memulai dan menyelesaikan perkerjaan mereka pada yang tepat setiap hari.\n\t\n\tOrang orang ini menunjukan kepada saya ahwa saya anya akan menang jika saya dapat mengatur hari saya dengan cerdas dan menghindari penundaan. Secara umum, mereka memiliki dampak positif dalam hidup saya. mendorong saya untuk selalu mecoba membangun pola kerja sehari hari yang sederhana dan lugas. tidak terlalu banyak dan tidak terlalu sedikit.\n\t\n- Berg Brandt (Amazon, Ex-Yahoo):\n\t\n\tYang paling saya hargai adalah integritas tinggi. Integritas tinggi memanifestasikan dirinya dalam berbagai bentuk dan programmer terbaik yang pernah berkerja dengan saya telah menunjukan integritas yang dingi dalam beberapa cara. Yang paling dasar adaalah fokus pada melakukan hal yang benar dan untuk alasan yang benar.\n\t\n\tProgrammer berintergitas tinggi memperhatikan hasil dan mengapa itu penting. Sementara mereka akan berlajir jika perlu,, mereka secara konsisten tanpa henti berbari menuju tuuan.\n\tMereka aalah orang orang yang secara proaktif akan memanggil jika ada sesuatu yang salah atau memanggil anda jika renaca atau arahan anda perlu penyesuaaian.\n\t\n\tmerekalah yang mengerjakan proyek yang tidak begitu glamor hanya karena penting unuk diselesaikan. Terakhir, mereka adalah orang orang yang akana berada disampng anda membantu menemukan solusi ketika dalam keadaan buruk.\n\t\n- Caio Gondim (New York Times):\n\t\n\tMenurut saya programmer terbaik adalah yang dapat diandalkan (reliable). lo gak bisa konsisten kalo gak reliable. mereka tau bahwa tidak layak berkerja sepanjang malam dan keesokan harinya tidak bisa befikir jernih.\n\t\n\tmereka tau bahwa sangat penting untuk bersenang senang dan makan dengan baik. mereka tidak memberikan estimasi dalam kondisi sempurna, karena mereka tau sangat jarang mendapatkan satu hari penuh tanpa gangguan. mereka tau bahwa akan ada meeting, sesuatu pada production dan membantu orang lain dalam membaca source code.\n\t\n- Blake Williams (GitHub):\n\t\n\tSaya melihat sebuah polah yang saya anggap sebagai programmer terbaik, semuanya disiplin. Mereka selalu punya waktu menulis kode yang baus, menambahkan cakupan pengujuan yang komperhensif dan menjelaskan detail seluk beluk melalui pesan commit message yang terperinci.\n\t\n\tprogrammer yang disiplin ini tidak berkerja sepanjang malam dan stres pada delivery fitur berikutnya. Mereka menginvestasikan waktu dalam melakukan sesuatu yang baik dan berkomunikasi dengan jelas. Disiplin itu membantu orang lain dalam tim merasa tidak terburu buru dan memungkinkan mereka menginvestasikan waktu untuk meningkatkan ppekeraan mereka yang sudah ada dari pada pindah ke tugas berikutnya. Pada akhirnya mereka menghemat waktu mereka dan tim mereka dengan memperlambat mengambil pendekatan pragmatis untuk pemecahan masalah.\n\n### Habit 5: Do It For Your Future Self\n\nJangan menjadi sok pintar, jangan mencoba membuat kode yang membuat lo merasa lebih pintar. Lo gak perlu pamer trik baru  yang baru aja lo pelajari. cukup dengan menulis kode yang dapat dibaca. Pikirin tentang maintainabilityu dan gunakan nama yang bermakna untuk variable dan function lo. Tanyakan pada diri sendiri: Apakah dimasa depan saya akan paham kode maksud dari kode ini?\n\n#### Yang harus dilakukan\n\nBuka project yang sedang lo kerjakan. Apakah ada refactoring yang bisa lo lakukan untuk membuat kehidupan dimasa depan jadi lebih mudah?\n\n#### Pertanyaan & Jawaban\n\nQ: Hal-hal apa yang lo lakukan dihari ini untuk membantu lo dimasa depan?\n\n- Silvio Gustavo (Spotify):\n\n\tSaya mencoba berempati dengan siapapun yang dapat menyentuh kode itu dimasa depan, termasuk diri saya dimasa depan. Apakah kode ini dapt dibaca oleh siapa pun dengan tingkat pengalaman apapun? Dengan pemikiran itu saya menargetkan.\n\t\n\t1. Tulis kode sederhana dengan nama variabel/method/class yang bermakna. Jangan berasumsi bahwa orang lain (termasuk lo) akan memahami nama pendek yang tidak berarti banyak.\n\t2. Punya automated testuang baik, ini akan memberikan dokumentasi tambahan tentang kode anda dan juga membantu siapa saja yang perlu menyentuh kode itu dimasa depan.\n\t3. Gunakan version control sebagai dokumentasi. Ketika proyek berkembang, perubahan dan pebaikan bug dilakukan setiap saat. Dimasa depan ketika itu menjadi legacy code tidak ada yang bisa memahamu keputusan dan perubahan yang dibuat saat itu jika tidak didokumentasikan.\n\n-  Lais Andrade (Google):\n\n\tSalah satu hal terbaik untuk menjaga basis kode dimasa depan adalah memiliki standar yang baik untuk praktik terbaik dan ini haru diikuti oleh tim. \n\t\n\t early optimization is the root of all evil. Sangat mudah menulis satu baris tanpa komentar, tapi nanti akan sulit untuk mendebug kode itu dalam waktu beberapa minggu, bulan atau tahun.\n\t Peer review juga sangat penting.\n\t \n\t Test semua kode yang lo tulis. Unit test,integration, performace/benchmark test. semuanya. Bikin aturan semuakode harus ada testnya.\n\n\n\n### Habit 6: Your 9-to-5 Is Not Enough\n\nmenurut penulis jam 9  ke 5 ini gak cukup untuk untuk berkari didunia teknologi.\n\n#### Yang harus dilakukan\n\nPikirkan tentang keterampilan yang menurut lo dapat ditingkatkan. Bisakah lo merencanakan waktu ekstra untuk mengembangkannya? 10 menit sehari juga tidak apa apa itu juga bisa membuat pebedaan.\n\n#### Pertanyaan & Jawaban\n\nQ: Bagaimana lo menghabiskan waktu luang? Bagaimana lo menyeimbangkan personal dan perkerjaan?\n\n- Silvio Gustavo (Spotify):\n\n\tSaya dulu menghabiskan waktu dengan menyelam lebih dalam pada internal android , best practice dan arsitektur code. ini sudah seperti hobi buat saya.\n\t\n\tPada titik tertentu, meskipun saya suka, tapi terkadan merasa tsres ketika menggabungkannya dengan pekerjaan 9-5. saya kemudian memutuskan untuk memperlambat dan menggunakan waktu luang saya untuk melakukan lebih banyak ha; seperti main game dan mempelajari hobi baru dan berolahraga. Saya memili keseimbangan kehidupan kerja yang jauh lebih baik saat ini.\n\t\n- Fernando Tadashi (Adobe):\n\t\n\tSaya mendedikasikan waktu saya untuk tau teknologi baru dan yang masih digunakan. terkadang saya belajar lebih dalam.\n\t\n- Fabio Costa (GoDaddy, Ex-Facebook):\n\n\tPada akhir pekan saya cenderung lebih banyak bekumpul dengan keluarga dan teman teman atau mengerjakan pet project.\n\n\n## Part Four: Career Habits\n\n### Habit 7: Master The Dark Side\n\nJaman dulu belajar bahasa pemrograman itu cuma ada di universitas yang bagus bagus saja. saat ini suah berbeda tidak perlu ke universitas sudah banyak bootcamp , tutorial dan kurus menjadi programmer.\n\nPada dasarnya programmer adalah penerjemah, tugas kita adalah menerjemahkan kebutuhan pengguna kedalam fungsi. Biasanya kebutuhan itu akan dibuat oleh BA (bisnis analis). Pada awalnya saya merasa orang bisnis itu seperti orang jahat tidak peduli dengan kualitas kode saya, tapi pada akhirnya saya menyadari ssi bisnis dapat membatu saya dalam aktifitas sehari hari.\n\n1. Hemat Waktu: Semakin lo paham bisnis, semakin mampu lo untuk memecahkan masalah itu sendir. \n2. Mencegah kode yang rumit: Kita selalu ingin membuat kode yang abstrak, fleksibel dapat diextend dan dapat digunakan kembali. Kita sangat ingin seperti itu hingga kita membuat aplikasi yang terlalu rumit.\n3. Prioritas yang lebih baik: Dengan pengethuan bisnis akan lebih mudah untuk memprioritaskan keputusan mikro. Lo bisa mengantisipasi mana bagian yang lebih penting.\n\nRekomendasi saya adalah mulai dengan kosakata atau vocabulary. Perhatikan kata dan istilah kusus yang digunakan oleh para pebisnis. Jika lo meniru terminologi yang sama komunikasi dengan mereka akan jauh lebih baik.\n\nIngat, orang yang tau cara membuat kode iti kuat, orang yang tau membuat kode dan tau cari kejar bisnis tidak dapat dihentikan.\n\n#### Yang harus dilakukan\n\nElaborasi daftar istilah yang paling umum digunakan dalam industri lo. Mulailah percakapan dengan teman kerja lo untuk memahami bidang mereka. Misalnya, Sales funnel itu seperti apa? Market yang niche apa yang sedang ditargetkan? Apa pertannyaan paling umum untuk customer suport? bagaimana produk kita berbeda dengan produk kompetitor?\n\n#### Pertanyaan & Jawaban\n\nQ: Apakah kalian mencoba untuk mengerti dari sisi bisnis sebelum programming sesuatu?\n\n- Michael Lancaster (BlackBerry):\n\n\tTergantung pada kerumitan pekeraan dan waktu. Karena kadang kita juga bisa menyelesaikan pekerjaan tanpa tau bisnis sama sekali.\n\t\n\tKarena itu, semakin banyak kami tau tentangbinis ini, semakin berharga kami bagi tim karena itu memungkinkan kami untuk menggunakan pengetahuan teknnis dan bisnis kami untuk memberikan kontribusi lebih besar.\n\t\n### Habit 8: [[Side Projects]]\n\nPasti kalian sudah tau kalo twitter, craiglist dan slack dimulai sebagai side project. ya side project, yang bisa sebesar sekarang. Side project dapat membantu kita mengembangkan portofolio lo, membuat resume, memamerkan keahlian lo. \n\nKalo lo udah mapan dalam karir lo, side project bisa sangat berguna. memungkinkan lo untuk mengalami dan mempelajari keterampilan baru yang mungkin gak ada dikerjaan lo. Juga gak ada tekanan, jadwal atau spesifikasi yang dipaksakan oleh  siapapun, yang artinya  lo bisa menggunakan semua kreativitas lo dan bersenang senang melakukannya.\n\nLangkah apa yang selanjutnya? Ide apa yang layak dikerjakan?\n\nIni adalah daftar pertanyaan yang biasanya gw tanyakan ke dirisendiri sebelum memulai project sampingan baru.\n\n1. Side project berarti lo harus mengorbankan waktu pribadi untuk mengerjakan project itu. Pertanyaannya:\n\n\t> Apakah saya benar benar menikmati subject, bidang pada jenis pekerjaan ini?\n\t\n\tJika jawabannya **tidak**, ya gak usah, kalau dikerjakan pun gak dapet apa apa dan biasanya terbengkalai.\n\n2. Butuh waktu untuk side project untuk mendapkatkan traction, pertanyaannya:\n\t\n\t> Apakah saya bersedia setidaknya 5 tahun untuk mengerjakan ide ini?\n\n\tKalau jawabannya **tidak**, kemungkinan besar anda akan kehilangan motivasi dan akan menyerah pada proyek inisebelum dimulai. namun, jika tujuan lo hanya untuk bereksperimen ya gak perlu khawatir.\n\n3. Memiliki ide adalah sau hal, memiliki kemampuan untuk mengeksekusi ide itu sama sekali berbeda, jadi lo harus tanya ke diri sendiri. \n\t\n\t> Bisakah saya menjalankan ide ini sendirian?\n\n\tKalau jawabannya **tidak**, lo perlu mempertimbangkan untuk mempelajari keterampilan baru atau mengundang seorang teman untuk mengisi kekosongan tersebut.\n\t\n4. Mengatakan **Ya** untuk satu ide berarti mengatakan tidak untuk banyak ide lain. Jadi tanyakan sama diri lo\n\n\t> Apakah ide ini lebih baik dari ide lain?\n\t> Apakah ada ide lain yang dapat menggunakan waktu saya dengan baik?\n\t\n\tKalau jawabannya **tidak**,  ulangi siklus ini untuk ide yang lain.\n\n5. Memahamu untuk siapa lo membangun solusi ini, Jika lo gak kenal audiens lo kemungkinan besar lo gak akan memahami kebutuhan mereka. jadi tanyakan pada diri lo:\n\n\t> Apakah saya secara pribadi mengalami hal ini atau saya memecahkannya untuk orang lain?\n\n\tKalau jawabannya **tidak**,  maka pertimbangkan untuk menjangkau orang orang yang benar benar mengalami rasa sakit yang coba anda selesaikan.\n\t\n6. Dan pertanyaan terakhir adalah \n\t\n\t> Mengapa saya senang dengan ide ini sekarang?\n\t> Apakah lo pengen mempelajari teknologi baru?\n\t> Apakah lo ingin menghasilkan lebih banyak uang?\n\t> Apakah lo membutuhkan pengalian dari masalah lain?\n\n\tJujur pada diri sendiri. Hal yang lebih penting dari memilih ide adalah memilih scope dari project lo.\n\n#### Yang harus dilakukan\n\nSelama beberapa hari kedepan perhatikan aplikasi yang sering lo gunakan. Apakah yang kurang dari mereka? Apakah lo dapat membuat versi lebih baik dari itu\n\n#### Pertanyaan & Jawaban\n\n### Habit 9: Mario or Sonic?\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n## Part Five: Team Habits\n\n### Habit 10: Active Listening\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n### Habit 11: Don’t Underestimate\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n### Habit 12: Specialist vs. Generalist\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n## Part Six: Life Habits\n\n### Habit 13: Control Your Variables\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n### Habit 14: Stop Waiting\n#### Yang harus dilakukan\n#### Pertanyaan & Jawaban\n\n## Part Seven: The End\n","n":0.018}}}]}
